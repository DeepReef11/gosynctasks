
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>backend: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">gosynctasks/backend/errors.go (0.0%)</option>
				
				<option value="file1">gosynctasks/backend/git/backend.go (25.2%)</option>
				
				<option value="file2">gosynctasks/backend/git/markdown_parser.go (89.9%)</option>
				
				<option value="file3">gosynctasks/backend/git/markdown_writer.go (90.2%)</option>
				
				<option value="file4">gosynctasks/backend/nextcloud/backend.go (64.9%)</option>
				
				<option value="file5">gosynctasks/backend/nextcloud/vtodo_parser.go (82.4%)</option>
				
				<option value="file6">gosynctasks/backend/registry.go (53.6%)</option>
				
				<option value="file7">gosynctasks/backend/selector.go (85.3%)</option>
				
				<option value="file8">gosynctasks/backend/sqlite/backend.go (74.6%)</option>
				
				<option value="file9">gosynctasks/backend/sqlite/database.go (69.4%)</option>
				
				<option value="file10">gosynctasks/backend/sqlite/schema.go (100.0%)</option>
				
				<option value="file11">gosynctasks/backend/sync/manager.go (69.6%)</option>
				
				<option value="file12">gosynctasks/backend/taskManager.go (66.1%)</option>
				
				<option value="file13">gosynctasks/backend/testing_helpers.go (40.7%)</option>
				
				<option value="file14">gosynctasks/backend/todoist/api.go (0.0%)</option>
				
				<option value="file15">gosynctasks/backend/todoist/backend.go (13.6%)</option>
				
				<option value="file16">gosynctasks/backend/todoist/mapper.go (12.3%)</option>
				
				<option value="file17">gosynctasks/cmd/gosynctasks/background_sync.go (0.0%)</option>
				
				<option value="file18">gosynctasks/cmd/gosynctasks/credentials.go (0.0%)</option>
				
				<option value="file19">gosynctasks/cmd/gosynctasks/list.go (0.0%)</option>
				
				<option value="file20">gosynctasks/cmd/gosynctasks/main.go (0.0%)</option>
				
				<option value="file21">gosynctasks/cmd/gosynctasks/sync.go (0.0%)</option>
				
				<option value="file22">gosynctasks/cmd/gosynctasks/view.go (0.0%)</option>
				
				<option value="file23">gosynctasks/internal/app/app.go (20.2%)</option>
				
				<option value="file24">gosynctasks/internal/cache/cache.go (81.4%)</option>
				
				<option value="file25">gosynctasks/internal/config/config.go (60.5%)</option>
				
				<option value="file26">gosynctasks/internal/credentials/env.go (87.5%)</option>
				
				<option value="file27">gosynctasks/internal/credentials/keyring.go (0.0%)</option>
				
				<option value="file28">gosynctasks/internal/credentials/resolver.go (78.3%)</option>
				
				<option value="file29">gosynctasks/internal/operations/actions.go (0.0%)</option>
				
				<option value="file30">gosynctasks/internal/operations/actions_unix.go (0.0%)</option>
				
				<option value="file31">gosynctasks/internal/operations/lists.go (0.0%)</option>
				
				<option value="file32">gosynctasks/internal/operations/subtasks.go (35.6%)</option>
				
				<option value="file33">gosynctasks/internal/operations/tasks.go (38.2%)</option>
				
				<option value="file34">gosynctasks/internal/utils/inputs.go (18.6%)</option>
				
				<option value="file35">gosynctasks/internal/utils/output.go (88.9%)</option>
				
				<option value="file36">gosynctasks/internal/utils/validation.go (0.0%)</option>
				
				<option value="file37">gosynctasks/internal/views/builder/builder.go (0.0%)</option>
				
				<option value="file38">gosynctasks/internal/views/builder/model.go (65.3%)</option>
				
				<option value="file39">gosynctasks/internal/views/builder/types.go (88.5%)</option>
				
				<option value="file40">gosynctasks/internal/views/builder/views.go (7.4%)</option>
				
				<option value="file41">gosynctasks/internal/views/fields.go (100.0%)</option>
				
				<option value="file42">gosynctasks/internal/views/filter.go (85.4%)</option>
				
				<option value="file43">gosynctasks/internal/views/formatters/base.go (66.7%)</option>
				
				<option value="file44">gosynctasks/internal/views/formatters/date.go (0.0%)</option>
				
				<option value="file45">gosynctasks/internal/views/formatters/plugin.go (85.4%)</option>
				
				<option value="file46">gosynctasks/internal/views/formatters/priority.go (0.0%)</option>
				
				<option value="file47">gosynctasks/internal/views/formatters/status.go (89.3%)</option>
				
				<option value="file48">gosynctasks/internal/views/formatters/text.go (0.0%)</option>
				
				<option value="file49">gosynctasks/internal/views/loader.go (76.7%)</option>
				
				<option value="file50">gosynctasks/internal/views/renderer.go (65.7%)</option>
				
				<option value="file51">gosynctasks/internal/views/resolver.go (88.1%)</option>
				
				<option value="file52">gosynctasks/internal/views/storage.go (28.1%)</option>
				
				<option value="file53">gosynctasks/internal/views/validation.go (72.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package backend

import "fmt"

// BackendError represents an error from a backend operation
// It provides structured error information including HTTP status codes,
// operation context, and the underlying error message
type BackendError struct {
        Operation  string // e.g., "DeleteTask", "GetTasks", "UpdateTask"
        StatusCode int    // HTTP status code (0 if not an HTTP error)
        Message    string // Human-readable error message
        TaskUID    string // Optional: affected task UID
        ListID     string // Optional: affected list ID
        Body       string // Optional: response body for debugging
        Err        error  // Optional: underlying error
}

// Error implements the error interface
func (e *BackendError) Error() string <span class="cov0" title="0">{
        if e.StatusCode &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s failed with status %d: %s", e.Operation, e.StatusCode, e.Message)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s failed: %s", e.Operation, e.Message)</span>
}

// Unwrap returns the underlying error for error wrapping
func (e *BackendError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// IsNotFound returns true if the error is a 404 Not Found
func (e *BackendError) IsNotFound() bool <span class="cov0" title="0">{
        return e.StatusCode == 404
}</span>

// IsUnauthorized returns true if the error is a 401 Unauthorized or 403 Forbidden
func (e *BackendError) IsUnauthorized() bool <span class="cov0" title="0">{
        return e.StatusCode == 401 || e.StatusCode == 403
}</span>

// IsServerError returns true if the error is a 5xx server error
func (e *BackendError) IsServerError() bool <span class="cov0" title="0">{
        return e.StatusCode &gt;= 500 &amp;&amp; e.StatusCode &lt; 600
}</span>

// NewBackendError creates a new BackendError
func NewBackendError(operation string, statusCode int, message string) *BackendError <span class="cov0" title="0">{
        return &amp;BackendError{
                Operation:  operation,
                StatusCode: statusCode,
                Message:    message,
        }
}</span>

// WithTaskUID adds task UID to the error for context
func (e *BackendError) WithTaskUID(uid string) *BackendError <span class="cov0" title="0">{
        e.TaskUID = uid
        return e
}</span>

// WithListID adds list ID to the error for context
func (e *BackendError) WithListID(listID string) *BackendError <span class="cov0" title="0">{
        e.ListID = listID
        return e
}</span>

// WithBody adds the response body to the error for debugging
func (e *BackendError) WithBody(body string) *BackendError <span class="cov0" title="0">{
        e.Body = body
        return e
}</span>

// WithError wraps an underlying error
func (e *BackendError) WithError(err error) *BackendError <span class="cov0" title="0">{
        e.Err = err
        return e
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package git

import (
        "gosynctasks/backend"
        "crypto/rand"
        "encoding/hex"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "time"
)

func init() <span class="cov1" title="1">{
        // Register Git backend for config type "git"
        // Git backend supports auto-detection
        backend.RegisterDetectable("git", newGitBackendWrapper)
}</span>

// newGitBackendWrapper wraps NewGitBackend to match BackendConfigConstructor signature
func newGitBackendWrapper(config backend.BackendConfig) (backend.TaskManager, error) <span class="cov0" title="0">{
        return NewGitBackend(config)
}</span>

// GitBackend implements backend.TaskManager for git repositories with markdown task files.
// Tasks are stored in markdown format with a special marker to enable gosynctasks.
type GitBackend struct {
        config       backend.BackendConfig
        RepoPath     string            // Absolute path to git repository root
        FilePath     string            // Absolute path to task file (e.g., TODO.md)
        taskLists    map[string][]backend.Task // Tasks organized by list name (## headers)
        fileModTime  time.Time         // Last modification time of file
        detectedInfo string            // Human-readable detection info
}

const (
        // Marker that must be present in markdown file to enable gosynctasks
        gitBackendMarker = "&lt;!-- gosynctasks:enabled --&gt;"
)

// NewGitBackend creates a new Git backend instance.
func NewGitBackend(config backend.BackendConfig) (*GitBackend, error) <span class="cov0" title="0">{
        gb := &amp;GitBackend{
                config:    config,
                taskLists: make(map[string][]backend.Task),
        }

        // Find git repository
        repoPath, err := gb.findGitRepo()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("git repository not found: %w", err)
        }</span>
        <span class="cov0" title="0">gb.RepoPath = repoPath

        // Find TODO file
        filePath, err := gb.findTodoFile()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("TODO file not found: %w", err)
        }</span>
        <span class="cov0" title="0">gb.FilePath = filePath

        // Load tasks from file
        if err := gb.loadFile(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load tasks: %w", err)
        }</span>

        <span class="cov0" title="0">gb.detectedInfo = fmt.Sprintf("Git repository at %s with task file %s",
                filepath.Base(gb.RepoPath), filepath.Base(gb.FilePath))

        return gb, nil</span>
}

// findGitRepo finds the git repository root by walking up the directory tree.
func (gb *GitBackend) findGitRepo() (string, error) <span class="cov1" title="1">{
        // Start from current working directory
        dir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Walk up directory tree looking for .git
        <span class="cov1" title="1">for </span><span class="cov5" title="3">{
                gitDir := filepath.Join(dir, ".git")
                if info, err := os.Stat(gitDir); err == nil </span><span class="cov1" title="1">{
                        // Found .git directory or file (submodule)
                        if info.IsDir() || !info.IsDir() </span><span class="cov1" title="1">{
                                return dir, nil
                        }</span>
                }

                // Move to parent directory
                <span class="cov3" title="2">parent := filepath.Dir(dir)
                if parent == dir </span><span class="cov0" title="0">{
                        // Reached root without finding .git
                        break</span>
                }
                <span class="cov3" title="2">dir = parent</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("not in a git repository")</span>
}

// findTodoFile searches for the task file based on config.
func (gb *GitBackend) findTodoFile() (string, error) <span class="cov0" title="0">{
        // Build list of files to try
        filesToTry := []string{}

        // Add configured file if specified
        if gb.config.File != "" </span><span class="cov0" title="0">{
                filesToTry = append(filesToTry, gb.config.File)
        }</span>

        // Add fallback files
        <span class="cov0" title="0">if len(gb.config.FallbackFiles) &gt; 0 </span><span class="cov0" title="0">{
                filesToTry = append(filesToTry, gb.config.FallbackFiles...)
        }</span>

        // Default fallbacks if nothing configured
        <span class="cov0" title="0">if len(filesToTry) == 0 </span><span class="cov0" title="0">{
                filesToTry = []string{"TODO.md", "todo.md", ".gosynctasks.md"}
        }</span>

        // Try each file
        <span class="cov0" title="0">for _, filename := range filesToTry </span><span class="cov0" title="0">{
                fullPath := filepath.Join(gb.RepoPath, filename)
                if info, err := os.Stat(fullPath); err == nil &amp;&amp; !info.IsDir() </span><span class="cov0" title="0">{
                        // File exists, check for marker
                        content, err := os.ReadFile(fullPath)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">if gb.hasMarker(string(content)) </span><span class="cov0" title="0">{
                                return fullPath, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return "", fmt.Errorf("no TODO file with gosynctasks marker found (tried: %s)",
                strings.Join(filesToTry, ", "))</span>
}

// hasMarker checks if content contains the gosynctasks marker.
func (gb *GitBackend) hasMarker(content string) bool <span class="cov5" title="3">{
        return strings.Contains(content, gitBackendMarker)
}</span>

// loadFile reads and parses the markdown file.
func (gb *GitBackend) loadFile() error <span class="cov0" title="0">{
        content, err := os.ReadFile(gb.FilePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get file modification time
        <span class="cov0" title="0">info, err := os.Stat(gb.FilePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">gb.fileModTime = info.ModTime()

        // Parse markdown
        parser := NewMarkdownParser()
        taskLists, err := parser.Parse(string(content))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">gb.taskLists = taskLists
        return nil</span>
}

// saveFile writes tasks back to the markdown file.
func (gb *GitBackend) saveFile() error <span class="cov0" title="0">{
        writer := NewMarkdownWriter()
        content := writer.Write(gb.taskLists)

        // Check if file was modified externally
        if info, err := os.Stat(gb.FilePath); err == nil </span><span class="cov0" title="0">{
                if info.ModTime().After(gb.fileModTime) </span><span class="cov0" title="0">{
                        return fmt.Errorf("file was modified externally, refusing to overwrite")
                }</span>
        }

        // Write to file
        <span class="cov0" title="0">if err := os.WriteFile(gb.FilePath, []byte(content), 0644); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update modification time
        <span class="cov0" title="0">if info, err := os.Stat(gb.FilePath); err == nil </span><span class="cov0" title="0">{
                gb.fileModTime = info.ModTime()
        }</span>

        // Auto-commit if enabled
        <span class="cov0" title="0">if gb.config.AutoCommit </span><span class="cov0" title="0">{
                return gb.commitChanges()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// commitChanges commits the task file to git.
func (gb *GitBackend) commitChanges() error <span class="cov0" title="0">{
        // Add file
        cmd := exec.Command("git", "add", gb.FilePath)
        cmd.Dir = gb.RepoPath
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("git add failed: %w", err)
        }</span>

        // Check if there are changes to commit
        <span class="cov0" title="0">cmd = exec.Command("git", "diff", "--cached", "--quiet")
        cmd.Dir = gb.RepoPath
        if err := cmd.Run(); err == nil </span><span class="cov0" title="0">{
                // No changes to commit
                return nil
        }</span>

        // Commit
        <span class="cov0" title="0">commitMsg := fmt.Sprintf("gosynctasks: Update tasks in %s", filepath.Base(gb.FilePath))
        cmd = exec.Command("git", "commit", "-m", commitMsg)
        cmd.Dir = gb.RepoPath
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("git commit failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// generateUID generates a unique task ID.
func (gb *GitBackend) generateUID() string <span class="cov3" title="2">{
        timestamp := time.Now().Unix()
        randomBytes := make([]byte, 4)
        _, _ = rand.Read(randomBytes)
        randomHex := hex.EncodeToString(randomBytes)
        return fmt.Sprintf("task-%d-%s", timestamp, randomHex)
}</span>

// CanDetect checks if this backend can be used in the current environment.
func (gb *GitBackend) CanDetect() (bool, error) <span class="cov0" title="0">{
        // Try to find git repo
        if _, err := gb.findGitRepo(); err != nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        // Try to find TODO file
        <span class="cov0" title="0">if _, err := gb.findTodoFile(); err != nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

// DetectionInfo returns human-readable detection information.
func (gb *GitBackend) DetectionInfo() string <span class="cov0" title="0">{
        return gb.detectedInfo
}</span>

// GetTaskLists retrieves all task lists (headers) from the markdown file.
func (gb *GitBackend) GetTaskLists() ([]backend.TaskList, error) <span class="cov0" title="0">{
        // Reload file to get latest changes
        if err := gb.loadFile(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var lists []backend.TaskList
        for name := range gb.taskLists </span><span class="cov0" title="0">{
                lists = append(lists, backend.TaskList{
                        ID:          name,
                        Name:        name,
                        Description: fmt.Sprintf("%d tasks", len(gb.taskLists[name])),
                })
        }</span>

        <span class="cov0" title="0">return lists, nil</span>
}

// GetTasks retrieves tasks from a specific list with optional filtering.
func (gb *GitBackend) GetTasks(listID string, filter *backend.TaskFilter) ([]backend.Task, error) <span class="cov0" title="0">{
        // Reload file to get latest changes
        if err := gb.loadFile(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tasks, exists := gb.taskLists[listID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("task list %q not found", listID)
        }</span>

        // Apply filter if provided
        <span class="cov0" title="0">if filter != nil </span><span class="cov0" title="0">{
                tasks = gb.filterTasks(tasks, filter)
        }</span>

        // Sort tasks
        <span class="cov0" title="0">gb.SortTasks(tasks)

        return tasks, nil</span>
}

// filterTasks applies a backend.TaskFilter to a slice of tasks.
func (gb *GitBackend) filterTasks(tasks []backend.Task, filter *backend.TaskFilter) []backend.Task <span class="cov5" title="3">{
        var filtered []backend.Task

        for _, task := range tasks </span><span class="cov9" title="9">{
                // Check status filter
                if filter.Statuses != nil &amp;&amp; len(*filter.Statuses) &gt; 0 </span><span class="cov5" title="3">{
                        matchesStatus := false
                        for _, status := range *filter.Statuses </span><span class="cov5" title="3">{
                                if task.Status == status </span><span class="cov3" title="2">{
                                        matchesStatus = true
                                        break</span>
                                }
                        }
                        <span class="cov5" title="3">if !matchesStatus </span><span class="cov1" title="1">{
                                continue</span>
                        }
                }

                // Check due date filters
                <span class="cov9" title="8">if filter.DueAfter != nil &amp;&amp; !task.DueDate.IsZero() </span><span class="cov5" title="3">{
                        if task.DueDate.Before(*filter.DueAfter) </span><span class="cov1" title="1">{
                                continue</span>
                        }
                }

                <span class="cov8" title="7">if filter.DueBefore != nil &amp;&amp; !task.DueDate.IsZero() </span><span class="cov0" title="0">{
                        if task.DueDate.After(*filter.DueBefore) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                // Check created after filter
                <span class="cov8" title="7">if filter.CreatedAfter != nil &amp;&amp; !task.Created.IsZero() </span><span class="cov5" title="3">{
                        if task.Created.Before(*filter.CreatedAfter) </span><span class="cov3" title="2">{
                                continue</span>
                        }
                }

                <span class="cov7" title="5">filtered = append(filtered, task)</span>
        }

        <span class="cov5" title="3">return filtered</span>
}

// FindTasksBySummary searches for tasks by summary text.
func (gb *GitBackend) FindTasksBySummary(listID string, summary string) ([]backend.Task, error) <span class="cov0" title="0">{
        tasks, err := gb.GetTasks(listID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">summary = strings.ToLower(summary)
        var matches []backend.Task

        for _, task := range tasks </span><span class="cov0" title="0">{
                if strings.Contains(strings.ToLower(task.Summary), summary) </span><span class="cov0" title="0">{
                        matches = append(matches, task)
                }</span>
        }

        <span class="cov0" title="0">return matches, nil</span>
}

// AddTask creates a new task in the specified list.
func (gb *GitBackend) AddTask(listID string, task backend.Task) error <span class="cov0" title="0">{
        // Reload file to get latest changes
        if err := gb.loadFile(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Generate UID if not provided
        <span class="cov0" title="0">if task.UID == "" </span><span class="cov0" title="0">{
                task.UID = gb.generateUID()
        }</span>

        // Set timestamps
        <span class="cov0" title="0">if task.Created.IsZero() </span><span class="cov0" title="0">{
                task.Created = time.Now()
        }</span>
        <span class="cov0" title="0">task.Modified = time.Now()

        // Add task to list
        gb.taskLists[listID] = append(gb.taskLists[listID], task)

        // Save file
        return gb.saveFile()</span>
}

// UpdateTask modifies an existing task.
func (gb *GitBackend) UpdateTask(listID string, task backend.Task) error <span class="cov0" title="0">{
        // Reload file to get latest changes
        if err := gb.loadFile(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">tasks, exists := gb.taskLists[listID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("task list %q not found", listID)
        }</span>

        // Find and update task
        <span class="cov0" title="0">found := false
        for i, t := range tasks </span><span class="cov0" title="0">{
                if t.UID == task.UID </span><span class="cov0" title="0">{
                        task.Modified = time.Now()
                        tasks[i] = task
                        found = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                return backend.NewBackendError("UpdateTask", 404, fmt.Sprintf("task %q not found", task.UID))
        }</span>

        <span class="cov0" title="0">gb.taskLists[listID] = tasks

        // Save file
        return gb.saveFile()</span>
}

// DeleteTask removes a task from the specified list.
func (gb *GitBackend) DeleteTask(listID string, taskUID string) error <span class="cov0" title="0">{
        // Reload file to get latest changes
        if err := gb.loadFile(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">tasks, exists := gb.taskLists[listID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("task list %q not found", listID)
        }</span>

        // Find and remove task
        <span class="cov0" title="0">found := false
        for i, t := range tasks </span><span class="cov0" title="0">{
                if t.UID == taskUID </span><span class="cov0" title="0">{
                        tasks = append(tasks[:i], tasks[i+1:]...)
                        found = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                return backend.NewBackendError("DeleteTask", 404, fmt.Sprintf("task %q not found", taskUID))
        }</span>

        <span class="cov0" title="0">gb.taskLists[listID] = tasks

        // Save file
        return gb.saveFile()</span>
}

// CreateTaskList creates a new task list (header) in the markdown file.
func (gb *GitBackend) CreateTaskList(name, description, color string) (string, error) <span class="cov0" title="0">{
        // Reload file to get latest changes
        if err := gb.loadFile(); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Check if list already exists
        <span class="cov0" title="0">if _, exists := gb.taskLists[name]; exists </span><span class="cov0" title="0">{
                return "", fmt.Errorf("task list %q already exists", name)
        }</span>

        // Create empty list
        <span class="cov0" title="0">gb.taskLists[name] = []backend.Task{}

        // Save file
        if err := gb.saveFile(); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return name, nil</span>
}

// DeleteTaskList removes a task list (header) and all its tasks from the markdown file.
func (gb *GitBackend) DeleteTaskList(listID string) error <span class="cov0" title="0">{
        // Reload file to get latest changes
        if err := gb.loadFile(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if list exists
        <span class="cov0" title="0">if _, exists := gb.taskLists[listID]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("task list %q not found", listID)
        }</span>

        // Delete list
        <span class="cov0" title="0">delete(gb.taskLists, listID)

        // Save file
        return gb.saveFile()</span>
}

// RenameTaskList changes the name of a task list (header) in the markdown file.
func (gb *GitBackend) RenameTaskList(listID, newName string) error <span class="cov0" title="0">{
        // Reload file to get latest changes
        if err := gb.loadFile(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if old list exists
        <span class="cov0" title="0">tasks, exists := gb.taskLists[listID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("task list %q not found", listID)
        }</span>

        // Check if new name already exists
        <span class="cov0" title="0">if _, exists := gb.taskLists[newName]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("task list %q already exists", newName)
        }</span>

        // Rename by deleting old and creating new
        <span class="cov0" title="0">delete(gb.taskLists, listID)
        gb.taskLists[newName] = tasks

        // Save file
        return gb.saveFile()</span>
}

// ParseStatusFlag converts user input to backend status format.
func (gb *GitBackend) ParseStatusFlag(statusFlag string) (string, error) <span class="cov10" title="10">{
        // Git backend uses app-style status names
        upper := strings.ToUpper(statusFlag)

        // Handle abbreviations
        switch upper </span>{
        case "T":<span class="cov1" title="1">
                return "TODO", nil</span>
        case "D":<span class="cov1" title="1">
                return "DONE", nil</span>
        case "P":<span class="cov1" title="1">
                return "PROCESSING", nil</span>
        case "C":<span class="cov1" title="1">
                return "CANCELLED", nil</span>
        }

        // Handle full names
        <span class="cov8" title="6">switch upper </span>{
        case "TODO", "DONE", "PROCESSING", "CANCELLED":<span class="cov6" title="4">
                return upper, nil</span>
        }

        <span class="cov3" title="2">return "", fmt.Errorf("invalid status flag: %s (use TODO/T, DONE/D, PROCESSING/P, CANCELLED/C)", statusFlag)</span>
}

// StatusToDisplayName converts backend status to display name.
func (gb *GitBackend) StatusToDisplayName(backendStatus string) string <span class="cov0" title="0">{
        // Git backend already uses display names
        return backendStatus
}</span>

// SortTasks sorts tasks by priority (1=highest) and creation date.
func (gb *GitBackend) SortTasks(tasks []backend.Task) <span class="cov1" title="1">{
        // Simple bubble sort (good enough for typical task lists)
        for i := 0; i &lt; len(tasks); i++ </span><span class="cov7" title="5">{
                for j := i + 1; j &lt; len(tasks); j++ </span><span class="cov10" title="10">{
                        // Priority 0 goes last
                        iPrio := tasks[i].Priority
                        jPrio := tasks[j].Priority
                        if iPrio == 0 </span><span class="cov6" title="4">{
                                iPrio = 100
                        }</span>
                        <span class="cov10" title="10">if jPrio == 0 </span><span class="cov0" title="0">{
                                jPrio = 100
                        }</span>

                        // Lower priority number = higher priority
                        <span class="cov10" title="10">if iPrio &gt; jPrio </span><span class="cov6" title="4">{
                                tasks[i], tasks[j] = tasks[j], tasks[i]
                        }</span> else<span class="cov8" title="6"> if iPrio == jPrio </span><span class="cov1" title="1">{
                                // Same priority, sort by creation date (older first)
                                if tasks[i].Created.After(tasks[j].Created) </span><span class="cov0" title="0">{
                                        tasks[i], tasks[j] = tasks[j], tasks[i]
                                }</span>
                        }
                }
        }
}

// GetPriorityColor returns ANSI color code for priority.
func (gb *GitBackend) GetPriorityColor(priority int) string <span class="cov8" title="7">{
        // Similar to Nextcloud coloring
        switch </span>{
        case priority &gt;= 1 &amp;&amp; priority &lt;= 4:<span class="cov3" title="2">
                return "\033[31m"</span> // Red (high priority)
        case priority == 5:<span class="cov1" title="1">
                return "\033[33m"</span> // Yellow (medium priority)
        case priority &gt;= 6 &amp;&amp; priority &lt;= 9:<span class="cov3" title="2">
                return "\033[34m"</span> // Blue (low priority)
        default:<span class="cov3" title="2">
                return ""</span> // No color (undefined priority)
        }
}

// GetBackendDisplayName returns a formatted string for display in task list headers.
func (gb *GitBackend) GetBackendDisplayName() string <span class="cov0" title="0">{
        repoName := filepath.Base(gb.RepoPath)
        fileName := filepath.Base(gb.FilePath)
        return fmt.Sprintf("[git:%s/%s]", repoName, fileName)
}</span>

// GetBackendType returns the backend type identifier.
func (gb *GitBackend) GetBackendType() string <span class="cov0" title="0">{
        return "git"
}</span>

// GetBackendContext returns contextual details specific to the backend.
func (gb *GitBackend) GetBackendContext() string <span class="cov0" title="0">{
        repoName := filepath.Base(gb.RepoPath)
        fileName := filepath.Base(gb.FilePath)
        return fmt.Sprintf("%s/%s", repoName, fileName)
}</span>

// GetDeletedTaskLists retrieves deleted task lists (not supported for Git backend).
func (gb *GitBackend) GetDeletedTaskLists() ([]backend.TaskList, error) <span class="cov0" title="0">{
        // Git backend doesn't support trash functionality
        return []backend.TaskList{}, nil
}</span>

// RestoreTaskList restores a deleted task list (not supported for Git backend).
func (gb *GitBackend) RestoreTaskList(listID string) error <span class="cov0" title="0">{
        return fmt.Errorf("GitBackend.RestoreTaskList not supported")
}</span>

// PermanentlyDeleteTaskList permanently deletes a task list (not supported for Git backend).
func (gb *GitBackend) PermanentlyDeleteTaskList(listID string) error <span class="cov0" title="0">{
        return fmt.Errorf("GitBackend.PermanentlyDeleteTaskList not supported")
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package git

import (
        "gosynctasks/backend"
        "fmt"
        "regexp"
        "strings"
        "time"
)

// MarkdownParser parses markdown task files into backend.Task structures.
type MarkdownParser struct {
        // Regex patterns for parsing
        checkboxPattern *regexp.Regexp
        tagPattern      *regexp.Regexp
}

// NewMarkdownParser creates a new markdown parser.
func NewMarkdownParser() *MarkdownParser <span class="cov2" title="2">{
        return &amp;MarkdownParser{
                // Matches: - [ ] backend.Task summary @tag:value @tag2:value2
                checkboxPattern: regexp.MustCompile(`^-\s+\[([ xX&gt;\-])\]\s+(.+)$`),
                // Matches: @tag:value
                tagPattern: regexp.MustCompile(`@(\w+):([^\s]+)`),
        }
}</span>

// Parse parses markdown content into task lists.
func (p *MarkdownParser) Parse(content string) (map[string][]backend.Task, error) <span class="cov3" title="3">{
        lines := strings.Split(content, "\n")
        taskLists := make(map[string][]backend.Task)
        currentList := "Default"
        var currentTask *backend.Task
        var descriptionLines []string

        for i, line := range lines </span><span class="cov10" title="28">{
                trimmed := strings.TrimSpace(line)

                // Check for list header (## Header)
                if strings.HasPrefix(trimmed, "## ") </span><span class="cov4" title="4">{
                        // Save any pending task description
                        if currentTask != nil &amp;&amp; len(descriptionLines) &gt; 0 </span><span class="cov0" title="0">{
                                currentTask.Description = strings.Join(descriptionLines, "\n")
                                descriptionLines = nil
                        }</span>
                        <span class="cov4" title="4">currentTask = nil

                        currentList = strings.TrimSpace(trimmed[3:])
                        if currentList == "" </span><span class="cov0" title="0">{
                                currentList = fmt.Sprintf("List-%d", i)
                        }</span>
                        <span class="cov4" title="4">continue</span>
                }

                // Check for task checkbox
                <span class="cov9" title="24">if matches := p.checkboxPattern.FindStringSubmatch(trimmed); matches != nil </span><span class="cov6" title="9">{
                        // Save any pending task description
                        if currentTask != nil &amp;&amp; len(descriptionLines) &gt; 0 </span><span class="cov1" title="1">{
                                currentTask.Description = strings.Join(descriptionLines, "\n")
                                descriptionLines = nil
                        }</span>

                        // Parse task
                        <span class="cov6" title="9">statusChar := matches[1]
                        rest := matches[2]

                        task := backend.Task{
                                Status:   p.parseStatus(statusChar),
                                Created:  time.Now(),
                                Modified: time.Now(),
                        }

                        // Extract tags and summary
                        summary, tags := p.extractTags(rest)
                        task.Summary = summary

                        // Apply tags
                        for key, value := range tags </span><span class="cov8" title="19">{
                                switch key </span>{
                                case "uid":<span class="cov6" title="9">
                                        task.UID = value</span>
                                case "priority":<span class="cov5" title="5">
                                        _, _ = fmt.Sscanf(value, "%d", &amp;task.Priority)</span>
                                case "due":<span class="cov2" title="2">
                                        if t, err := time.Parse("2006-01-02", value); err == nil </span><span class="cov2" title="2">{
                                                task.DueDate = &amp;t
                                        }</span>
                                case "start":<span class="cov0" title="0">
                                        if t, err := time.Parse("2006-01-02", value); err == nil </span><span class="cov0" title="0">{
                                                task.StartDate = &amp;t
                                        }</span>
                                case "created":<span class="cov2" title="2">
                                        if t, err := time.Parse("2006-01-02", value); err == nil </span><span class="cov2" title="2">{
                                                task.Created = t
                                        }</span>
                                case "completed":<span class="cov1" title="1">
                                        if t, err := time.Parse("2006-01-02", value); err == nil </span><span class="cov1" title="1">{
                                                task.Completed = &amp;t
                                        }</span>
                                case "status":<span class="cov0" title="0">
                                        task.Status = value</span>
                                }
                        }

                        // Add to current list
                        <span class="cov6" title="9">taskLists[currentList] = append(taskLists[currentList], task)
                        currentTask = &amp;taskLists[currentList][len(taskLists[currentList])-1]
                        continue</span>
                }

                // Check for task description (indented lines following a task)
                <span class="cov8" title="15">if currentTask != nil &amp;&amp; (strings.HasPrefix(line, "  ") || strings.HasPrefix(line, "\t")) </span><span class="cov4" title="4">{
                        descLine := strings.TrimSpace(line)
                        if descLine != "" </span><span class="cov4" title="4">{
                                descriptionLines = append(descriptionLines, descLine)
                        }</span>
                        <span class="cov4" title="4">continue</span>
                }

                // Empty line or other content ends current task
                <span class="cov7" title="11">if currentTask != nil &amp;&amp; len(descriptionLines) &gt; 0 </span><span class="cov2" title="2">{
                        currentTask.Description = strings.Join(descriptionLines, "\n")
                        descriptionLines = nil
                        currentTask = nil
                }</span>
        }

        // Save any final task description
        <span class="cov3" title="3">if currentTask != nil &amp;&amp; len(descriptionLines) &gt; 0 </span><span class="cov0" title="0">{
                currentTask.Description = strings.Join(descriptionLines, "\n")
        }</span>

        <span class="cov3" title="3">return taskLists, nil</span>
}

// parseStatus converts markdown checkbox status to task status.
func (p *MarkdownParser) parseStatus(statusChar string) string <span class="cov6" title="9">{
        switch statusChar </span>{
        case "x", "X":<span class="cov3" title="3">
                return "DONE"</span>
        case "&gt;":<span class="cov1" title="1">
                return "PROCESSING"</span>
        case "-":<span class="cov1" title="1">
                return "CANCELLED"</span>
        default:<span class="cov4" title="4">
                return "TODO"</span>
        }
}

// extractTags extracts @tag:value pairs from text and returns cleaned summary and tags.
func (p *MarkdownParser) extractTags(text string) (string, map[string]string) <span class="cov6" title="9">{
        tags := make(map[string]string)

        // Find all tags
        matches := p.tagPattern.FindAllStringSubmatch(text, -1)
        for _, match := range matches </span><span class="cov8" title="19">{
                if len(match) == 3 </span><span class="cov8" title="19">{
                        key := strings.ToLower(match[1])
                        value := match[2]
                        tags[key] = value
                }</span>
        }

        // Remove tags from summary
        <span class="cov6" title="9">summary := p.tagPattern.ReplaceAllString(text, "")
        summary = strings.TrimSpace(summary)

        return summary, tags</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package git

import (
        "gosynctasks/backend"
        "fmt"
        "strings"
)

// MarkdownWriter writes backend.Task structures back to markdown format.
type MarkdownWriter struct{}

// NewMarkdownWriter creates a new markdown writer.
func NewMarkdownWriter() *MarkdownWriter <span class="cov5" title="2">{
        return &amp;MarkdownWriter{}
}</span>

// Write converts task lists to markdown format.
func (w *MarkdownWriter) Write(taskLists map[string][]backend.Task) string <span class="cov5" title="2">{
        var builder strings.Builder

        // Write marker at the top
        builder.WriteString(gitBackendMarker)
        builder.WriteString("\n\n")

        // Write each task list
        // Note: iteration order is non-deterministic, but that's okay for now
        for listName, tasks := range taskLists </span><span class="cov5" title="2">{
                // Write list header
                builder.WriteString(fmt.Sprintf("## %s\n", listName))

                // Write each task
                for _, task := range tasks </span><span class="cov10" title="4">{
                        // Write checkbox with status
                        checkbox := w.formatCheckbox(task.Status)
                        builder.WriteString(fmt.Sprintf("- %s %s", checkbox, task.Summary))

                        // Write tags
                        tags := w.formatTags(task)
                        if tags != "" </span><span class="cov10" title="4">{
                                builder.WriteString(" " + tags)
                        }</span>

                        <span class="cov10" title="4">builder.WriteString("\n")

                        // Write description if present
                        if task.Description != "" </span><span class="cov5" title="2">{
                                // Indent description lines
                                descLines := strings.Split(task.Description, "\n")
                                for _, line := range descLines </span><span class="cov5" title="2">{
                                        builder.WriteString(fmt.Sprintf("  %s\n", line))
                                }</span>
                        }
                }

                <span class="cov5" title="2">builder.WriteString("\n")</span>
        }

        <span class="cov5" title="2">return builder.String()</span>
}

// formatCheckbox converts task status to markdown checkbox.
func (w *MarkdownWriter) formatCheckbox(status string) string <span class="cov10" title="4">{
        switch status </span>{
        case "DONE":<span class="cov5" title="2">
                return "[x]"</span>
        case "PROCESSING":<span class="cov0" title="0">
                return "[&gt;]"</span>
        case "CANCELLED":<span class="cov0" title="0">
                return "[-]"</span>
        default:<span class="cov5" title="2">
                return "[ ]"</span>
        }
}

// formatTags formats task metadata as @tag:value pairs.
func (w *MarkdownWriter) formatTags(task backend.Task) string <span class="cov10" title="4">{
        var tags []string

        // Always include UID
        if task.UID != "" </span><span class="cov10" title="4">{
                tags = append(tags, fmt.Sprintf("@uid:%s", task.UID))
        }</span>

        // Include priority if set
        <span class="cov10" title="4">if task.Priority &gt; 0 </span><span class="cov5" title="2">{
                tags = append(tags, fmt.Sprintf("@priority:%d", task.Priority))
        }</span>

        // Include dates if set
        <span class="cov10" title="4">if task.DueDate != nil </span><span class="cov1" title="1">{
                if !task.DueDate.IsZero() </span><span class="cov1" title="1">{
                        tags = append(tags, fmt.Sprintf("@due:%s", task.DueDate.Format("2006-01-02")))
                }</span>
        }

        <span class="cov10" title="4">if task.StartDate != nil </span><span class="cov0" title="0">{
                if !task.StartDate.IsZero() </span><span class="cov0" title="0">{
                        tags = append(tags, fmt.Sprintf("@start:%s", task.StartDate.Format("2006-01-02")))
                }</span>
        }

        <span class="cov10" title="4">if !task.Created.IsZero() </span><span class="cov8" title="3">{
                tags = append(tags, fmt.Sprintf("@created:%s", task.Created.Format("2006-01-02")))
        }</span>

        <span class="cov10" title="4">if task.Completed != nil </span><span class="cov1" title="1">{
                if !task.Completed.IsZero() </span><span class="cov1" title="1">{
                        tags = append(tags, fmt.Sprintf("@completed:%s", task.Completed.Format("2006-01-02")))
                }</span>
        }

        <span class="cov10" title="4">return strings.Join(tags, " ")</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package nextcloud

import (
        "bytes"
        "crypto/tls"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "os"
        "sort"
        "strings"
        "time"

        "gosynctasks/backend"
        "gosynctasks/internal/credentials"
)

func init() <span class="cov1" title="1">{
        // Register Nextcloud backend for URL scheme "nextcloud://"
        backend.RegisterScheme("nextcloud", NewNextcloudBackend)

        // Register Nextcloud backend for config type "nextcloud"
        backend.RegisterType("nextcloud", newNextcloudBackendFromBackendConfig)
}</span>

type NextcloudBackend struct {
        Connector      backend.ConnectorConfig
        BackendName    string // Backend name for credential resolution
        ConfigHost     string // Host from config (for credential resolution)
        ConfigUsername string // Username from config (for credential resolution)
        username       string
        password       string
        baseURL        string
        client         *http.Client
}

// Status mapping: user-friendly names and abbreviations to CalDAV standard
var statusToCalDAV = map[string]string{
        "T":            "NEEDS-ACTION",
        "TODO":         "NEEDS-ACTION",
        "D":            "COMPLETED",
        "DONE":         "COMPLETED",
        "P":            "IN-PROCESS",
        "PROCESSING":   "IN-PROCESS",
        "C":            "CANCELLED",
        "CANCELLED":    "CANCELLED",
        "NEEDS-ACTION": "NEEDS-ACTION",
        "COMPLETED":    "COMPLETED",
        "IN-PROCESS":   "IN-PROCESS",
}

// CalDAV status to display name mapping
var calDAVToDisplay = map[string]string{
        "NEEDS-ACTION": "TODO",
        "COMPLETED":    "DONE",
        "IN-PROCESS":   "PROCESSING",
        "CANCELLED":    "CANCELLED",
}

func (nB *NextcloudBackend) getClient() *http.Client <span class="cov8" title="25">{
        if nB.client == nil </span><span class="cov7" title="22">{
                nB.client = &amp;http.Client{
                        Transport: &amp;http.Transport{
                                TLSClientConfig:     &amp;tls.Config{InsecureSkipVerify: nB.Connector.InsecureSkipVerify},
                                MaxIdleConns:        10,
                                MaxIdleConnsPerHost: 2,
                                IdleConnTimeout:     30 * time.Second,
                        },
                        Timeout: 30 * time.Second,
                }
        }</span>
        <span class="cov8" title="25">return nB.client</span>
}

func (nB *NextcloudBackend) getUsername() string <span class="cov10" title="59">{
        if nB.username == "" </span><span class="cov8" title="30">{
                // Try credential resolver first (keyring &gt; env &gt; URL)
                if nB.BackendName != "" </span><span class="cov5" title="8">{
                        resolver := credentials.NewResolver()
                        creds, err := resolver.Resolve(nB.BackendName, nB.ConfigUsername, nB.ConfigHost, nB.Connector.URL)
                        if err == nil &amp;&amp; creds.Username != "" </span><span class="cov5" title="7">{
                                nB.username = creds.Username
                                nB.password = creds.Password // Cache both
                                return nB.username
                        }</span>
                }

                // Fallback to URL (backward compatible)
                <span class="cov7" title="23">if nB.Connector.URL != nil &amp;&amp; nB.Connector.URL.User != nil </span><span class="cov7" title="22">{
                        nB.username = nB.Connector.URL.User.Username()
                }</span>
        }
        <span class="cov9" title="52">return nB.username</span>
}

func (nB *NextcloudBackend) getPassword() string <span class="cov8" title="32">{
        if nB.password == "" </span><span class="cov7" title="23">{
                // Try credential resolver first
                if nB.BackendName != "" </span><span class="cov1" title="1">{
                        resolver := credentials.NewResolver()
                        creds, err := resolver.Resolve(nB.BackendName, nB.ConfigUsername, nB.ConfigHost, nB.Connector.URL)
                        if err == nil &amp;&amp; creds.Password != "" </span><span class="cov0" title="0">{
                                nB.password = creds.Password
                                nB.username = creds.Username // Cache both
                                return nB.password
                        }</span>
                }

                // Fallback to URL (backward compatible)
                <span class="cov7" title="23">if nB.Connector.URL != nil &amp;&amp; nB.Connector.URL.User != nil </span><span class="cov7" title="22">{
                        nB.password, _ = nB.Connector.URL.User.Password()
                }</span>
        }
        <span class="cov8" title="32">return nB.password</span>
}

func (nB *NextcloudBackend) getBaseURL() string <span class="cov8" title="34">{
        if nB.baseURL == "" </span><span class="cov5" title="9">{
                if nB.Connector.URL != nil </span><span class="cov5" title="9">{
                        // SECURITY: Always use HTTPS by default for Nextcloud connections
                        // HTTP is only allowed if explicitly configured via AllowHTTP flag
                        protocol := "https"
                        host := nB.Connector.URL.Host

                        // Only use HTTP if explicitly allowed in config
                        if nB.Connector.AllowHTTP </span><span class="cov4" title="4">{
                                // Check if port is specified and is a common HTTP port
                                if strings.Contains(host, ":80") || strings.Contains(host, ":8080") || strings.Contains(host, ":8000") </span><span class="cov3" title="3">{
                                        protocol = "http"
                                }</span>
                        }
                        // Otherwise, always use HTTPS regardless of port

                        <span class="cov5" title="9">nB.baseURL = fmt.Sprintf("%s://%s", protocol, host)</span>
                }
        }
        <span class="cov8" title="34">return nB.baseURL</span>
}

// buildCalendarURL constructs the CalDAV calendar collection URL
func (nB *NextcloudBackend) buildCalendarURL() string <span class="cov2" title="2">{
        return fmt.Sprintf("%s/remote.php/dav/calendars/%s/", nB.getBaseURL(), nB.getUsername())
}</span>

// buildListURL constructs the CalDAV URL for a specific task list
func (nB *NextcloudBackend) buildListURL(listID string) string <span class="cov7" title="16">{
        return fmt.Sprintf("%s/remote.php/dav/calendars/%s/%s/", nB.getBaseURL(), nB.getUsername(), listID)
}</span>

// buildTaskURL constructs the CalDAV URL for a specific task
func (nB *NextcloudBackend) buildTaskURL(listID, taskUID string) string <span class="cov5" title="7">{
        return fmt.Sprintf("%s/remote.php/dav/calendars/%s/%s/%s.ics", nB.getBaseURL(), nB.getUsername(), listID, taskUID)
}</span>

// makeAuthenticatedRequest creates and executes an authenticated HTTP request
func (nB *NextcloudBackend) makeAuthenticatedRequest(method, url string, body io.Reader, headers map[string]string) (*http.Response, error) <span class="cov8" title="25">{
        req, err := http.NewRequest(method, url, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Set basic auth
        <span class="cov8" title="25">req.SetBasicAuth(nB.getUsername(), nB.getPassword())

        // Set custom headers
        for key, value := range headers </span><span class="cov8" title="25">{
                req.Header.Set(key, value)
        }</span>

        // Send request
        <span class="cov8" title="25">client := nB.getClient()
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send request: %w", err)
        }</span>

        <span class="cov8" title="25">return resp, nil</span>
}

// checkHTTPResponse checks HTTP response status and returns appropriate errors
func (nB *NextcloudBackend) checkHTTPResponse(resp *http.Response, operation string, allowedStatuses ...int) error <span class="cov7" title="21">{
        // If specific statuses are allowed, check against them
        if len(allowedStatuses) &gt; 0 </span><span class="cov6" title="11">{
                for _, status := range allowedStatuses </span><span class="cov7" title="18">{
                        if resp.StatusCode == status </span><span class="cov4" title="6">{
                                return nil
                        }</span>
                }
        } else<span class="cov6" title="10"> {
                // Default: allow 2xx status codes
                if resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt; 300 </span><span class="cov5" title="9">{
                        return nil
                }</span>
        }

        // Read response body for error details
        <span class="cov4" title="6">body, _ := io.ReadAll(resp.Body)

        // Common error cases
        switch resp.StatusCode </span>{
        case 401, 403:<span class="cov2" title="2">
                return backend.NewBackendError(operation, resp.StatusCode, "Authentication failed. Please check your username and password in the config file").
                        WithBody(string(body))</span>
        case 404:<span class="cov0" title="0">
                return backend.NewBackendError(operation, resp.StatusCode, "Resource not found. Please check your configuration").
                        WithBody(string(body))</span>
        case 405:<span class="cov0" title="0">
                return backend.NewBackendError(operation, resp.StatusCode, "Operation not allowed or resource already exists").
                        WithBody(string(body))</span>
        default:<span class="cov4" title="4">
                return backend.NewBackendError(operation, resp.StatusCode, resp.Status).
                        WithBody(string(body))</span>
        }
}

func (nB *NextcloudBackend) buildCalendarQuery(filter *backend.TaskFilter) string <span class="cov4" title="6">{
        query := `&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;c:calendar-query xmlns:d="DAV:" xmlns:c="urn:ietf:params:xml:ns:caldav"&gt;
  &lt;d:prop&gt;
    &lt;d:getetag /&gt;
    &lt;c:calendar-data /&gt;
  &lt;/d:prop&gt;
  &lt;c:filter&gt;
    &lt;c:comp-filter name="VCALENDAR"&gt;
      &lt;c:comp-filter name="VTODO"&gt;`

        if filter != nil </span><span class="cov1" title="1">{
                if filter.Statuses != nil </span><span class="cov1" title="1">{
                        // Statuses are already in CalDAV format from BuildFilter
                        for _, status := range *filter.Statuses </span><span class="cov1" title="1">{
                                if status == "NEEDS-ACTION" </span><span class="cov1" title="1">{
                                        query += `&lt;c:prop-filter name="COMPLETED"&gt;
  &lt;c:is-not-defined/&gt;
&lt;/c:prop-filter&gt;`
                                }</span> else<span class="cov0" title="0"> {
                                        query += fmt.Sprintf(`&lt;c:prop-filter name="STATUS"&gt;
          &lt;c:text-match&gt;&lt;![CDATA[%s]]&gt;&lt;/c:text-match&gt;
        &lt;/c:prop-filter&gt;`, status)

                                }</span>
                        }
                }

                <span class="cov1" title="1">if filter.DueAfter != nil || filter.DueBefore != nil </span><span class="cov0" title="0">{
                        query += `
        &lt;c:prop-filter name="DUE"&gt;`
                        if filter.DueAfter != nil </span><span class="cov0" title="0">{
                                query += fmt.Sprintf(`
          &lt;c:time-range start="%s"/&gt;`, filter.DueAfter.Format("20060102T150405Z"))
                        }</span>
                        <span class="cov0" title="0">if filter.DueBefore != nil </span><span class="cov0" title="0">{
                                query += fmt.Sprintf(`
          &lt;c:time-range end="%s"/&gt;`, filter.DueBefore.Format("20060102T150405Z"))
                        }</span>
                        <span class="cov0" title="0">query += `
        &lt;/c:prop-filter&gt;`</span>
                }
        }

        <span class="cov4" title="6">query += `
      &lt;/c:comp-filter&gt;
    &lt;/c:comp-filter&gt;
  &lt;/c:filter&gt;
&lt;/c:calendar-query&gt;`

        return query</span>
}
func (nB *NextcloudBackend) GetTasks(listID string, taskFilter *backend.TaskFilter) ([]backend.Task, error) <span class="cov4" title="6">{
        // Credentials can come from URL, keyring, or environment variables
        // Only require URL.User if we're not using keyring/env (i.e., no BackendName)
        if nB.BackendName == "" &amp;&amp; nB.Connector.URL.User == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no user credentials in URL and no backend name for credential resolution")
        }</span>

        // Build request body
        <span class="cov4" title="6">queryBody := nB.buildCalendarQuery(taskFilter)

        // Make authenticated request
        headers := map[string]string{
                "Content-Type": "application/xml",
                "Depth":        "1",
        }
        resp, err := nB.makeAuthenticatedRequest("REPORT", nB.buildListURL(listID), strings.NewReader(queryBody), headers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="6">defer func() </span><span class="cov4" title="6">{ _ = resp.Body.Close() }</span>()

        // Check response status
        <span class="cov4" title="6">if err := nB.checkHTTPResponse(resp, "GetTasks"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Parse response
        <span class="cov4" title="6">respBody, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="6">tasks, err := nB.parseVTODOs(string(respBody))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Apply client-side ExcludeStatuses filter (CalDAV doesn't support NOT IN queries easily)
        <span class="cov4" title="6">if taskFilter != nil &amp;&amp; taskFilter.ExcludeStatuses != nil &amp;&amp; len(*taskFilter.ExcludeStatuses) &gt; 0 </span><span class="cov0" title="0">{
                filtered := make([]backend.Task, 0, len(tasks))
                excludeMap := make(map[string]bool)
                for _, status := range *taskFilter.ExcludeStatuses </span><span class="cov0" title="0">{
                        excludeMap[status] = true
                }</span>
                <span class="cov0" title="0">for _, task := range tasks </span><span class="cov0" title="0">{
                        if !excludeMap[task.Status] </span><span class="cov0" title="0">{
                                filtered = append(filtered, task)
                        }</span>
                }
                <span class="cov0" title="0">return filtered, nil</span>
        }

        <span class="cov4" title="6">return tasks, nil</span>
}

func (nB *NextcloudBackend) FindTasksBySummary(listID string, summary string) ([]backend.Task, error) <span class="cov4" title="4">{
        // For now, implement client-side filtering
        // Future optimization: could use CalDAV text-match query for server-side search

        // Get all tasks from the list
        allTasks, err := nB.GetTasks(listID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Filter by summary (case-insensitive partial match)
        <span class="cov4" title="4">var matches []backend.Task
        summaryLower := strings.ToLower(summary)

        for _, task := range allTasks </span><span class="cov5" title="8">{
                taskSummaryLower := strings.ToLower(task.Summary)

                // Include both exact and partial matches
                if strings.Contains(taskSummaryLower, summaryLower) </span><span class="cov3" title="3">{
                        matches = append(matches, task)
                }</span>
        }

        <span class="cov4" title="4">return matches, nil</span>
}

func (nB *NextcloudBackend) GetTaskLists() ([]backend.TaskList, error) <span class="cov2" title="2">{
        calendarURL := nB.buildCalendarURL()

        // Build request body
        propfindBody := `&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;d:propfind xmlns:d="DAV:" xmlns:cs="http://calendarserver.org/ns/" xmlns:c="urn:ietf:params:xml:ns:caldav" xmlns:ic="http://apple.com/ns/ical/" xmlns:nc="http://nextcloud.com/ns"&gt;
  &lt;d:prop&gt;
    &lt;d:resourcetype /&gt;
    &lt;d:displayname /&gt;
    &lt;cs:getctag /&gt;
    &lt;c:supported-calendar-component-set /&gt;
    &lt;ic:calendar-color /&gt;
    &lt;nc:deleted-at /&gt;
  &lt;/d:prop&gt;
&lt;/d:propfind&gt;`

        // Make authenticated request
        headers := map[string]string{
                "Content-Type": "application/xml",
                "Depth":        "1",
        }
        resp, err := nB.makeAuthenticatedRequest("PROPFIND", calendarURL, strings.NewReader(propfindBody), headers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("HTTP request failed: %w", err)
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{ _ = resp.Body.Close() }</span>()

        // Check response status
        <span class="cov2" title="2">if err := nB.checkHTTPResponse(resp, "GetTaskLists"); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Parse response
        <span class="cov1" title="1">respBody, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov1" title="1">return nB.parseTaskLists(string(respBody), calendarURL)</span>
}

func (nB *NextcloudBackend) GetDeletedTaskLists() ([]backend.TaskList, error) <span class="cov0" title="0">{
        calendarURL := nB.buildCalendarURL()

        // Build request body (same as GetTaskLists)
        propfindBody := `&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;d:propfind xmlns:d="DAV:" xmlns:cs="http://calendarserver.org/ns/" xmlns:c="urn:ietf:params:xml:ns:caldav" xmlns:ic="http://apple.com/ns/ical/" xmlns:nc="http://nextcloud.com/ns"&gt;
  &lt;d:prop&gt;
    &lt;d:resourcetype /&gt;
    &lt;d:displayname /&gt;
    &lt;cs:getctag /&gt;
    &lt;c:supported-calendar-component-set /&gt;
    &lt;ic:calendar-color /&gt;
    &lt;nc:deleted-at /&gt;
  &lt;/d:prop&gt;
&lt;/d:propfind&gt;`

        // Make authenticated request
        headers := map[string]string{
                "Content-Type": "application/xml",
                "Depth":        "1",
        }
        resp, err := nB.makeAuthenticatedRequest("PROPFIND", calendarURL, strings.NewReader(propfindBody), headers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("HTTP request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        // Check response status
        <span class="cov0" title="0">if err := nB.checkHTTPResponse(resp, "GetDeletedTaskLists"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Parse response
        <span class="cov0" title="0">respBody, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">return nB.parseDeletedTaskLists(string(respBody), calendarURL)</span>
}

func (nB *NextcloudBackend) AddTask(listID string, task backend.Task) error <span class="cov1" title="1">{
        // Set defaults
        if task.UID == "" </span><span class="cov1" title="1">{
                task.UID = fmt.Sprintf("task-%d", time.Now().Unix())
        }</span>
        <span class="cov1" title="1">if task.Created.IsZero() </span><span class="cov1" title="1">{
                task.Created = time.Now()
        }</span>
        <span class="cov1" title="1">if task.Status == "" </span><span class="cov0" title="0">{
                task.Status = "NEEDS-ACTION"
        }</span>

        // Build the iCalendar content
        <span class="cov1" title="1">icalContent := nB.buildICalContent(task)

        // Make authenticated request
        headers := map[string]string{
                "Content-Type": "text/calendar; charset=utf-8",
        }
        resp, err := nB.makeAuthenticatedRequest("PUT", nB.buildTaskURL(listID, task.UID), bytes.NewBufferString(icalContent), headers)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{ _ = resp.Body.Close() }</span>()

        // Check response status
        <span class="cov1" title="1">if err := nB.checkHTTPResponse(resp, "AddTask"); err != nil </span><span class="cov0" title="0">{
                if backendErr, ok := err.(*backend.BackendError); ok </span><span class="cov0" title="0">{
                        return backendErr.WithTaskUID(task.UID).WithListID(listID)
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov1" title="1">return nil</span>
}

func (nB *NextcloudBackend) UpdateTask(listID string, task backend.Task) error <span class="cov1" title="1">{
        // Set modified time to now
        task.Modified = time.Now()

        // If status is COMPLETED and Completed time not set, set it now
        if task.Status == "COMPLETED" &amp;&amp; task.Completed == nil </span><span class="cov1" title="1">{
                now := time.Now()
                task.Completed = &amp;now
        }</span>

        // Build the iCalendar content
        <span class="cov1" title="1">icalContent := nB.buildICalContent(task)

        // Make authenticated request (CalDAV uses PUT for both create and update)
        headers := map[string]string{
                "Content-Type": "text/calendar; charset=utf-8",
        }
        resp, err := nB.makeAuthenticatedRequest("PUT", nB.buildTaskURL(listID, task.UID), bytes.NewBufferString(icalContent), headers)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{ _ = resp.Body.Close() }</span>()

        // Check response status
        <span class="cov1" title="1">if err := nB.checkHTTPResponse(resp, "UpdateTask"); err != nil </span><span class="cov0" title="0">{
                if backendErr, ok := err.(*backend.BackendError); ok </span><span class="cov0" title="0">{
                        return backendErr.WithTaskUID(task.UID).WithListID(listID)
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov1" title="1">return nil</span>
}

func (nB *NextcloudBackend) DeleteTask(listID string, taskUID string) error <span class="cov4" title="5">{
        // Make authenticated DELETE request
        // 204 No Content is the typical success status for DELETE
        resp, err := nB.makeAuthenticatedRequest("DELETE", nB.buildTaskURL(listID, taskUID), nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="5">defer func() </span><span class="cov4" title="5">{ _ = resp.Body.Close() }</span>()

        // Check response status - handle 404 specifically for task not found
        <span class="cov4" title="5">if resp.StatusCode == 404 </span><span class="cov1" title="1">{
                return backend.NewBackendError("DeleteTask", 404, "task not found (may have been already deleted)").
                        WithTaskUID(taskUID).
                        WithListID(listID)
        }</span>

        // Check for other errors
        <span class="cov4" title="4">if err := nB.checkHTTPResponse(resp, "DeleteTask", 200, 204); err != nil </span><span class="cov2" title="2">{
                if backendErr, ok := err.(*backend.BackendError); ok </span><span class="cov2" title="2">{
                        return backendErr.WithTaskUID(taskUID).WithListID(listID)
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov2" title="2">return nil</span>
}

func (nB *NextcloudBackend) CreateTaskList(name, description, color string) (string, error) <span class="cov4" title="4">{
        // Generate a unique list ID from the name (lowercase, replace spaces with dashes)
        listID := strings.ToLower(strings.ReplaceAll(name, " ", "-"))
        // Add timestamp to ensure uniqueness
        listID = fmt.Sprintf("%s-%d", listID, time.Now().Unix())

        // Build the MKCALENDAR request body
        mkcolBody := `&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;d:mkcol xmlns:d="DAV:" xmlns:c="urn:ietf:params:xml:ns:caldav" xmlns:ic="http://apple.com/ns/ical/"&gt;
  &lt;d:set&gt;
    &lt;d:prop&gt;
      &lt;d:resourcetype&gt;
        &lt;d:collection/&gt;
        &lt;c:calendar/&gt;
      &lt;/d:resourcetype&gt;
      &lt;d:displayname&gt;` + name + `&lt;/d:displayname&gt;
      &lt;c:supported-calendar-component-set&gt;
        &lt;c:comp name="VTODO"/&gt;
      &lt;/c:supported-calendar-component-set&gt;`

        if description != "" </span><span class="cov1" title="1">{
                mkcolBody += `
      &lt;c:calendar-description&gt;` + description + `&lt;/c:calendar-description&gt;`
        }</span>

        <span class="cov4" title="4">if color != "" </span><span class="cov1" title="1">{
                mkcolBody += `
      &lt;ic:calendar-color&gt;` + color + `&lt;/ic:calendar-color&gt;`
        }</span>

        <span class="cov4" title="4">mkcolBody += `
    &lt;/d:prop&gt;
  &lt;/d:set&gt;
&lt;/d:mkcol&gt;`

        // Make authenticated request
        // 201 Created is the success status for MKCOL
        headers := map[string]string{
                "Content-Type": "application/xml; charset=utf-8",
        }
        resp, err := nB.makeAuthenticatedRequest("MKCOL", nB.buildListURL(listID), bytes.NewBufferString(mkcolBody), headers)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov4" title="4">defer func() </span><span class="cov4" title="4">{ _ = resp.Body.Close() }</span>()

        // Check response status - handle 405 specifically for list already exists
        <span class="cov4" title="4">if resp.StatusCode == 405 </span><span class="cov1" title="1">{
                body, _ := io.ReadAll(resp.Body)
                return "", backend.NewBackendError("CreateTaskList", 405, "list already exists or name conflict").
                        WithBody(string(body))
        }</span>

        // Check for other errors
        <span class="cov3" title="3">if err := nB.checkHTTPResponse(resp, "CreateTaskList", 201); err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>

        <span class="cov2" title="2">return listID, nil</span>
}

func (nB *NextcloudBackend) DeleteTaskList(listID string) error <span class="cov3" title="3">{
        // Make authenticated DELETE request
        // 204 No Content is the success status for DELETE
        resp, err := nB.makeAuthenticatedRequest("DELETE", nB.buildListURL(listID), nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="3">defer func() </span><span class="cov3" title="3">{ _ = resp.Body.Close() }</span>()

        // Check response status - handle 404 specifically for list not found
        <span class="cov3" title="3">if resp.StatusCode == 404 </span><span class="cov1" title="1">{
                return backend.NewBackendError("DeleteTaskList", 404, "list not found").
                        WithListID(listID)
        }</span>

        // Check for other errors
        <span class="cov2" title="2">if err := nB.checkHTTPResponse(resp, "DeleteTaskList", 200, 204); err != nil </span><span class="cov1" title="1">{
                if backendErr, ok := err.(*backend.BackendError); ok </span><span class="cov1" title="1">{
                        return backendErr.WithListID(listID)
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov1" title="1">return nil</span>
}

func (nB *NextcloudBackend) RenameTaskList(listID, newName string) error <span class="cov3" title="3">{
        // Build the PROPPATCH request body to update displayname
        proppatchBody := `&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;d:propertyupdate xmlns:d="DAV:"&gt;
  &lt;d:set&gt;
    &lt;d:prop&gt;
      &lt;d:displayname&gt;` + newName + `&lt;/d:displayname&gt;
    &lt;/d:prop&gt;
  &lt;/d:set&gt;
&lt;/d:propertyupdate&gt;`

        // Make authenticated request
        // 207 Multi-Status is the typical success status for PROPPATCH
        headers := map[string]string{
                "Content-Type": "application/xml; charset=utf-8",
        }
        resp, err := nB.makeAuthenticatedRequest("PROPPATCH", nB.buildListURL(listID), bytes.NewBufferString(proppatchBody), headers)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="3">defer func() </span><span class="cov3" title="3">{ _ = resp.Body.Close() }</span>()

        // Check response status - handle 404 specifically for list not found
        <span class="cov3" title="3">if resp.StatusCode == 404 </span><span class="cov1" title="1">{
                return backend.NewBackendError("RenameTaskList", 404, "list not found").
                        WithListID(listID)
        }</span>

        // Check for other errors
        <span class="cov2" title="2">if err := nB.checkHTTPResponse(resp, "RenameTaskList", 200, 207); err != nil </span><span class="cov1" title="1">{
                if backendErr, ok := err.(*backend.BackendError); ok </span><span class="cov1" title="1">{
                        return backendErr.WithListID(listID)
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov1" title="1">return nil</span>
}

func (nB *NextcloudBackend) RestoreTaskList(listID string) error <span class="cov0" title="0">{
        // Build the MOVE request to restore from trash
        // Nextcloud uses MOVE method to restore deleted calendars
        // Source: deleted calendar URL, Destination: restored calendar URL

        // Build source URL (current location in trash)
        sourceURL := nB.buildListURL(listID)

        // Build destination URL (where to restore - use the deleted-suffix format)
        // Nextcloud appends a suffix to deleted calendars, we need to remove it
        restoredListID := strings.TrimSuffix(listID, "-deleted")
        if restoredListID == listID </span><span class="cov0" title="0">{
                // If no -deleted suffix, try restoring to same location
                restoredListID = listID
        }</span>
        <span class="cov0" title="0">destURL := nB.buildListURL(restoredListID)

        // Make authenticated MOVE request
        headers := map[string]string{
                "Destination": destURL,
                "Overwrite":   "F", // Don't overwrite existing calendars
        }
        resp, err := nB.makeAuthenticatedRequest("MOVE", sourceURL, nil, headers)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to restore list: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        // Check response status - 201 Created or 204 No Content are success statuses
        <span class="cov0" title="0">if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                return backend.NewBackendError("RestoreTaskList", 404, "list not found in trash").
                        WithListID(listID)
        }</span>

        <span class="cov0" title="0">if err := nB.checkHTTPResponse(resp, "RestoreTaskList", 201, 204); err != nil </span><span class="cov0" title="0">{
                if backendErr, ok := err.(*backend.BackendError); ok </span><span class="cov0" title="0">{
                        return backendErr.WithListID(listID)
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (nB *NextcloudBackend) PermanentlyDeleteTaskList(listID string) error <span class="cov0" title="0">{
        // Build DELETE request with special header to permanently delete from trash
        // For Nextcloud, we need to delete the calendar completely

        // Make authenticated DELETE request
        resp, err := nB.makeAuthenticatedRequest("DELETE", nB.buildListURL(listID), nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to permanently delete list: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        // Check response status - handle 404 specifically for list not found
        <span class="cov0" title="0">if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                return backend.NewBackendError("PermanentlyDeleteTaskList", 404, "list not found in trash").
                        WithListID(listID)
        }</span>

        // Check for other errors - 200 OK or 204 No Content are success statuses
        <span class="cov0" title="0">if err := nB.checkHTTPResponse(resp, "PermanentlyDeleteTaskList", 200, 204); err != nil </span><span class="cov0" title="0">{
                if backendErr, ok := err.(*backend.BackendError); ok </span><span class="cov0" title="0">{
                        return backendErr.WithListID(listID)
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (nb *NextcloudBackend) buildICalContent(task backend.Task) string <span class="cov2" title="2">{
        var icalContent bytes.Buffer

        // Format timestamps
        now := time.Now().UTC()
        dtstamp := now.Format("20060102T150405Z")
        created := task.Created.UTC().Format("20060102T150405Z")

        icalContent.WriteString("BEGIN:VCALENDAR\r\n")
        icalContent.WriteString("VERSION:2.0\r\n")
        icalContent.WriteString("PRODID:-//Go CalDAV Client//EN\r\n")
        icalContent.WriteString("BEGIN:VTODO\r\n")
        icalContent.WriteString(fmt.Sprintf("UID:%s\r\n", task.UID))
        icalContent.WriteString(fmt.Sprintf("DTSTAMP:%s\r\n", dtstamp))
        icalContent.WriteString(fmt.Sprintf("CREATED:%s\r\n", created))

        // Add LAST-MODIFIED if task has been modified
        if !task.Modified.IsZero() </span><span class="cov1" title="1">{
                modified := task.Modified.UTC().Format("20060102T150405Z")
                icalContent.WriteString(fmt.Sprintf("LAST-MODIFIED:%s\r\n", modified))
        }</span>

        <span class="cov2" title="2">icalContent.WriteString(fmt.Sprintf("SUMMARY:%s\r\n", task.Summary))

        if task.Description != "" </span><span class="cov2" title="2">{
                icalContent.WriteString(fmt.Sprintf("DESCRIPTION:%s\r\n", task.Description))
        }</span>

        <span class="cov2" title="2">icalContent.WriteString(fmt.Sprintf("STATUS:%s\r\n", task.Status))

        if task.Priority &gt; 0 </span><span class="cov2" title="2">{
                icalContent.WriteString(fmt.Sprintf("PRIORITY:%d\r\n", task.Priority))
        }</span>

        <span class="cov2" title="2">if task.DueDate != nil </span><span class="cov0" title="0">{
                due := task.DueDate.UTC().Format("20060102T150405Z")
                icalContent.WriteString(fmt.Sprintf("DUE:%s\r\n", due))
        }</span>

        <span class="cov2" title="2">if task.StartDate != nil </span><span class="cov0" title="0">{
                start := task.StartDate.UTC().Format("20060102T150405Z")
                icalContent.WriteString(fmt.Sprintf("DTSTART:%s\r\n", start))
        }</span>

        // Add COMPLETED timestamp if status is COMPLETED
        <span class="cov2" title="2">if task.Status == "COMPLETED" &amp;&amp; task.Completed != nil </span><span class="cov1" title="1">{
                completed := task.Completed.UTC().Format("20060102T150405Z")
                icalContent.WriteString(fmt.Sprintf("COMPLETED:%s\r\n", completed))
        }</span>

        // Add RELATED-TO for parent-child relationships
        <span class="cov2" title="2">if task.ParentUID != "" </span><span class="cov0" title="0">{
                icalContent.WriteString(fmt.Sprintf("RELATED-TO:%s\r\n", task.ParentUID))
        }</span>

        <span class="cov2" title="2">icalContent.WriteString("END:VTODO\r\n")
        icalContent.WriteString("END:VCALENDAR\r\n")

        return icalContent.String()</span>
}

func (nB *NextcloudBackend) SortTasks(tasks []backend.Task) <span class="cov1" title="1">{
        // Nextcloud priority: 1 is highest, 0 is undefined (goes last)
        sort.Slice(tasks, func(i, j int) bool </span><span class="cov5" title="9">{
                pi, pj := tasks[i].Priority, tasks[j].Priority

                // Priority 0 (undefined) goes to the end
                if pi == 0 &amp;&amp; pj != 0 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov5" title="9">if pj == 0 &amp;&amp; pi != 0 </span><span class="cov4" title="4">{
                        return true
                }</span>

                // Otherwise sort ascending (1, 2, 3, ...)
                <span class="cov4" title="5">return pi &lt; pj</span>
        })
}

func (nB *NextcloudBackend) ParseStatusFlag(statusFlag string) (string, error) <span class="cov7" title="17">{
        if statusFlag == "" </span><span class="cov1" title="1">{
                return "", fmt.Errorf("status flag cannot be empty")
        }</span>

        // Convert to uppercase and look up in map
        <span class="cov7" title="16">upperStatus := strings.ToUpper(statusFlag)
        if calDAVStatus, ok := statusToCalDAV[upperStatus]; ok </span><span class="cov6" title="14">{
                return calDAVStatus, nil
        }</span>

        <span class="cov2" title="2">return "", fmt.Errorf("invalid status: %s (valid: TODO/T, DONE/D, PROCESSING/P, CANCELLED/C)", statusFlag)</span>
}

func (nB *NextcloudBackend) StatusToDisplayName(backendStatus string) string <span class="cov5" title="7">{
        // Convert CalDAV status to display name
        upperStatus := strings.ToUpper(backendStatus)
        if displayName, ok := calDAVToDisplay[upperStatus]; ok </span><span class="cov4" title="6">{
                return displayName
        }</span>
        <span class="cov1" title="1">return backendStatus</span>
}

func (nB *NextcloudBackend) GetPriorityColor(priority int) string <span class="cov4" title="6">{
        // Nextcloud priority color scheme
        if priority &gt;= 1 &amp;&amp; priority &lt;= 4 </span><span class="cov2" title="2">{
                return "\033[31m" // Red (high priority)
        }</span> else<span class="cov4" title="4"> if priority == 5 </span><span class="cov1" title="1">{
                return "\033[33m" // Yellow (medium priority)
        }</span> else<span class="cov3" title="3"> if priority &gt;= 6 &amp;&amp; priority &lt;= 9 </span><span class="cov2" title="2">{
                return "\033[34m" // Blue (low priority)
        }</span>
        <span class="cov1" title="1">return ""</span> // No color for 0 (undefined)
}

func (nB *NextcloudBackend) GetBackendDisplayName() string <span class="cov0" title="0">{
        username := nB.getUsername()
        host := ""
        if nB.Connector.URL != nil </span><span class="cov0" title="0">{
                host = nB.Connector.URL.Host
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("[nextcloud:%s@%s]", username, host)</span>
}

func (nB *NextcloudBackend) GetBackendType() string <span class="cov0" title="0">{
        return "nextcloud"
}</span>

func (nB *NextcloudBackend) GetBackendContext() string <span class="cov0" title="0">{
        username := nB.getUsername()
        host := ""
        if nB.Connector.URL != nil </span><span class="cov0" title="0">{
                host = nB.Connector.URL.Host
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s@%s", username, host)</span>
}

func NewNextcloudBackend(connectorConfig backend.ConnectorConfig) (backend.TaskManager, error) <span class="cov6" title="13">{
        nB := &amp;NextcloudBackend{
                Connector: connectorConfig,
        }

        // Don't call BasicValidation here - it will be called on first operation
        // This allows BackendName to be set by the factory first (needed for keyring credentials)

        // SECURITY: Check if AllowHTTP is enabled and warn
        if nB.Connector.AllowHTTP &amp;&amp; !nB.Connector.SuppressHTTPWarning </span><span class="cov0" title="0">{
                // Check if this will result in HTTP connections
                host := nB.Connector.URL.Host
                if strings.Contains(host, ":80") || strings.Contains(host, ":8080") || strings.Contains(host, ":8000") </span><span class="cov0" title="0">{
                        fmt.Fprintln(os.Stderr, "")
                        fmt.Fprintln(os.Stderr, "")
                        fmt.Fprintln(os.Stderr, "                       SECURITY WARNING                        ")
                        fmt.Fprintln(os.Stderr, "")
                        fmt.Fprintln(os.Stderr, " HTTP connections are INSECURE and transmit data in PLAINTEXT     ")
                        fmt.Fprintln(os.Stderr, " including your username and password!                            ")
                        fmt.Fprintln(os.Stderr, "                                                                   ")
                        fmt.Fprintln(os.Stderr, " Only use HTTP for local testing with trusted networks.           ")
                        fmt.Fprintln(os.Stderr, " For production, use HTTPS with valid certificates.               ")
                        fmt.Fprintln(os.Stderr, "")
                        fmt.Fprintln(os.Stderr, "")
                }</span>
        }

        // SECURITY: Warn if TLS verification is disabled
        <span class="cov6" title="13">if nB.Connector.InsecureSkipVerify &amp;&amp; !nB.Connector.SuppressSSLWarning </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "")
                fmt.Fprintln(os.Stderr, "")
                fmt.Fprintln(os.Stderr, "                       SECURITY WARNING                        ")
                fmt.Fprintln(os.Stderr, "")
                fmt.Fprintln(os.Stderr, " TLS certificate verification is DISABLED!                        ")
                fmt.Fprintln(os.Stderr, " This makes you vulnerable to man-in-the-middle attacks.          ")
                fmt.Fprintln(os.Stderr, "                                                                   ")
                fmt.Fprintln(os.Stderr, " Only use this for development with self-signed certificates.     ")
                fmt.Fprintln(os.Stderr, " For production, use properly signed certificates or add your     ")
                fmt.Fprintln(os.Stderr, " CA certificate to the system trust store.                        ")
                fmt.Fprintln(os.Stderr, "")
                fmt.Fprintln(os.Stderr, "")
        }</span>

        <span class="cov6" title="13">return nB, nil</span>
}

// newNextcloudBackendFromBackendConfig creates a Nextcloud backend from BackendConfig
func newNextcloudBackendFromBackendConfig(bc backend.BackendConfig) (backend.TaskManager, error) <span class="cov6" title="13">{
        // Parse URL if provided, otherwise construct from host
        var u *url.URL
        var err error

        if bc.URL != "" </span><span class="cov4" title="4">{
                u, err = url.Parse(bc.URL)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid URL for nextcloud backend: %w", err)
                }</span>
        } else<span class="cov5" title="9"> if bc.Host != "" </span><span class="cov5" title="9">{
                // Construct URL from host (without credentials)
                u, _ = url.Parse(fmt.Sprintf("nextcloud://%s", bc.Host))
        }</span>

        <span class="cov6" title="13">connConfig := backend.ConnectorConfig{
                URL:                 u,
                InsecureSkipVerify:  bc.InsecureSkipVerify,
                SuppressSSLWarning:  bc.SuppressSSLWarning,
                AllowHTTP:           bc.AllowHTTP,
                SuppressHTTPWarning: bc.SuppressHTTPWarning,
        }

        backendInstance, err := NewNextcloudBackend(connConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set backend name and config fields for credential resolution
        <span class="cov6" title="13">if nb, ok := backendInstance.(*NextcloudBackend); ok </span><span class="cov6" title="13">{
                nb.BackendName = bc.Name
                nb.ConfigHost = bc.Host
                nb.ConfigUsername = bc.Username
        }</span>

        <span class="cov6" title="13">return backendInstance, nil</span>
}

func (nB *NextcloudBackend) BasicValidation() error <span class="cov2" title="2">{
        if nB.Connector.URL == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("connector URL is nil")
        }</span>

        // Credentials can come from URL, keyring, or environment variables
        // Only require URL.User if we're not using keyring/env (i.e., no BackendName)
        <span class="cov2" title="2">if nB.BackendName == "" &amp;&amp; nB.Connector.URL.User == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("no user credentials in URL and no backend name for credential resolution")
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package nextcloud

import (
        "gosynctasks/backend"
        "fmt"
        "strconv"
        "strings"
        "time"
)

func (nB *NextcloudBackend) parseVTODOs(xmlData string) ([]backend.Task, error) <span class="cov3" title="6">{
        var tasks []backend.Task

        // Extract VTODO blocks from XML
        vtodoBlocks := extractVTODOBlocks(xmlData)

        for _, vtodo := range vtodoBlocks </span><span class="cov4" title="12">{
                task, err := parseVTODO(vtodo)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip invalid tasks
                }
                <span class="cov4" title="12">tasks = append(tasks, task)</span>
        }

        <span class="cov3" title="6">return tasks, nil</span>
}

func extractVTODOBlocks(xmlData string) []string <span class="cov4" title="12">{
        var blocks []string
        lines := strings.Split(xmlData, "\n")

        var currentBlock strings.Builder
        inVTODO := false

        for _, line := range lines </span><span class="cov10" title="303">{
                line = strings.TrimSpace(line)

                if strings.HasPrefix(line, "BEGIN:VTODO") </span><span class="cov5" title="17">{
                        inVTODO = true
                        currentBlock.Reset()
                        currentBlock.WriteString(line + "\n")
                }</span> else<span class="cov9" title="286"> if strings.HasPrefix(line, "END:VTODO") &amp;&amp; inVTODO </span><span class="cov5" title="17">{
                        currentBlock.WriteString(line + "\n")
                        blocks = append(blocks, currentBlock.String())
                        inVTODO = false
                }</span> else<span class="cov9" title="269"> if inVTODO </span><span class="cov8" title="100">{
                        currentBlock.WriteString(line + "\n")
                }</span>
        }

        <span class="cov4" title="12">return blocks</span>
}

func parseVTODO(vtodo string) (backend.Task, error) <span class="cov5" title="19">{
        task := backend.Task{
                Status:   "NEEDS-ACTION",
                Priority: 0,
                Created:  time.Now(),
                Modified: time.Now(),
        }

        lines := strings.SplitSeq(vtodo, "\n")

        for line := range lines </span><span class="cov9" title="164">{
                line = strings.TrimSpace(line)
                if line == "" </span><span class="cov4" title="12">{
                        continue</span>
                }

                <span class="cov8" title="152">parts := strings.SplitN(line, ":", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="152">key := parts[0]
                value := parts[1]

                // Handle parameters (e.g., DTSTART;VALUE=DATE:20240101)
                if strings.Contains(key, ";") </span><span class="cov2" title="2">{
                        key = strings.Split(key, ";")[0]
                }</span>

                <span class="cov8" title="152">switch key </span>{
                case "UID":<span class="cov5" title="18">
                        task.UID = value</span>
                case "SUMMARY":<span class="cov5" title="19">
                        task.Summary = unescapeText(value)</span>
                case "DESCRIPTION":<span class="cov4" title="8">
                        task.Description = unescapeText(value)</span>
                case "STATUS":<span class="cov5" title="13">
                        task.Status = value</span>
                case "PRIORITY":<span class="cov5" title="13">
                        if p := parseInt(value); p &gt;= 0 &amp;&amp; p &lt;= 9 </span><span class="cov5" title="13">{
                                task.Priority = p
                        }</span>
                case "CREATED":<span class="cov5" title="13">
                        if t, err := parseICalTime(value); err == nil </span><span class="cov5" title="13">{
                                task.Created = t
                        }</span>
                case "LAST-MODIFIED":<span class="cov5" title="13">
                        if t, err := parseICalTime(value); err == nil </span><span class="cov5" title="13">{
                                task.Modified = t
                        }</span>
                case "DUE":<span class="cov4" title="8">
                        if t, err := parseICalTime(value); err == nil </span><span class="cov4" title="8">{
                                task.DueDate = &amp;t
                        }</span>
                case "DTSTART":<span class="cov1" title="1">
                        if t, err := parseICalTime(value); err == nil </span><span class="cov1" title="1">{
                                task.StartDate = &amp;t
                        }</span>
                case "COMPLETED":<span class="cov3" title="6">
                        if t, err := parseICalTime(value); err == nil </span><span class="cov3" title="6">{
                                task.Completed = &amp;t
                        }</span>
                case "CATEGORIES":<span class="cov1" title="1">
                        task.Categories = strings.Split(unescapeText(value), ",")</span>
                case "RELATED-TO":<span class="cov1" title="1">
                        task.ParentUID = value</span>
                }
        }

        <span class="cov5" title="19">if task.UID == "" </span><span class="cov1" title="1">{
                return task, fmt.Errorf("missing UID")
        }</span>

        <span class="cov5" title="18">return task, nil</span>
}

func parseICalTime(value string) (time.Time, error) <span class="cov7" title="47">{
        // Handle different iCal time formats
        formats := []string{
                "20060102T150405Z", // UTC
                "20060102T150405",  // Local
                "20060102",         // Date only
        }

        for _, format := range formats </span><span class="cov7" title="60">{
                if t, err := time.Parse(format, value); err == nil </span><span class="cov6" title="44">{
                        return t, nil
                }</span>
        }

        <span class="cov2" title="3">return time.Time{}, fmt.Errorf("invalid time format: %s", value)</span>
}

func unescapeText(text string) string <span class="cov6" title="35">{
        text = strings.ReplaceAll(text, "\\n", "\n")
        text = strings.ReplaceAll(text, "\\,", ",")
        text = strings.ReplaceAll(text, "\\;", ";")
        text = strings.ReplaceAll(text, "\\\\", "\\")
        return text
}</span>

func parseInt(s string) int <span class="cov5" title="19">{
        if i, err := strconv.Atoi(s); err == nil </span><span class="cov5" title="16">{
                return i
        }</span>
        <span class="cov2" title="3">return 0</span>
}

func (nB *NextcloudBackend) parseTaskLists(xmlData, baseURL string) ([]backend.TaskList, error) <span class="cov1" title="1">{
        var taskLists []backend.TaskList

        responses := extractResponses(xmlData)

        for _, response := range responses </span><span class="cov2" title="2">{
                // Only include calendars with 200 OK status and VTODO support
                if !strings.Contains(response, "HTTP/1.1 200 OK") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov2" title="2">taskList := parseTaskListResponse(response, baseURL)

                // Skip trashbin, inbox, outbox, and other special collections
                if taskList.ID == "trashbin" || taskList.ID == "inbox" || taskList.ID == "outbox" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip deleted calendars (those with deleted-calendar resourcetype)
                // Check for &lt;deleted-calendar xmlns="http://nextcloud.com/ns"/&gt;
                <span class="cov2" title="2">isDeleted := isDeletedCalendar(response)

                if isDeleted </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Only include calendars that actually support VTODO
                <span class="cov2" title="2">if taskList.ID != "" &amp;&amp; strings.Contains(response, `&lt;cal:comp name="VTODO"/&gt;`) </span><span class="cov2" title="2">{
                        taskLists = append(taskLists, taskList)
                }</span>
        }

        <span class="cov1" title="1">return taskLists, nil</span>
}

func (nB *NextcloudBackend) parseDeletedTaskLists(xmlData, baseURL string) ([]backend.TaskList, error) <span class="cov0" title="0">{
        var taskLists []backend.TaskList

        responses := extractResponses(xmlData)

        for _, response := range responses </span><span class="cov0" title="0">{
                // Only include calendars with 200 OK status and VTODO support
                if !strings.Contains(response, "HTTP/1.1 200 OK") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">taskList := parseTaskListResponse(response, baseURL)

                // Skip trashbin, inbox, outbox, and other special collections
                if taskList.ID == "trashbin" || taskList.ID == "inbox" || taskList.ID == "outbox" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Only include deleted calendars (those with deleted-calendar resourcetype)
                // Check for &lt;deleted-calendar xmlns="http://nextcloud.com/ns"/&gt;
                <span class="cov0" title="0">isDeleted := isDeletedCalendar(response)

                if !isDeleted </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Only include calendars that actually support VTODO
                <span class="cov0" title="0">if taskList.ID != "" &amp;&amp; strings.Contains(response, `&lt;cal:comp name="VTODO"/&gt;`) </span><span class="cov0" title="0">{
                        taskLists = append(taskLists, taskList)
                }</span>
        }

        <span class="cov0" title="0">return taskLists, nil</span>
}

// isDeletedCalendar checks if a calendar response contains the deleted-calendar resourcetype
func isDeletedCalendar(response string) bool <span class="cov2" title="2">{
        // Check for the deleted-calendar element in resourcetype
        // The element can appear in several forms:
        // 1. &lt;deleted-calendar xmlns="http://nextcloud.com/ns"/&gt;
        // 2. &lt;nc:deleted-calendar/&gt;
        // 3. Within a resourcetype: &lt;d:resourcetype&gt;...&lt;deleted-calendar/&gt;...&lt;/d:resourcetype&gt;

        // First, try to find the resourcetype section
        resourceTypeStart := strings.Index(response, "&lt;resourcetype&gt;")
        if resourceTypeStart == -1 </span><span class="cov2" title="2">{
                resourceTypeStart = strings.Index(response, "&lt;d:resourcetype&gt;")
        }</span>

        <span class="cov2" title="2">if resourceTypeStart != -1 </span><span class="cov0" title="0">{
                // Find the end of resourcetype
                resourceTypeEnd := strings.Index(response[resourceTypeStart:], "&lt;/resourcetype&gt;")
                if resourceTypeEnd == -1 </span><span class="cov0" title="0">{
                        resourceTypeEnd = strings.Index(response[resourceTypeStart:], "&lt;/d:resourcetype&gt;")
                }</span>

                <span class="cov0" title="0">if resourceTypeEnd != -1 </span><span class="cov0" title="0">{
                        // Extract the resourcetype content
                        resourceTypeContent := response[resourceTypeStart : resourceTypeStart+resourceTypeEnd]

                        // Check if deleted-calendar is present in resourcetype
                        return strings.Contains(resourceTypeContent, "deleted-calendar")
                }</span>
        }

        // Fallback: check anywhere in response (less accurate but safer)
        <span class="cov2" title="2">return strings.Contains(response, "deleted-calendar")</span>
}

func containsVTODO(response string) bool <span class="cov0" title="0">{
        return strings.Contains(response, `&lt;cal:comp name="VTODO"/&gt;`)
}</span>

func extractResponses(xmlData string) []string <span class="cov3" title="6">{
        var responses []string

        // Try different response tag patterns
        patterns := []string{
                "&lt;d:response&gt;",
                "&lt;response&gt;",
                "&lt;D:response&gt;",
        }

        for _, startTag := range patterns </span><span class="cov4" title="11">{
                endTag := strings.Replace(startTag, "&lt;", "&lt;/", 1)

                data := xmlData
                for </span><span class="cov5" title="18">{
                        start := strings.Index(data, startTag)
                        if start == -1 </span><span class="cov4" title="11">{
                                break</span>
                        }

                        <span class="cov4" title="7">end := strings.Index(data[start:], endTag)
                        if end == -1 </span><span class="cov0" title="0">{
                                break</span>
                        }

                        <span class="cov4" title="7">response := data[start : start+end+len(endTag)]
                        responses = append(responses, response)
                        data = data[start+end+len(endTag):]</span>
                }

                <span class="cov4" title="11">if len(responses) &gt; 0 </span><span class="cov3" title="5">{
                        break</span>
                }
        }

        // fmt.Printf("extractResponses found %d responses\n", len(responses))
        <span class="cov3" title="6">return responses</span>
}

func parseTaskListResponse(response, baseURL string) backend.TaskList <span class="cov3" title="4">{
        taskList := backend.TaskList{}

        // Extract href (calendar ID)
        if href := extractXMLValue(response, "href"); href != "" </span><span class="cov3" title="4">{
                // Extract calendar ID from href path
                parts := strings.Split(strings.Trim(href, "/"), "/")
                if len(parts) &gt; 0 </span><span class="cov3" title="4">{
                        taskList.ID = parts[len(parts)-1]
                }</span>
                <span class="cov3" title="4">taskList.URL = href</span>
        }

        // Extract displayname
        <span class="cov3" title="4">taskList.Name = extractXMLValue(response, "displayname")

        // Extract ctag
        taskList.CTags = extractXMLValue(response, "getctag")

        // Extract color
        taskList.Color = extractXMLValue(response, "calendar-color")

        // Extract deleted-at timestamp (Nextcloud trash)
        taskList.DeletedAt = extractXMLValue(response, "deleted-at")

        return taskList</span>
}

func extractXMLValue(xml, tag string) string <span class="cov6" title="29">{
        // Try without namespace prefix first
        if start := strings.Index(xml, fmt.Sprintf("&lt;%s&gt;", tag)); start != -1 </span><span class="cov3" title="4">{
                start += len(tag) + 2
                if end := strings.Index(xml[start:], fmt.Sprintf("&lt;/%s&gt;", tag)); end != -1 </span><span class="cov3" title="4">{
                        return strings.TrimSpace(xml[start : start+end])
                }</span>
        }

        // Try with namespace prefixes
        <span class="cov6" title="25">for _, prefix := range []string{"d:", "cs:", "ic:", "nc:"} </span><span class="cov7" title="60">{
                fullTag := prefix + tag
                if start := strings.Index(xml, fmt.Sprintf("&lt;%s&gt;", fullTag)); start != -1 </span><span class="cov5" title="17">{
                        start += len(fullTag) + 2
                        if end := strings.Index(xml[start:], fmt.Sprintf("&lt;/%s&gt;", fullTag)); end != -1 </span><span class="cov5" title="17">{
                                return strings.TrimSpace(xml[start : start+end])
                        }</span>
                }
        }

        <span class="cov4" title="8">return ""</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package backend

import (
        "fmt"
        "sync"
)

// BackendConstructor is a function that creates a new backend instance
type BackendConstructor func(config ConnectorConfig) (TaskManager, error)

// BackendConfigConstructor is a function that creates a backend from BackendConfig
type BackendConfigConstructor func(config BackendConfig) (TaskManager, error)

// Registry holds registered backend constructors
type Registry struct {
        mu                       sync.RWMutex
        schemeConstructors       map[string]BackendConstructor
        typeConstructors         map[string]BackendConfigConstructor
        detectableConstructors   map[string]BackendConfigConstructor
}

var globalRegistry = &amp;Registry{
        schemeConstructors:     make(map[string]BackendConstructor),
        typeConstructors:       make(map[string]BackendConfigConstructor),
        detectableConstructors: make(map[string]BackendConfigConstructor),
}

// RegisterScheme registers a backend constructor for a URL scheme
func RegisterScheme(scheme string, constructor BackendConstructor) <span class="cov6" title="2">{
        globalRegistry.mu.Lock()
        defer globalRegistry.mu.Unlock()
        globalRegistry.schemeConstructors[scheme] = constructor
}</span>

// RegisterType registers a backend constructor for a config type
func RegisterType(backendType string, constructor BackendConfigConstructor) <span class="cov10" title="3">{
        globalRegistry.mu.Lock()
        defer globalRegistry.mu.Unlock()
        globalRegistry.typeConstructors[backendType] = constructor
}</span>

// RegisterDetectable registers a backend as detectable with auto-detection capability
func RegisterDetectable(backendType string, constructor BackendConfigConstructor) <span class="cov1" title="1">{
        globalRegistry.mu.Lock()
        defer globalRegistry.mu.Unlock()
        globalRegistry.detectableConstructors[backendType] = constructor
        // Also register as a regular type
        globalRegistry.typeConstructors[backendType] = constructor
}</span>

// GetSchemeConstructor returns the constructor for a URL scheme
func GetSchemeConstructor(scheme string) (BackendConstructor, error) <span class="cov0" title="0">{
        globalRegistry.mu.RLock()
        defer globalRegistry.mu.RUnlock()

        constructor, ok := globalRegistry.schemeConstructors[scheme]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unsupported URL scheme: %s", scheme)
        }</span>
        <span class="cov0" title="0">return constructor, nil</span>
}

// GetTypeConstructor returns the constructor for a backend type
func GetTypeConstructor(backendType string) (BackendConfigConstructor, error) <span class="cov1" title="1">{
        globalRegistry.mu.RLock()
        defer globalRegistry.mu.RUnlock()

        constructor, ok := globalRegistry.typeConstructors[backendType]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unsupported backend type: %s", backendType)
        }</span>
        <span class="cov1" title="1">return constructor, nil</span>
}

// GetDetectableConstructors returns all detectable backend constructors
func GetDetectableConstructors() map[string]BackendConfigConstructor <span class="cov0" title="0">{
        globalRegistry.mu.RLock()
        defer globalRegistry.mu.RUnlock()

        // Return a copy to avoid concurrent access issues
        result := make(map[string]BackendConfigConstructor)
        for k, v := range globalRegistry.detectableConstructors </span><span class="cov0" title="0">{
                result[k] = v
        }</span>
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package backend

import (
        "fmt"
        "strings"
)

// BackendRegistry manages configured backends and provides access to them.
// It stores backend instances keyed by their configuration name.
type BackendRegistry struct {
        backends map[string]TaskManager
        configs  map[string]BackendConfig
}

// NewBackendRegistry creates a new BackendRegistry from a map of backend configurations.
func NewBackendRegistry(configs map[string]BackendConfig) (*BackendRegistry, error) <span class="cov1" title="1">{
        registry := &amp;BackendRegistry{
                backends: make(map[string]TaskManager),
                configs:  configs,
        }

        // Initialize all enabled backends
        for name, config := range configs </span><span class="cov3" title="2">{
                if !config.Enabled </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov1" title="1">taskManager, err := config.TaskManager()
                if err != nil </span><span class="cov0" title="0">{
                        // Skip backends that can't be initialized (e.g., git backend when not in a git repo)
                        continue</span>
                }

                <span class="cov1" title="1">registry.backends[name] = taskManager</span>
        }

        <span class="cov1" title="1">return registry, nil</span>
}

// GetBackend returns the TaskManager for the specified backend name.
// Returns an error if the backend doesn't exist or isn't initialized.
func (r *BackendRegistry) GetBackend(name string) (TaskManager, error) <span class="cov10" title="11">{
        backend, exists := r.backends[name]
        if !exists </span><span class="cov5" title="3">{
                return nil, fmt.Errorf("backend %q not found or not initialized", name)
        }</span>
        <span class="cov8" title="8">return backend, nil</span>
}

// ListBackends returns information about all configured backends.
func (r *BackendRegistry) ListBackends() []BackendInfo <span class="cov1" title="1">{
        var infos []BackendInfo

        for name, config := range r.configs </span><span class="cov3" title="2">{
                info := BackendInfo{
                        Name:    name,
                        Type:    config.Type,
                        Enabled: config.Enabled,
                        Ready:   false,
                }

                // Check if backend is actually initialized
                if _, exists := r.backends[name]; exists </span><span class="cov1" title="1">{
                        info.Ready = true
                }</span>

                // Add detection info if backend supports it
                <span class="cov3" title="2">if backend, exists := r.backends[name]; exists </span><span class="cov1" title="1">{
                        if detectable, ok := backend.(DetectableBackend); ok </span><span class="cov0" title="0">{
                                if detected, err := detectable.CanDetect(); err == nil &amp;&amp; detected </span><span class="cov0" title="0">{
                                        info.Detected = true
                                        info.DetectionInfo = detectable.DetectionInfo()
                                }</span>
                        }
                }

                <span class="cov3" title="2">infos = append(infos, info)</span>
        }

        <span class="cov1" title="1">return infos</span>
}

// GetEnabledBackends returns a slice of names of all enabled backends.
func (r *BackendRegistry) GetEnabledBackends() []string <span class="cov3" title="2">{
        var enabled []string
        for name, config := range r.configs </span><span class="cov1" title="1">{
                if config.Enabled </span><span class="cov1" title="1">{
                        if _, exists := r.backends[name]; exists </span><span class="cov1" title="1">{
                                enabled = append(enabled, name)
                        }</span>
                }
        }
        <span class="cov3" title="2">return enabled</span>
}

// BackendInfo contains information about a backend for display purposes.
type BackendInfo struct {
        Name          string
        Type          string
        Enabled       bool
        Ready         bool   // Whether the backend is initialized
        Detected      bool   // Whether the backend was auto-detected
        DetectionInfo string // Human-readable detection information
}

// String returns a formatted string representation of the backend info.
func (bi BackendInfo) String() string <span class="cov1" title="1">{
        var parts []string
        parts = append(parts, fmt.Sprintf("Name: %s", bi.Name))
        parts = append(parts, fmt.Sprintf("Type: %s", bi.Type))

        var status []string
        if bi.Enabled </span><span class="cov1" title="1">{
                status = append(status, "enabled")
        }</span> else<span class="cov0" title="0"> {
                status = append(status, "disabled")
        }</span>
        <span class="cov1" title="1">if bi.Ready </span><span class="cov1" title="1">{
                status = append(status, "ready")
        }</span> else<span class="cov0" title="0"> {
                status = append(status, "not ready")
        }</span>
        <span class="cov1" title="1">if bi.Detected </span><span class="cov1" title="1">{
                status = append(status, "detected")
        }</span>

        <span class="cov1" title="1">parts = append(parts, fmt.Sprintf("Status: %s", strings.Join(status, ", ")))

        if bi.DetectionInfo != "" </span><span class="cov1" title="1">{
                parts = append(parts, fmt.Sprintf("Detection: %s", bi.DetectionInfo))
        }</span>

        <span class="cov1" title="1">return strings.Join(parts, " | ")</span>
}

// BackendSelector implements the backend selection logic based on priority.
type BackendSelector struct {
        registry *BackendRegistry
}

// NewBackendSelector creates a new BackendSelector with the given registry.
func NewBackendSelector(registry *BackendRegistry) *BackendSelector <span class="cov9" title="10">{
        return &amp;BackendSelector{
                registry: registry,
        }
}</span>

// Select chooses a backend based on the selection criteria.
// Selection priority:
// 1. Explicit backend name (if provided)
// 2. Sync local backend (if sync is enabled and no explicit backend)
// 3. Auto-detection (if enabled)
// 4. Default backend
// 5. First enabled backend
func (s *BackendSelector) Select(explicitBackend string, autoDetect bool, defaultBackend string, priority []string, syncEnabled bool, syncLocalBackend string) (string, TaskManager, error) <span class="cov9" title="9">{
        // Priority 1: Explicit backend name
        if explicitBackend != "" </span><span class="cov5" title="3">{
                backend, err := s.registry.GetBackend(explicitBackend)
                if err != nil </span><span class="cov1" title="1">{
                        return "", nil, fmt.Errorf("explicitly specified backend %q: %w", explicitBackend, err)
                }</span>
                <span class="cov3" title="2">return explicitBackend, backend, nil</span>
        }

        // Priority 2: Sync local backend (when sync is enabled)
        // This ensures that when sync is active, operations use the local backend
        // and sync happens in the background to the remote backend
        <span class="cov7" title="6">if syncEnabled &amp;&amp; syncLocalBackend != "" </span><span class="cov1" title="1">{
                backend, err := s.registry.GetBackend(syncLocalBackend)
                if err == nil </span><span class="cov1" title="1">{
                        return syncLocalBackend, backend, nil
                }</span>
                // If sync local backend fails, fall through to next priority
        }

        // Priority 3: Auto-detection
        <span class="cov7" title="5">if autoDetect </span><span class="cov1" title="1">{
                name, backend, err := s.autoDetect(priority)
                if err == nil &amp;&amp; backend != nil </span><span class="cov1" title="1">{
                        return name, backend, nil
                }</span>
                // If auto-detection fails, fall through to next priority
        }

        // Priority 4: Default backend
        <span class="cov6" title="4">if defaultBackend != "" </span><span class="cov3" title="2">{
                backend, err := s.registry.GetBackend(defaultBackend)
                if err == nil </span><span class="cov3" title="2">{
                        return defaultBackend, backend, nil
                }</span>
                // If default backend fails, fall through to next priority
        }

        // Priority 5: First enabled backend
        <span class="cov3" title="2">enabled := s.registry.GetEnabledBackends()
        if len(enabled) &gt; 0 </span><span class="cov1" title="1">{
                name := enabled[0]
                backend, err := s.registry.GetBackend(name)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil, fmt.Errorf("failed to get first enabled backend: %w", err)
                }</span>
                <span class="cov1" title="1">return name, backend, nil</span>
        }

        <span class="cov1" title="1">return "", nil, fmt.Errorf("no backends available")</span>
}

// autoDetect attempts to detect a usable backend based on the environment.
// It checks backends in priority order and returns the first detected one.
func (s *BackendSelector) autoDetect(priority []string) (string, TaskManager, error) <span class="cov1" title="1">{
        // Try backends in priority order first
        for _, name := range priority </span><span class="cov1" title="1">{
                backend, err := s.registry.GetBackend(name)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if backend supports detection
                <span class="cov1" title="1">if detectable, ok := backend.(DetectableBackend); ok </span><span class="cov1" title="1">{
                        detected, err := detectable.CanDetect()
                        if err == nil &amp;&amp; detected </span><span class="cov1" title="1">{
                                return name, backend, nil
                        }</span>
                }
        }

        // If no priority backend detected, try all detectable backends
        <span class="cov0" title="0">for name, backend := range s.registry.backends </span><span class="cov0" title="0">{
                if detectable, ok := backend.(DetectableBackend); ok </span><span class="cov0" title="0">{
                        detected, err := detectable.CanDetect()
                        if err == nil &amp;&amp; detected </span><span class="cov0" title="0">{
                                return name, backend, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return "", nil, fmt.Errorf("no backend detected")</span>
}

// DetectAll returns information about all detected backends.
func (s *BackendSelector) DetectAll() []BackendInfo <span class="cov1" title="1">{
        var detected []BackendInfo

        for name, backend := range s.registry.backends </span><span class="cov3" title="2">{
                if detectable, ok := backend.(DetectableBackend); ok </span><span class="cov1" title="1">{
                        if canDetect, err := detectable.CanDetect(); err == nil &amp;&amp; canDetect </span><span class="cov1" title="1">{
                                config := s.registry.configs[name]
                                info := BackendInfo{
                                        Name:          name,
                                        Type:          config.Type,
                                        Enabled:       config.Enabled,
                                        Ready:         true,
                                        Detected:      true,
                                        DetectionInfo: detectable.DetectionInfo(),
                                }
                                detected = append(detected, info)
                        }</span>
                }
        }

        <span class="cov1" title="1">return detected</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package sqlite

import (
        "gosynctasks/backend"
        "database/sql"
        "fmt"
        "strings"
        "time"

        _ "modernc.org/sqlite" // SQLite driver
)

func init() <span class="cov1" title="1">{
        // Register SQLite backend for config type "sqlite"
        backend.RegisterType("sqlite", newSQLiteBackendWrapper)
}</span>

// newSQLiteBackendWrapper wraps NewSQLiteBackend to match BackendConfigConstructor signature
func newSQLiteBackendWrapper(config backend.BackendConfig) (backend.TaskManager, error) <span class="cov0" title="0">{
        return NewSQLiteBackend(config)
}</span>

// SQLiteError represents errors specific to SQLite backend operations
type SQLiteError struct {
        Op      string // Operation that failed
        Err     error  // Underlying error
        ListID  string // Optional: list ID if relevant
        TaskUID string // Optional: task UID if relevant
}

func (e *SQLiteError) Error() string <span class="cov1" title="1">{
        if e.ListID != "" &amp;&amp; e.TaskUID != "" </span><span class="cov1" title="1">{
                return fmt.Sprintf("sqlite %s failed for task %s in list %s: %v", e.Op, e.TaskUID, e.ListID, e.Err)
        }</span> else<span class="cov0" title="0"> if e.ListID != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("sqlite %s failed for list %s: %v", e.Op, e.ListID, e.Err)
        }</span> else<span class="cov0" title="0"> if e.TaskUID != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("sqlite %s failed for task %s: %v", e.Op, e.TaskUID, e.Err)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("sqlite %s failed: %v", e.Op, e.Err)</span>
}

func (e *SQLiteError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// SQLiteBackend implements backend.TaskManager interface for local SQLite storage
type SQLiteBackend struct {
        Config backend.BackendConfig
        db     *Database
}

// NewSQLiteBackend creates a new SQLite backend instance
func NewSQLiteBackend(config backend.BackendConfig) (*SQLiteBackend, error) <span class="cov6" title="32">{
        sb := &amp;SQLiteBackend{
                Config: config,
        }

        // Initialize database immediately
        if err := sb.initDB(); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;SQLiteError{Op: "init", Err: err}
        }</span>

        <span class="cov6" title="32">return sb, nil</span>
}

// initDB initializes the database connection (lazy initialization)
func (sb *SQLiteBackend) initDB() error <span class="cov9" title="115">{
        if sb.db != nil </span><span class="cov8" title="83">{
                return nil // Already initialized
        }</span>

        <span class="cov6" title="32">db, err := InitDatabase(sb.Config.DBPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="32">sb.db = db
        return nil</span>
}

// GetDB returns the database connection, initializing if necessary
func (sb *SQLiteBackend) GetDB() (*Database, error) <span class="cov8" title="83">{
        if err := sb.initDB(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="83">return sb.db, nil</span>
}

// Close closes the database connection
func (sb *SQLiteBackend) Close() error <span class="cov6" title="33">{
        if sb.db != nil </span><span class="cov6" title="33">{
                return sb.db.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetTaskLists retrieves all task lists from local storage
func (sb *SQLiteBackend) GetTaskLists() ([]backend.TaskList, error) <span class="cov3" title="4">{
        db, err := sb.GetDB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;SQLiteError{Op: "GetTaskLists", Err: err}
        }</span>

        <span class="cov3" title="4">query := `
                SELECT list_id, list_name, list_color, last_ctag, created_at, modified_at
                FROM list_sync_metadata
                ORDER BY list_name ASC
        `

        rows, err := db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;SQLiteError{Op: "GetTaskLists", Err: err}
        }</span>
        <span class="cov3" title="4">defer func() </span><span class="cov3" title="4">{ _ = rows.Close() }</span>()

        <span class="cov3" title="4">var lists []backend.TaskList
        for rows.Next() </span><span class="cov3" title="4">{
                var list backend.TaskList
                var createdAt, modifiedAt sql.NullInt64
                var ctag sql.NullString

                err := rows.Scan(
                        &amp;list.ID,
                        &amp;list.Name,
                        &amp;list.Color,
                        &amp;ctag,
                        &amp;createdAt,
                        &amp;modifiedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, &amp;SQLiteError{Op: "GetTaskLists", Err: err}
                }</span>

                <span class="cov3" title="4">if ctag.Valid </span><span class="cov0" title="0">{
                        list.CTags = ctag.String
                }</span>

                <span class="cov3" title="4">lists = append(lists, list)</span>
        }

        <span class="cov3" title="4">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;SQLiteError{Op: "GetTaskLists", Err: err}
        }</span>

        <span class="cov3" title="4">return lists, nil</span>
}

// GetTasks retrieves tasks from a list with optional filtering
func (sb *SQLiteBackend) GetTasks(listID string, taskFilter *backend.TaskFilter) ([]backend.Task, error) <span class="cov5" title="12">{
        db, err := sb.GetDB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;SQLiteError{Op: "GetTasks", ListID: listID, Err: err}
        }</span>

        // Build query with filters
        <span class="cov5" title="12">query := `
                SELECT id, list_id, summary, description, status, priority,
                       created_at, modified_at, due_date, start_date, completed_at,
                       parent_uid, categories
                FROM tasks
                WHERE list_id = ?
        `

        args := []interface{}{listID}
        query, args = sb.applyFilters(query, args, taskFilter)
        query += " ORDER BY priority ASC, created_at DESC"

        rows, err := db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;SQLiteError{Op: "GetTasks", ListID: listID, Err: err}
        }</span>
        <span class="cov5" title="12">defer func() </span><span class="cov5" title="12">{ _ = rows.Close() }</span>()

        <span class="cov5" title="12">tasks, err := sb.scanTasks(rows)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;SQLiteError{Op: "GetTasks", ListID: listID, Err: err}
        }</span>

        <span class="cov5" title="12">return tasks, nil</span>
}

// applyFilters adds WHERE clauses for task filtering
func (sb *SQLiteBackend) applyFilters(query string, args []interface{}, filter *backend.TaskFilter) (string, []interface{}) <span class="cov5" title="12">{
        if filter == nil </span><span class="cov4" title="10">{
                return query, args
        }</span>

        // Status filter
        <span class="cov2" title="2">if filter.Statuses != nil &amp;&amp; len(*filter.Statuses) &gt; 0 </span><span class="cov1" title="1">{
                placeholders := make([]string, len(*filter.Statuses))
                for i, status := range *filter.Statuses </span><span class="cov1" title="1">{
                        placeholders[i] = "?"
                        args = append(args, status)
                }</span>
                <span class="cov1" title="1">query += fmt.Sprintf(" AND status IN (%s)", strings.Join(placeholders, ","))</span>
        }

        // Exclude statuses filter
        <span class="cov2" title="2">if filter.ExcludeStatuses != nil &amp;&amp; len(*filter.ExcludeStatuses) &gt; 0 </span><span class="cov0" title="0">{
                placeholders := make([]string, len(*filter.ExcludeStatuses))
                for i, status := range *filter.ExcludeStatuses </span><span class="cov0" title="0">{
                        placeholders[i] = "?"
                        args = append(args, status)
                }</span>
                <span class="cov0" title="0">query += fmt.Sprintf(" AND status NOT IN (%s)", strings.Join(placeholders, ","))</span>
        }

        // Due date filters
        <span class="cov2" title="2">if filter.DueBefore != nil </span><span class="cov1" title="1">{
                query += " AND due_date &lt;= ?"
                args = append(args, filter.DueBefore.Unix())
        }</span>
        <span class="cov2" title="2">if filter.DueAfter != nil </span><span class="cov0" title="0">{
                query += " AND due_date &gt;= ?"
                args = append(args, filter.DueAfter.Unix())
        }</span>

        // Created date filters
        <span class="cov2" title="2">if filter.CreatedBefore != nil </span><span class="cov0" title="0">{
                query += " AND created_at &lt;= ?"
                args = append(args, filter.CreatedBefore.Unix())
        }</span>
        <span class="cov2" title="2">if filter.CreatedAfter != nil </span><span class="cov0" title="0">{
                query += " AND created_at &gt;= ?"
                args = append(args, filter.CreatedAfter.Unix())
        }</span>

        // Priority filter (if we add it to backend.TaskFilter in future)
        // Categories filter would need LIKE queries for the categories TEXT field

        <span class="cov2" title="2">return query, args</span>
}

// scanTasks scans task rows from a query result
func (sb *SQLiteBackend) scanTasks(rows *sql.Rows) ([]backend.Task, error) <span class="cov5" title="17">{
        var tasks []backend.Task

        for rows.Next() </span><span class="cov5" title="16">{
                var task backend.Task
                var listID string // Temporary variable for list_id (not stored in backend.Task struct)
                var description, parentUID, categories sql.NullString
                var createdAt, modifiedAt, dueDate, startDate, completedAt sql.NullInt64

                err := rows.Scan(
                        &amp;task.UID,
                        &amp;listID, // Scan list_id but don't store in backend.Task
                        &amp;task.Summary,
                        &amp;description,
                        &amp;task.Status,
                        &amp;task.Priority,
                        &amp;createdAt,
                        &amp;modifiedAt,
                        &amp;dueDate,
                        &amp;startDate,
                        &amp;completedAt,
                        &amp;parentUID,
                        &amp;categories,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Handle nullable fields
                <span class="cov5" title="16">if description.Valid </span><span class="cov1" title="1">{
                        task.Description = description.String
                }</span>
                <span class="cov5" title="16">if parentUID.Valid </span><span class="cov1" title="1">{
                        task.ParentUID = parentUID.String
                }</span>
                <span class="cov5" title="16">if categories.Valid &amp;&amp; categories.String != "" </span><span class="cov1" title="1">{
                        task.Categories = strings.Split(categories.String, ",")
                }</span>

                // Convert timestamps
                <span class="cov5" title="16">if createdAt.Valid </span><span class="cov5" title="16">{
                        task.Created = time.Unix(createdAt.Int64, 0)
                }</span>
                <span class="cov5" title="16">if modifiedAt.Valid </span><span class="cov5" title="16">{
                        task.Modified = time.Unix(modifiedAt.Int64, 0)
                }</span>
                <span class="cov5" title="16">if dueDate.Valid </span><span class="cov2" title="2">{
                        t := time.Unix(dueDate.Int64, 0)
                        task.DueDate = &amp;t
                }</span>
                <span class="cov5" title="16">if startDate.Valid </span><span class="cov1" title="1">{
                        t := time.Unix(startDate.Int64, 0)
                        task.StartDate = &amp;t
                }</span>
                <span class="cov5" title="16">if completedAt.Valid </span><span class="cov0" title="0">{
                        t := time.Unix(completedAt.Int64, 0)
                        task.Completed = &amp;t
                }</span>

                <span class="cov5" title="16">tasks = append(tasks, task)</span>
        }

        <span class="cov5" title="17">return tasks, rows.Err()</span>
}

// FindTasksBySummary searches for tasks by summary (case-insensitive)
func (sb *SQLiteBackend) FindTasksBySummary(listID string, summary string) ([]backend.Task, error) <span class="cov2" title="2">{
        db, err := sb.GetDB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;SQLiteError{Op: "FindTasksBySummary", ListID: listID, Err: err}
        }</span>

        <span class="cov2" title="2">query := `
                SELECT id, list_id, summary, description, status, priority,
                       created_at, modified_at, due_date, start_date, completed_at,
                       parent_uid, categories
                FROM tasks
                WHERE list_id = ? AND LOWER(summary) LIKE LOWER(?)
                ORDER BY
                        CASE WHEN LOWER(summary) = LOWER(?) THEN 0 ELSE 1 END,
                        priority ASC,
                        created_at DESC
        `

        searchPattern := "%" + summary + "%"
        rows, err := db.Query(query, listID, searchPattern, summary)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;SQLiteError{Op: "FindTasksBySummary", ListID: listID, Err: err}
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{ _ = rows.Close() }</span>()

        <span class="cov2" title="2">tasks, err := sb.scanTasks(rows)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;SQLiteError{Op: "FindTasksBySummary", ListID: listID, Err: err}
        }</span>

        <span class="cov2" title="2">return tasks, nil</span>
}

// AddTask creates a new task in the database
func (sb *SQLiteBackend) AddTask(listID string, task backend.Task) error <span class="cov6" title="23">{
        db, err := sb.GetDB()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "AddTask", ListID: listID, Err: err}
        }</span>

        // Generate UID if not provided
        <span class="cov6" title="23">if task.UID == "" </span><span class="cov1" title="1">{
                task.UID = GenerateUID()
        }</span>

        // Start transaction
        <span class="cov6" title="23">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "AddTask", ListID: listID, TaskUID: task.UID, Err: err}
        }</span>
        <span class="cov6" title="23">defer func() </span><span class="cov6" title="23">{ _ = tx.Rollback() }</span>()

        // Set timestamps
        <span class="cov6" title="23">now := time.Now()
        if task.Created.IsZero() </span><span class="cov6" title="23">{
                task.Created = now
        }</span>
        <span class="cov6" title="23">if task.Modified.IsZero() </span><span class="cov6" title="23">{
                task.Modified = now
        }</span>

        // Insert task
        <span class="cov6" title="23">query := `
                INSERT INTO tasks (
                        id, list_id, summary, description, status, priority,
                        created_at, modified_at, due_date, start_date, completed_at,
                        parent_uid, categories
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = tx.Exec(query,
                task.UID,
                listID,
                task.Summary,
                NullString(task.Description),
                task.Status,
                task.Priority,
                TimeValueToNullInt64(task.Created),
                TimeValueToNullInt64(task.Modified),
                TimeToNullInt64(task.DueDate),
                TimeToNullInt64(task.StartDate),
                TimeToNullInt64(task.Completed),
                NullString(task.ParentUID),
                NullString(strings.Join(task.Categories, ",")),
        )
        if err != nil </span><span class="cov1" title="1">{
                return &amp;SQLiteError{Op: "AddTask", ListID: listID, TaskUID: task.UID, Err: err}
        }</span>

        // Insert sync metadata
        <span class="cov6" title="22">_, err = tx.Exec(`
                INSERT INTO sync_metadata (task_uid, list_id, locally_modified, local_modified_at)
                VALUES (?, ?, 1, ?)
        `, task.UID, listID, now.Unix())
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "AddTask", ListID: listID, TaskUID: task.UID, Err: err}
        }</span>

        // Queue sync operation
        <span class="cov6" title="22">_, err = tx.Exec(`
                INSERT OR REPLACE INTO sync_queue (task_uid, list_id, operation, created_at)
                VALUES (?, ?, 'create', ?)
        `, task.UID, listID, now.Unix())
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "AddTask", ListID: listID, TaskUID: task.UID, Err: err}
        }</span>

        <span class="cov6" title="22">return tx.Commit()</span>
}

// UpdateTask updates an existing task
func (sb *SQLiteBackend) UpdateTask(listID string, task backend.Task) error <span class="cov2" title="2">{
        db, err := sb.GetDB()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "UpdateTask", ListID: listID, TaskUID: task.UID, Err: err}
        }</span>

        // Start transaction
        <span class="cov2" title="2">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "UpdateTask", ListID: listID, TaskUID: task.UID, Err: err}
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{ _ = tx.Rollback() }</span>()

        // Update modified timestamp
        <span class="cov2" title="2">now := time.Now()
        task.Modified = now

        // Update task
        query := `
                UPDATE tasks
                SET summary = ?, description = ?, status = ?, priority = ?,
                    modified_at = ?, due_date = ?, start_date = ?, completed_at = ?,
                    parent_uid = ?, categories = ?
                WHERE id = ? AND list_id = ?
        `

        result, err := tx.Exec(query,
                task.Summary,
                NullString(task.Description),
                task.Status,
                task.Priority,
                TimeValueToNullInt64(task.Modified),
                TimeToNullInt64(task.DueDate),
                TimeToNullInt64(task.StartDate),
                TimeToNullInt64(task.Completed),
                NullString(task.ParentUID),
                NullString(strings.Join(task.Categories, ",")),
                task.UID,
                listID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "UpdateTask", ListID: listID, TaskUID: task.UID, Err: err}
        }</span>

        // Check if task exists
        <span class="cov2" title="2">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "UpdateTask", ListID: listID, TaskUID: task.UID, Err: err}
        }</span>
        <span class="cov2" title="2">if rowsAffected == 0 </span><span class="cov1" title="1">{
                return backend.NewBackendError("UpdateTask", 404, fmt.Sprintf("task %s not found in list %s", task.UID, listID))
        }</span>

        // Update sync metadata
        <span class="cov1" title="1">_, err = tx.Exec(`
                UPDATE sync_metadata
                SET locally_modified = 1, local_modified_at = ?
                WHERE task_uid = ?
        `, now.Unix(), task.UID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "UpdateTask", ListID: listID, TaskUID: task.UID, Err: err}
        }</span>

        // Queue sync operation
        <span class="cov1" title="1">_, err = tx.Exec(`
                INSERT OR REPLACE INTO sync_queue (task_uid, list_id, operation, created_at)
                VALUES (?, ?, 'update', ?)
        `, task.UID, listID, now.Unix())
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "UpdateTask", ListID: listID, TaskUID: task.UID, Err: err}
        }</span>

        <span class="cov1" title="1">return tx.Commit()</span>
}

// DeleteTask removes a task from the database
func (sb *SQLiteBackend) DeleteTask(listID string, taskUID string) error <span class="cov2" title="2">{
        db, err := sb.GetDB()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "DeleteTask", ListID: listID, TaskUID: taskUID, Err: err}
        }</span>

        // Start transaction
        <span class="cov2" title="2">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "DeleteTask", ListID: listID, TaskUID: taskUID, Err: err}
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{ _ = tx.Rollback() }</span>()

        // Check if task exists
        <span class="cov2" title="2">var exists bool
        err = tx.QueryRow("SELECT EXISTS(SELECT 1 FROM tasks WHERE id = ? AND list_id = ?)", taskUID, listID).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "DeleteTask", ListID: listID, TaskUID: taskUID, Err: err}
        }</span>
        <span class="cov2" title="2">if !exists </span><span class="cov1" title="1">{
                return backend.NewBackendError("DeleteTask", 404, fmt.Sprintf("task %s not found in list %s", taskUID, listID))
        }</span>

        // Mark as locally deleted (soft delete for sync)
        <span class="cov1" title="1">now := time.Now().Unix()
        _, err = tx.Exec(`
                UPDATE sync_metadata
                SET locally_deleted = 1, local_modified_at = ?
                WHERE task_uid = ?
        `, now, taskUID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "DeleteTask", ListID: listID, TaskUID: taskUID, Err: err}
        }</span>

        // Queue delete operation
        <span class="cov1" title="1">_, err = tx.Exec(`
                INSERT OR REPLACE INTO sync_queue (task_uid, list_id, operation, created_at)
                VALUES (?, ?, 'delete', ?)
        `, taskUID, listID, now)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "DeleteTask", ListID: listID, TaskUID: taskUID, Err: err}
        }</span>

        // Delete task (cascade will delete sync_metadata)
        <span class="cov1" title="1">_, err = tx.Exec("DELETE FROM tasks WHERE id = ? AND list_id = ?", taskUID, listID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "DeleteTask", ListID: listID, TaskUID: taskUID, Err: err}
        }</span>

        <span class="cov1" title="1">return tx.Commit()</span>
}

// CreateTaskList creates a new task list
func (sb *SQLiteBackend) CreateTaskList(name, description, color string) (string, error) <span class="cov6" title="23">{
        db, err := sb.GetDB()
        if err != nil </span><span class="cov0" title="0">{
                return "", &amp;SQLiteError{Op: "CreateTaskList", Err: err}
        }</span>

        <span class="cov6" title="23">listID := GenerateUID()
        now := time.Now().Unix()

        _, err = db.Exec(`
                INSERT INTO list_sync_metadata (list_id, list_name, list_color, created_at, modified_at)
                VALUES (?, ?, ?, ?, ?)
        `, listID, name, color, now, now)
        if err != nil </span><span class="cov0" title="0">{
                return "", &amp;SQLiteError{Op: "CreateTaskList", Err: err}
        }</span>

        <span class="cov6" title="23">return listID, nil</span>
}

// DeleteTaskList removes a task list and all its tasks
func (sb *SQLiteBackend) DeleteTaskList(listID string) error <span class="cov2" title="2">{
        db, err := sb.GetDB()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "DeleteTaskList", ListID: listID, Err: err}
        }</span>

        <span class="cov2" title="2">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "DeleteTaskList", ListID: listID, Err: err}
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{ _ = tx.Rollback() }</span>()

        // Delete all tasks in the list (cascade will delete sync_metadata)
        <span class="cov2" title="2">_, err = tx.Exec("DELETE FROM tasks WHERE list_id = ?", listID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "DeleteTaskList", ListID: listID, Err: err}
        }</span>

        // Delete list metadata
        <span class="cov2" title="2">result, err := tx.Exec("DELETE FROM list_sync_metadata WHERE list_id = ?", listID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "DeleteTaskList", ListID: listID, Err: err}
        }</span>

        <span class="cov2" title="2">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "DeleteTaskList", ListID: listID, Err: err}
        }</span>
        <span class="cov2" title="2">if rowsAffected == 0 </span><span class="cov1" title="1">{
                return backend.NewBackendError("DeleteTaskList", 404, fmt.Sprintf("list %s not found", listID))
        }</span>

        <span class="cov1" title="1">return tx.Commit()</span>
}

// RenameTaskList renames a task list
func (sb *SQLiteBackend) RenameTaskList(listID, newName string) error <span class="cov2" title="2">{
        db, err := sb.GetDB()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "RenameTaskList", ListID: listID, Err: err}
        }</span>

        <span class="cov2" title="2">result, err := db.Exec(`
                UPDATE list_sync_metadata
                SET list_name = ?, modified_at = ?
                WHERE list_id = ?
        `, newName, time.Now().Unix(), listID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "RenameTaskList", ListID: listID, Err: err}
        }</span>

        <span class="cov2" title="2">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "RenameTaskList", ListID: listID, Err: err}
        }</span>
        <span class="cov2" title="2">if rowsAffected == 0 </span><span class="cov1" title="1">{
                return backend.NewBackendError("RenameTaskList", 404, fmt.Sprintf("list %s not found", listID))
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// GetDeletedTaskLists returns deleted task lists (not supported for SQLite yet)
func (sb *SQLiteBackend) GetDeletedTaskLists() ([]backend.TaskList, error) <span class="cov1" title="1">{
        // SQLite backend doesn't support trash yet
        return []backend.TaskList{}, nil
}</span>

// RestoreTaskList restores a deleted task list (not supported for SQLite yet)
func (sb *SQLiteBackend) RestoreTaskList(listID string) error <span class="cov1" title="1">{
        return fmt.Errorf("trash not supported for SQLite backend")
}</span>

// PermanentlyDeleteTaskList permanently deletes a task list (not supported for SQLite yet)
func (sb *SQLiteBackend) PermanentlyDeleteTaskList(listID string) error <span class="cov0" title="0">{
        return fmt.Errorf("trash not supported for SQLite backend")
}</span>

// ParseStatusFlag converts status abbreviations to backend status format
func (sb *SQLiteBackend) ParseStatusFlag(statusFlag string) (string, error) <span class="cov5" title="12">{
        // SQLite uses standard CalDAV status names
        flag := strings.ToUpper(statusFlag)

        switch flag </span>{
        case "T", "TODO", "NEEDS-ACTION":<span class="cov2" title="3">
                return "NEEDS-ACTION", nil</span>
        case "D", "DONE", "COMPLETED":<span class="cov2" title="3">
                return "COMPLETED", nil</span>
        case "P", "PROCESSING", "IN-PROCESS":<span class="cov2" title="3">
                return "IN-PROCESS", nil</span>
        case "C", "CANCELLED":<span class="cov2" title="2">
                return "CANCELLED", nil</span>
        default:<span class="cov1" title="1">
                return "", fmt.Errorf("invalid status flag: %s (valid: T/TODO, D/DONE, P/PROCESSING, C/CANCELLED)", statusFlag)</span>
        }
}

// StatusToDisplayName converts backend status to display name
func (sb *SQLiteBackend) StatusToDisplayName(backendStatus string) string <span class="cov3" title="4">{
        switch strings.ToUpper(backendStatus) </span>{
        case "NEEDS-ACTION":<span class="cov1" title="1">
                return "TODO"</span>
        case "COMPLETED":<span class="cov1" title="1">
                return "DONE"</span>
        case "IN-PROCESS":<span class="cov1" title="1">
                return "PROCESSING"</span>
        case "CANCELLED":<span class="cov1" title="1">
                return "CANCELLED"</span>
        default:<span class="cov0" title="0">
                return backendStatus</span>
        }
}

// SortTasks sorts tasks by priority (1=highest, 0=undefined goes last)
func (sb *SQLiteBackend) SortTasks(tasks []backend.Task) <span class="cov1" title="1">{
        // Use the same sorting as Nextcloud (priority-based)
        // This is already handled in GetTasks ORDER BY clause
        // But we implement it here for consistency
        for i := 0; i &lt; len(tasks)-1; i++ </span><span class="cov2" title="3">{
                for j := i + 1; j &lt; len(tasks); j++ </span><span class="cov4" title="6">{
                        // Priority 0 (undefined) goes last
                        if tasks[i].Priority == 0 &amp;&amp; tasks[j].Priority != 0 </span><span class="cov2" title="3">{
                                tasks[i], tasks[j] = tasks[j], tasks[i]
                        }</span> else<span class="cov2" title="3"> if tasks[i].Priority != 0 &amp;&amp; tasks[j].Priority != 0 &amp;&amp; tasks[i].Priority &gt; tasks[j].Priority </span><span class="cov1" title="1">{
                                tasks[i], tasks[j] = tasks[j], tasks[i]
                        }</span>
                }
        }
}

// GetPriorityColor returns ANSI color code for priority
func (sb *SQLiteBackend) GetPriorityColor(priority int) string <span class="cov4" title="6">{
        // Use same color scheme as Nextcloud
        if priority &gt;= 1 &amp;&amp; priority &lt;= 4 </span><span class="cov2" title="2">{
                return "\033[31m" // Red (high priority)
        }</span> else<span class="cov3" title="4"> if priority == 5 </span><span class="cov1" title="1">{
                return "\033[33m" // Yellow (medium priority)
        }</span> else<span class="cov2" title="3"> if priority &gt;= 6 &amp;&amp; priority &lt;= 9 </span><span class="cov2" title="2">{
                return "\033[34m" // Blue (low priority)
        }</span>
        <span class="cov1" title="1">return ""</span> // No color for priority 0 (undefined)
}

// GetBackendDisplayName returns a formatted string for display in task list headers
func (sb *SQLiteBackend) GetBackendDisplayName() string <span class="cov0" title="0">{
        dbPath := sb.Config.DBPath
        if dbPath == "" </span><span class="cov0" title="0">{
                dbPath, _ = getDatabasePath(sb.Config.DBPath)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("[sqlite:%s]", dbPath)</span>
}

// GetBackendType returns the backend type identifier
func (sb *SQLiteBackend) GetBackendType() string <span class="cov0" title="0">{
        return "sqlite"
}</span>

// GetBackendContext returns contextual details specific to the backend
func (sb *SQLiteBackend) GetBackendContext() string <span class="cov0" title="0">{
        dbPath := sb.Config.DBPath
        if dbPath == "" </span><span class="cov0" title="0">{
                dbPath, _ = getDatabasePath(sb.Config.DBPath)
        }</span>
        <span class="cov0" title="0">return dbPath</span>
}

// Sync-specific methods

// MarkLocallyModified marks a task as locally modified
func (sb *SQLiteBackend) MarkLocallyModified(taskUID string) error <span class="cov1" title="1">{
        db, err := sb.GetDB()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "MarkLocallyModified", TaskUID: taskUID, Err: err}
        }</span>

        <span class="cov1" title="1">_, err = db.Exec(`
                UPDATE sync_metadata
                SET locally_modified = 1, local_modified_at = ?
                WHERE task_uid = ?
        `, time.Now().Unix(), taskUID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "MarkLocallyModified", TaskUID: taskUID, Err: err}
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// MarkLocallyDeleted marks a task as locally deleted
func (sb *SQLiteBackend) MarkLocallyDeleted(taskUID string) error <span class="cov0" title="0">{
        db, err := sb.GetDB()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "MarkLocallyDeleted", TaskUID: taskUID, Err: err}
        }</span>

        <span class="cov0" title="0">_, err = db.Exec(`
                UPDATE sync_metadata
                SET locally_deleted = 1, local_modified_at = ?
                WHERE task_uid = ?
        `, time.Now().Unix(), taskUID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "MarkLocallyDeleted", TaskUID: taskUID, Err: err}
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetLocallyModifiedTasks retrieves tasks that have been modified locally
func (sb *SQLiteBackend) GetLocallyModifiedTasks() ([]backend.Task, error) <span class="cov2" title="3">{
        db, err := sb.GetDB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;SQLiteError{Op: "GetLocallyModifiedTasks", Err: err}
        }</span>

        <span class="cov2" title="3">query := `
                SELECT t.id, t.list_id, t.summary, t.description, t.status, t.priority,
                       t.created_at, t.modified_at, t.due_date, t.start_date, t.completed_at,
                       t.parent_uid, t.categories
                FROM tasks t
                INNER JOIN sync_metadata sm ON t.id = sm.task_uid
                WHERE sm.locally_modified = 1
                ORDER BY sm.local_modified_at ASC
        `

        rows, err := db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;SQLiteError{Op: "GetLocallyModifiedTasks", Err: err}
        }</span>
        <span class="cov2" title="3">defer func() </span><span class="cov2" title="3">{ _ = rows.Close() }</span>()

        <span class="cov2" title="3">tasks, err := sb.scanTasks(rows)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;SQLiteError{Op: "GetLocallyModifiedTasks", Err: err}
        }</span>

        <span class="cov2" title="3">return tasks, nil</span>
}

// SyncOperation represents a pending sync operation
type SyncOperation struct {
        ID         int
        TaskUID    string
        ListID     string
        Operation  string // "create", "update", "delete"
        CreatedAt  time.Time
        RetryCount int
        LastError  string
}

// GetPendingSyncOperations retrieves operations queued for sync
func (sb *SQLiteBackend) GetPendingSyncOperations() ([]SyncOperation, error) <span class="cov2" title="3">{
        db, err := sb.GetDB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;SQLiteError{Op: "GetPendingSyncOperations", Err: err}
        }</span>

        <span class="cov2" title="3">query := `
                SELECT id, task_uid, list_id, operation, created_at, retry_count, last_error
                FROM sync_queue
                ORDER BY created_at ASC
        `

        rows, err := db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;SQLiteError{Op: "GetPendingSyncOperations", Err: err}
        }</span>
        <span class="cov2" title="3">defer func() </span><span class="cov2" title="3">{ _ = rows.Close() }</span>()

        <span class="cov2" title="3">var operations []SyncOperation
        for rows.Next() </span><span class="cov2" title="2">{
                var op SyncOperation
                var createdAt int64
                var lastError sql.NullString

                err := rows.Scan(
                        &amp;op.ID,
                        &amp;op.TaskUID,
                        &amp;op.ListID,
                        &amp;op.Operation,
                        &amp;createdAt,
                        &amp;op.RetryCount,
                        &amp;lastError,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, &amp;SQLiteError{Op: "GetPendingSyncOperations", Err: err}
                }</span>

                <span class="cov2" title="2">op.CreatedAt = time.Unix(createdAt, 0)
                if lastError.Valid </span><span class="cov0" title="0">{
                        op.LastError = lastError.String
                }</span>

                <span class="cov2" title="2">operations = append(operations, op)</span>
        }

        <span class="cov2" title="3">return operations, rows.Err()</span>
}

// ClearSyncFlags clears locally_modified and locally_deleted flags for a task
// Note: This does NOT remove pending sync operations from the queue.
// Use ClearSyncFlagsAndQueue() if you need to remove queue entries as well.
func (sb *SQLiteBackend) ClearSyncFlags(taskUID string) error <span class="cov1" title="1">{
        db, err := sb.GetDB()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "ClearSyncFlags", TaskUID: taskUID, Err: err}
        }</span>

        <span class="cov1" title="1">_, err = db.Exec(`
                UPDATE sync_metadata
                SET locally_modified = 0, locally_deleted = 0
                WHERE task_uid = ?
        `, taskUID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "ClearSyncFlags", TaskUID: taskUID, Err: err}
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// ClearSyncFlagsAndQueue clears locally_modified and locally_deleted flags for a task
// and removes all pending sync operations from the queue.
// This should be called after successfully pushing all operations for a task.
func (sb *SQLiteBackend) ClearSyncFlagsAndQueue(taskUID string) error <span class="cov1" title="1">{
        db, err := sb.GetDB()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "ClearSyncFlagsAndQueue", TaskUID: taskUID, Err: err}
        }</span>

        // Start transaction to ensure both operations succeed or fail together
        <span class="cov1" title="1">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "ClearSyncFlagsAndQueue", TaskUID: taskUID, Err: err}
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{ _ = tx.Rollback() }</span>()

        // Get current task modified timestamp to update remote_modified_at
        <span class="cov1" title="1">var modifiedAt sql.NullInt64
        err = tx.QueryRow(`
                SELECT modified_at
                FROM tasks
                WHERE id = ?
        `, taskUID).Scan(&amp;modifiedAt)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "ClearSyncFlags", TaskUID: taskUID, Err: err}
        }</span>

        // Clear sync metadata flags and update remote_modified_at
        // This indicates the task is now in sync with remote at this timestamp
        <span class="cov1" title="1">_, err = tx.Exec(`
                UPDATE sync_metadata
                SET locally_modified = 0, locally_deleted = 0, remote_modified_at = ?
                WHERE task_uid = ?
        `, modifiedAt, taskUID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "ClearSyncFlagsAndQueue", TaskUID: taskUID, Err: err}
        }</span>

        // Remove all pending sync operations for this task
        <span class="cov1" title="1">_, err = tx.Exec(`
                DELETE FROM sync_queue
                WHERE task_uid = ?
        `, taskUID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "ClearSyncFlagsAndQueue", TaskUID: taskUID, Err: err}
        }</span>

        <span class="cov1" title="1">return tx.Commit()</span>
}

// UpdateSyncMetadata updates sync metadata for a task
func (sb *SQLiteBackend) UpdateSyncMetadata(taskUID, listID, etag string, remoteModifiedAt time.Time) error <span class="cov1" title="1">{
        db, err := sb.GetDB()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "UpdateSyncMetadata", TaskUID: taskUID, Err: err}
        }</span>

        <span class="cov1" title="1">now := time.Now().Unix()

        _, err = db.Exec(`
                INSERT INTO sync_metadata (
                        task_uid, list_id, remote_etag, last_synced_at,
                        remote_modified_at, locally_modified, locally_deleted
                ) VALUES (?, ?, ?, ?, ?, 0, 0)
                ON CONFLICT(task_uid) DO UPDATE SET
                        remote_etag = excluded.remote_etag,
                        last_synced_at = excluded.last_synced_at,
                        remote_modified_at = excluded.remote_modified_at
        `, taskUID, listID, etag, now, remoteModifiedAt.Unix())
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "UpdateSyncMetadata", TaskUID: taskUID, Err: err}
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// RemoveSyncOperation removes a sync operation from the queue
func (sb *SQLiteBackend) RemoveSyncOperation(taskUID, operation string) error <span class="cov1" title="1">{
        db, err := sb.GetDB()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "RemoveSyncOperation", TaskUID: taskUID, Err: err}
        }</span>

        <span class="cov1" title="1">_, err = db.Exec(`
                DELETE FROM sync_queue
                WHERE task_uid = ? AND operation = ?
        `, taskUID, operation)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SQLiteError{Op: "RemoveSyncOperation", TaskUID: taskUID, Err: err}
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// Helper functions

// generateUID generates a unique identifier for tasks/lists
func GenerateUID() string <span class="cov6" title="24">{
        return fmt.Sprintf("task-%d-%s", time.Now().Unix(), randomString(8))
}</span>

// randomString generates a random alphanumeric string
func randomString(length int) string <span class="cov6" title="24">{
        const charset = "abcdefghijklmnopqrstuvwxyz0123456789"
        b := make([]byte, length)
        for i := range b </span><span class="cov10" title="192">{
                b[i] = charset[time.Now().UnixNano()%int64(len(charset))]
        }</span>
        <span class="cov6" title="24">return string(b)</span>
}

// nullString converts string to sql.NullString
func NullString(s string) sql.NullString <span class="cov8" title="75">{
        if s == "" </span><span class="cov8" title="71">{
                return sql.NullString{Valid: false}
        }</span>
        <span class="cov3" title="4">return sql.NullString{String: s, Valid: true}</span>
}

// timeToNullInt64 converts *time.Time to sql.NullInt64
func TimeToNullInt64(t *time.Time) sql.NullInt64 <span class="cov8" title="75">{
        if t == nil </span><span class="cov8" title="71">{
                return sql.NullInt64{Valid: false}
        }</span>
        <span class="cov3" title="4">return sql.NullInt64{Int64: t.Unix(), Valid: true}</span>
}

// timeValueToNullInt64 converts time.Time (non-pointer) to sql.NullInt64
func TimeValueToNullInt64(t time.Time) sql.NullInt64 <span class="cov7" title="48">{
        if t.IsZero() </span><span class="cov0" title="0">{
                return sql.NullInt64{Valid: false}
        }</span>
        <span class="cov7" title="48">return sql.NullInt64{Int64: t.Unix(), Valid: true}</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package sqlite

import (
        "database/sql"
        "fmt"
        "os"
        "path/filepath"
        "time"

        _ "modernc.org/sqlite" // SQLite driver
)

// Database wraps sql.DB with helper methods for schema management
type Database struct {
        *sql.DB
        path string
}

// InitDatabase initializes the SQLite database with proper schema
// It creates the database at the XDG-compliant location and sets up all tables
func InitDatabase(customPath string) (*Database, error) <span class="cov7" title="46">{
        dbPath, err := getDatabasePath(customPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get database path: %w", err)
        }</span>

        // Ensure the directory exists
        <span class="cov7" title="46">dir := filepath.Dir(dbPath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create database directory: %w", err)
        }</span>

        // Open database connection
        <span class="cov7" title="46">db, err := sql.Open("sqlite", dbPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        <span class="cov7" title="46">database := &amp;Database{
                DB:   db,
                path: dbPath,
        }

        // Initialize schema
        if err := database.initializeSchema(); err != nil </span><span class="cov0" title="0">{
                _ = db.Close()
                return nil, fmt.Errorf("failed to initialize schema: %w", err)
        }</span>

        <span class="cov7" title="46">return database, nil</span>
}

// getDatabasePath returns the path to the SQLite database file
// Priority: customPath &gt; $XDG_DATA_HOME/gosynctasks/tasks.db &gt; ~/.local/share/gosynctasks/tasks.db
func getDatabasePath(customPath string) (string, error) <span class="cov7" title="48">{
        if customPath != "" </span><span class="cov7" title="47">{
                return customPath, nil
        }</span>

        // Try XDG_DATA_HOME
        <span class="cov1" title="1">if xdgDataHome := os.Getenv("XDG_DATA_HOME"); xdgDataHome != "" </span><span class="cov1" title="1">{
                return filepath.Join(xdgDataHome, "gosynctasks", "tasks.db"), nil
        }</span>

        // Fallback to ~/.local/share
        <span class="cov0" title="0">homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get user home directory: %w", err)
        }</span>

        <span class="cov0" title="0">return filepath.Join(homeDir, ".local", "share", "gosynctasks", "tasks.db"), nil</span>
}

// initializeSchema creates all tables, indexes, and sets pragmas
func (db *Database) initializeSchema() error <span class="cov7" title="46">{
        // Set pragmas first
        for _, pragma := range PragmaStatements() </span><span class="cov9" title="138">{
                if _, err := db.Exec(pragma); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to execute pragma %q: %w", pragma, err)
                }</span>
        }

        // Create all tables
        <span class="cov7" title="46">for _, schema := range AllTableSchemas() </span><span class="cov10" title="230">{
                if _, err := db.Exec(schema); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create table: %w", err)
                }</span>
        }

        // Create all indexes
        <span class="cov7" title="46">for _, index := range AllIndexes() </span><span class="cov9" title="138">{
                if _, err := db.Exec(index); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create index: %w", err)
                }</span>
        }

        // Record schema version
        <span class="cov7" title="46">if err := db.recordSchemaVersion(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to record schema version: %w", err)
        }</span>

        <span class="cov7" title="46">return nil</span>
}

// recordSchemaVersion records the current schema version in the database
func (db *Database) recordSchemaVersion() error <span class="cov7" title="46">{
        // Check if version already recorded
        var count int
        err := db.QueryRow("SELECT COUNT(*) FROM schema_version WHERE version = ?", SchemaVersion).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check schema version: %w", err)
        }</span>

        <span class="cov7" title="46">if count &gt; 0 </span><span class="cov0" title="0">{
                return nil // Version already recorded
        }</span>

        // Insert new version record
        <span class="cov7" title="46">_, err = db.Exec(
                "INSERT INTO schema_version (version, applied_at) VALUES (?, ?)",
                SchemaVersion,
                time.Now().Unix(),
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert schema version: %w", err)
        }</span>

        <span class="cov7" title="46">return nil</span>
}

// GetSchemaVersion returns the current schema version from the database
func (db *Database) GetSchemaVersion() (int, error) <span class="cov1" title="1">{
        var version int
        err := db.QueryRow("SELECT MAX(version) FROM schema_version").Scan(&amp;version)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get schema version: %w", err)
        }</span>
        <span class="cov1" title="1">return version, nil</span>
}

// Path returns the filesystem path to the database file
func (db *Database) Path() string <span class="cov1" title="1">{
        return db.path
}</span>

// Vacuum runs VACUUM to optimize the database
func (db *Database) Vacuum() error <span class="cov1" title="1">{
        _, err := db.Exec("VACUUM")
        return err
}</span>

// GetStats returns basic database statistics
func (db *Database) GetStats() (DatabaseStats, error) <span class="cov1" title="1">{
        stats := DatabaseStats{}

        // Count tasks
        err := db.QueryRow("SELECT COUNT(*) FROM tasks").Scan(&amp;stats.TaskCount)
        if err != nil </span><span class="cov0" title="0">{
                return stats, fmt.Errorf("failed to count tasks: %w", err)
        }</span>

        // Count lists
        <span class="cov1" title="1">err = db.QueryRow("SELECT COUNT(*) FROM list_sync_metadata").Scan(&amp;stats.ListCount)
        if err != nil </span><span class="cov0" title="0">{
                return stats, fmt.Errorf("failed to count lists: %w", err)
        }</span>

        // Count pending sync operations
        <span class="cov1" title="1">err = db.QueryRow("SELECT COUNT(*) FROM sync_queue").Scan(&amp;stats.PendingSyncOps)
        if err != nil </span><span class="cov0" title="0">{
                return stats, fmt.Errorf("failed to count pending sync operations: %w", err)
        }</span>

        // Count locally modified tasks
        <span class="cov1" title="1">err = db.QueryRow("SELECT COUNT(*) FROM sync_metadata WHERE locally_modified = 1").Scan(&amp;stats.LocallyModified)
        if err != nil </span><span class="cov0" title="0">{
                return stats, fmt.Errorf("failed to count locally modified tasks: %w", err)
        }</span>

        // Get database file size
        <span class="cov1" title="1">fileInfo, err := os.Stat(db.path)
        if err != nil </span><span class="cov0" title="0">{
                return stats, fmt.Errorf("failed to stat database file: %w", err)
        }</span>
        <span class="cov1" title="1">stats.DatabaseSize = fileInfo.Size()

        return stats, nil</span>
}

// DatabaseStats holds statistics about the database
type DatabaseStats struct {
        TaskCount       int
        ListCount       int
        PendingSyncOps  int
        LocallyModified int
        DatabaseSize    int64 // in bytes
}

// String returns a human-readable representation of database statistics
func (s DatabaseStats) String() string <span class="cov1" title="1">{
        sizeMB := float64(s.DatabaseSize) / (1024 * 1024)
        return fmt.Sprintf(
                "Tasks: %d | Lists: %d | Pending sync: %d | Modified: %d | Size: %.2f MB",
                s.TaskCount, s.ListCount, s.PendingSyncOps, s.LocallyModified, sizeMB,
        )
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package sqlite

// Schema version for migration management
const SchemaVersion = 1

// SQL statements for database schema creation

// TasksTableSQL creates the main tasks table following VTODO iCalendar format
const TasksTableSQL = `
CREATE TABLE IF NOT EXISTS tasks (
    id TEXT PRIMARY KEY,
    list_id TEXT NOT NULL,
    summary TEXT NOT NULL,
    description TEXT,
    status TEXT,
    priority INTEGER DEFAULT 0,
    created_at INTEGER,
    modified_at INTEGER,
    due_date INTEGER,
    start_date INTEGER,
    completed_at INTEGER,
    parent_uid TEXT,
    categories TEXT,

    FOREIGN KEY(parent_uid) REFERENCES tasks(id) ON DELETE SET NULL
);
`

// SyncMetadataTableSQL creates the sync metadata table for tracking sync state per task
const SyncMetadataTableSQL = `
CREATE TABLE IF NOT EXISTS sync_metadata (
    task_uid TEXT PRIMARY KEY,
    list_id TEXT NOT NULL,

    -- Server state tracking
    remote_etag TEXT,
    last_synced_at INTEGER,

    -- Local state flags
    locally_modified INTEGER DEFAULT 0,
    locally_deleted INTEGER DEFAULT 0,

    -- Conflict detection
    remote_modified_at INTEGER,
    local_modified_at INTEGER,

    FOREIGN KEY(task_uid) REFERENCES tasks(id) ON DELETE CASCADE
);
`

// ListSyncMetadataTableSQL creates the list sync metadata table for tracking sync state per list
const ListSyncMetadataTableSQL = `
CREATE TABLE IF NOT EXISTS list_sync_metadata (
    list_id TEXT PRIMARY KEY,
    list_name TEXT NOT NULL,
    list_color TEXT,

    -- Sync state tracking
    last_ctag TEXT,
    last_full_sync INTEGER,
    sync_token TEXT,

    -- List metadata
    created_at INTEGER,
    modified_at INTEGER
);
`

// SyncQueueTableSQL creates the sync queue table for operations to perform on next sync
const SyncQueueTableSQL = `
CREATE TABLE IF NOT EXISTS sync_queue (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    task_uid TEXT NOT NULL,
    list_id TEXT NOT NULL,
    operation TEXT NOT NULL CHECK(operation IN ('create', 'update', 'delete')),
    created_at INTEGER NOT NULL,
    retry_count INTEGER DEFAULT 0,
    last_error TEXT,

    -- Ensure we don't queue duplicate operations for the same task
    UNIQUE(task_uid, operation)
);
`

// SchemaVersionTableSQL creates the schema version table for migration tracking
const SchemaVersionTableSQL = `
CREATE TABLE IF NOT EXISTS schema_version (
    version INTEGER PRIMARY KEY,
    applied_at INTEGER NOT NULL
);
`

// Index creation statements for performance optimization

// TasksIndexesSQL creates indexes on tasks table for common queries
const TasksIndexesSQL = `
CREATE INDEX IF NOT EXISTS idx_tasks_list_id ON tasks(list_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON tasks(due_date);
CREATE INDEX IF NOT EXISTS idx_tasks_parent_uid ON tasks(parent_uid);
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);
`

// SyncMetadataIndexesSQL creates indexes on sync_metadata table
const SyncMetadataIndexesSQL = `
CREATE INDEX IF NOT EXISTS idx_sync_metadata_locally_modified ON sync_metadata(locally_modified);
CREATE INDEX IF NOT EXISTS idx_sync_metadata_locally_deleted ON sync_metadata(locally_deleted);
CREATE INDEX IF NOT EXISTS idx_sync_metadata_list_id ON sync_metadata(list_id);
`

// SyncQueueIndexesSQL creates indexes on sync_queue table
const SyncQueueIndexesSQL = `
CREATE INDEX IF NOT EXISTS idx_sync_queue_operation ON sync_queue(operation);
CREATE INDEX IF NOT EXISTS idx_sync_queue_created_at ON sync_queue(created_at);
CREATE INDEX IF NOT EXISTS idx_sync_queue_retry_count ON sync_queue(retry_count);
`

// AllTableSchemas returns all table creation statements in order
func AllTableSchemas() []string <span class="cov10" title="46">{
        return []string{
                SchemaVersionTableSQL,
                TasksTableSQL,
                SyncMetadataTableSQL,
                ListSyncMetadataTableSQL,
                SyncQueueTableSQL,
        }
}</span>

// AllIndexes returns all index creation statements
func AllIndexes() []string <span class="cov10" title="46">{
        return []string{
                TasksIndexesSQL,
                SyncMetadataIndexesSQL,
                SyncQueueIndexesSQL,
        }
}</span>

// PragmaStatements returns pragma statements to execute on database connection
func PragmaStatements() []string <span class="cov10" title="46">{
        return []string{
                "PRAGMA foreign_keys = ON",
                "PRAGMA journal_mode = WAL",   // Write-Ahead Logging for better concurrency
                "PRAGMA synchronous = NORMAL", // Balance between safety and performance
        }
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package sync

import (
        "gosynctasks/backend"
        "gosynctasks/backend/sqlite"
        "database/sql"
        "fmt"
        "strings"
        "time"
)

// ConflictResolutionStrategy defines how to handle sync conflicts
type ConflictResolutionStrategy string

const (
        ServerWins ConflictResolutionStrategy = "server_wins" // Discard local changes, use server version
        LocalWins  ConflictResolutionStrategy = "local_wins"  // Overwrite server with local version
        Merge      ConflictResolutionStrategy = "merge"       // Combine non-conflicting fields
        KeepBoth   ConflictResolutionStrategy = "keep_both"   // Create duplicate with suffix
)

// SyncManager coordinates synchronization between local SQLite and remote backend
type SyncManager struct {
        local    *sqlite.SQLiteBackend
        remote   backend.TaskManager
        strategy ConflictResolutionStrategy
}

// NewSyncManager creates a new sync manager
func NewSyncManager(local *sqlite.SQLiteBackend, remote backend.TaskManager, strategy ConflictResolutionStrategy) *SyncManager <span class="cov10" title="14">{
        return &amp;SyncManager{
                local:    local,
                remote:   remote,
                strategy: strategy,
        }
}</span>

// SyncResult contains statistics about the sync operation
type SyncResult struct {
        PulledTasks       int
        PushedTasks       int
        ConflictsFound    int
        ConflictsResolved int
        Errors            []error
        Duration          time.Duration
}

// Sync performs bidirectional synchronization
func (sm *SyncManager) Sync() (*SyncResult, error) <span class="cov10" title="14">{
        startTime := time.Now()
        result := &amp;SyncResult{}

        // Phase 1: Pull remote changes
        pullResult, err := sm.pull()
        if err != nil </span><span class="cov0" title="0">{
                result.Errors = append(result.Errors, fmt.Errorf("pull phase failed: %w", err))
                // Continue to push phase even if pull fails
        }</span> else<span class="cov10" title="14"> {
                result.PulledTasks = pullResult.PulledTasks
                result.ConflictsFound = pullResult.ConflictsFound
                result.ConflictsResolved = pullResult.ConflictsResolved
        }</span>

        // Phase 2: Push local changes
        <span class="cov10" title="14">pushResult, err := sm.push()
        if err != nil </span><span class="cov0" title="0">{
                result.Errors = append(result.Errors, fmt.Errorf("push phase failed: %w", err))
        }</span> else<span class="cov10" title="14"> {
                result.PushedTasks = pushResult.PushedTasks
        }</span>

        <span class="cov10" title="14">result.Duration = time.Since(startTime)
        return result, nil</span>
}

// pullResult contains statistics from the pull phase
type pullResult struct {
        PulledTasks       int
        ConflictsFound    int
        ConflictsResolved int
}

// pull retrieves remote changes and applies them locally
func (sm *SyncManager) pull() (*pullResult, error) <span class="cov10" title="14">{
        result := &amp;pullResult{}

        // Get all remote task lists
        remoteLists, err := sm.remote.GetTaskLists()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get remote lists: %w", err)
        }</span>

        // Sync each list
        <span class="cov10" title="14">for _, remoteList := range remoteLists </span><span class="cov9" title="13">{
                // Check if list exists locally
                localLists, err := sm.local.GetTaskLists()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get local lists: %w", err)
                }</span>

                // Find or create list locally
                <span class="cov9" title="13">listExists := false
                var localCTag string
                for _, localList := range localLists </span><span class="cov8" title="10">{
                        if localList.ID == remoteList.ID </span><span class="cov8" title="10">{
                                listExists = true
                                localCTag = localList.CTags
                                break</span>
                        }
                }

                // Check if list changed (CTag comparison)
                <span class="cov9" title="13">if listExists &amp;&amp; localCTag == remoteList.CTags </span><span class="cov1" title="1">{
                        // No changes, skip this list
                        continue</span>
                }

                // Create list if it doesn't exist
                <span class="cov9" title="12">if !listExists </span><span class="cov4" title="3">{
                        // Insert list metadata
                        db, err := sm.local.GetDB()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov4" title="3">now := time.Now().Unix()
                        _, err = db.Exec(`
                                INSERT INTO list_sync_metadata (list_id, list_name, list_color, last_ctag, last_full_sync, created_at, modified_at)
                                VALUES (?, ?, ?, ?, ?, ?, ?)
                        `, remoteList.ID, remoteList.Name, remoteList.Color, remoteList.CTags, now, now, now)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to create local list: %w", err)
                        }</span>
                } else<span class="cov8" title="9"> {
                        // Update list CTag
                        db, err := sm.local.GetDB()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="9">_, err = db.Exec(`
                                UPDATE list_sync_metadata
                                SET last_ctag = ?, last_full_sync = ?
                                WHERE list_id = ?
                        `, remoteList.CTags, time.Now().Unix(), remoteList.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to update list CTag: %w", err)
                        }</span>
                }

                // Get all remote tasks for this list
                <span class="cov9" title="12">remoteTasks, err := sm.remote.GetTasks(remoteList.ID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get remote tasks for list %s: %w", remoteList.ID, err)
                }</span>

                // Sort remote tasks so parents come before children (important for foreign key constraints)
                <span class="cov9" title="12">remoteTasks = sortTasksByHierarchy(remoteTasks)

                // Get all local tasks for this list
                localTasks, err := sm.local.GetTasks(remoteList.ID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get local tasks for list %s: %w", remoteList.ID, err)
                }</span>

                // Create map of local tasks for quick lookup
                <span class="cov9" title="12">localTaskMap := make(map[string]*backend.Task)
                for i := range localTasks </span><span class="cov8" title="8">{
                        localTaskMap[localTasks[i].UID] = &amp;localTasks[i]
                }</span>

                // Process each remote task
                <span class="cov9" title="12">for _, remoteTask := range remoteTasks </span><span class="cov9" title="12">{
                        localTask, exists := localTaskMap[remoteTask.UID]

                        if !exists </span><span class="cov7" title="6">{
                                // New remote task - insert locally
                                err := sm.insertTaskLocally(remoteList.ID, remoteTask)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("failed to insert task %s: %w", remoteTask.UID, err)
                                }</span>
                                <span class="cov7" title="6">result.PulledTasks++</span>
                        } else<span class="cov7" title="6"> {
                                // backend.Task exists locally - check for conflict
                                isLocallyModified, err := sm.isTaskLocallyModified(remoteTask.UID)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>

                                <span class="cov7" title="6">isRemoteModified, err := sm.isTaskRemoteModified(remoteTask)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>

                                <span class="cov7" title="6">if isLocallyModified &amp;&amp; isRemoteModified </span><span class="cov4" title="3">{
                                        // Both modified - real conflict
                                        result.ConflictsFound++
                                        err := sm.resolveConflict(remoteList.ID, *localTask, remoteTask)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("failed to resolve conflict for task %s: %w", remoteTask.UID, err)
                                        }</span>
                                        <span class="cov4" title="3">result.ConflictsResolved++</span>
                                } else<span class="cov4" title="3"> if isLocallyModified </span>{<span class="cov1" title="1">
                                        // Only local modified - will be pushed in push phase, don't update local
                                        // Do nothing here, let push phase handle it
                                }</span> else<span class="cov3" title="2"> {
                                        // Remote modified or neither modified - update local with remote
                                        err := sm.updateTaskLocally(remoteList.ID, remoteTask)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("failed to update task %s: %w", remoteTask.UID, err)
                                        }</span>
                                        <span class="cov3" title="2">result.PulledTasks++</span>
                                }
                        }

                        // Remove from map (for deletion detection)
                        <span class="cov9" title="12">delete(localTaskMap, remoteTask.UID)</span>
                }

                // Remaining tasks in map were deleted remotely
                <span class="cov9" title="12">for _, deletedTask := range localTaskMap </span><span class="cov3" title="2">{
                        isLocallyModified, err := sm.isTaskLocallyModified(deletedTask.UID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov3" title="2">if !isLocallyModified </span><span class="cov0" title="0">{
                                // Delete locally
                                err := sm.deleteTaskLocally(remoteList.ID, deletedTask.UID)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("failed to delete task %s: %w", deletedTask.UID, err)
                                }</span>
                        }
                        // If locally modified, keep it (will be pushed in push phase)
                }
        }

        <span class="cov10" title="14">return result, nil</span>
}

// pushResult contains statistics from the push phase
type pushResult struct {
        PushedTasks int
}

// push sends local changes to remote backend
func (sm *SyncManager) push() (*pushResult, error) <span class="cov10" title="14">{
        result := &amp;pushResult{}

        // Get pending sync operations
        operations, err := sm.local.GetPendingSyncOperations()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get pending operations: %w", err)
        }</span>

        // Process each operation
        <span class="cov10" title="14">for _, op := range operations </span><span class="cov8" title="9">{
                // Skip if too many retries
                if op.RetryCount &gt;= 5 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="9">var pushErr error

                switch op.Operation </span>{
                case "create":<span class="cov7" title="6">
                        pushErr = sm.pushCreate(op)</span>
                case "update":<span class="cov3" title="2">
                        pushErr = sm.pushUpdate(op)</span>
                case "delete":<span class="cov1" title="1">
                        pushErr = sm.pushDelete(op)</span>
                default:<span class="cov0" title="0">
                        pushErr = fmt.Errorf("unknown operation: %s", op.Operation)</span>
                }

                <span class="cov8" title="9">if pushErr != nil </span><span class="cov1" title="1">{
                        // Increment retry count
                        db, err := sm.local.GetDB()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov1" title="1">_, err = db.Exec(`
                                UPDATE sync_queue
                                SET retry_count = retry_count + 1, last_error = ?
                                WHERE id = ?
                        `, pushErr.Error(), op.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to update retry count: %w", err)
                        }</span>

                        // Apply exponential backoff
                        <span class="cov1" title="1">backoffSeconds := 1 &lt;&lt; op.RetryCount // 2^retryCount
                        if backoffSeconds &gt; 300 </span><span class="cov0" title="0">{
                                backoffSeconds = 300 // Max 5 minutes
                        }</span>
                        <span class="cov1" title="1">time.Sleep(time.Duration(backoffSeconds) * time.Second)</span>
                } else<span class="cov8" title="8"> {
                        // Success - remove from queue and clear flags
                        err := sm.local.ClearSyncFlagsAndQueue(op.TaskUID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to clear sync flags and queue: %w", err)
                        }</span>

                        <span class="cov8" title="8">result.PushedTasks++</span>
                }
        }

        <span class="cov10" title="14">return result, nil</span>
}

// pushCreate pushes a create operation to remote
func (sm *SyncManager) pushCreate(op sqlite.SyncOperation) error <span class="cov7" title="6">{
        // Get task from local
        tasks, err := sm.local.GetTasks(op.ListID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="6">var task *backend.Task
        for i := range tasks </span><span class="cov7" title="7">{
                if tasks[i].UID == op.TaskUID </span><span class="cov7" title="6">{
                        task = &amp;tasks[i]
                        break</span>
                }
        }

        <span class="cov7" title="6">if task == nil </span><span class="cov0" title="0">{
                // backend.Task was deleted locally, remove from queue
                return nil
        }</span>

        // Add to remote
        <span class="cov7" title="6">err = sm.remote.AddTask(op.ListID, *task)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to create task on remote: %w", err)
        }</span>

        <span class="cov6" title="5">return nil</span>
}

// pushUpdate pushes an update operation to remote
func (sm *SyncManager) pushUpdate(op sqlite.SyncOperation) error <span class="cov3" title="2">{
        // Get task from local
        tasks, err := sm.local.GetTasks(op.ListID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">var task *backend.Task
        for i := range tasks </span><span class="cov3" title="2">{
                if tasks[i].UID == op.TaskUID </span><span class="cov3" title="2">{
                        task = &amp;tasks[i]
                        break</span>
                }
        }

        <span class="cov3" title="2">if task == nil </span><span class="cov0" title="0">{
                // backend.Task was deleted locally, remove from queue
                return nil
        }</span>

        // Update on remote
        <span class="cov3" title="2">err = sm.remote.UpdateTask(op.ListID, *task)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update task on remote: %w", err)
        }</span>

        <span class="cov3" title="2">return nil</span>
}

// pushDelete pushes a delete operation to remote
func (sm *SyncManager) pushDelete(op sqlite.SyncOperation) error <span class="cov1" title="1">{
        err := sm.remote.DeleteTask(op.ListID, op.TaskUID)
        if err != nil </span><span class="cov0" title="0">{
                // If task doesn't exist on remote, that's ok
                if backendErr, ok := err.(*backend.BackendError); ok &amp;&amp; backendErr.IsNotFound() </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to delete task on remote: %w", err)</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// isTaskLocallyModified checks if a task is locally modified
func (sm *SyncManager) isTaskLocallyModified(taskUID string) (bool, error) <span class="cov8" title="8">{
        db, err := sm.local.GetDB()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="8">var locallyModified int
        err = db.QueryRow(`
                SELECT COALESCE(locally_modified, 0)
                FROM sync_metadata
                WHERE task_uid = ?
        `, taskUID).Scan(&amp;locallyModified)
        if err != nil </span><span class="cov0" title="0">{
                // If no sync metadata, treat as not modified
                return false, nil
        }</span>

        <span class="cov8" title="8">return locallyModified == 1, nil</span>
}

// isTaskRemoteModified checks if a remote task has been modified since last sync
func (sm *SyncManager) isTaskRemoteModified(remoteTask backend.Task) (bool, error) <span class="cov7" title="6">{
        db, err := sm.local.GetDB()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov7" title="6">var remoteModifiedAt sql.NullInt64
        err = db.QueryRow(`
                SELECT remote_modified_at
                FROM sync_metadata
                WHERE task_uid = ?
        `, remoteTask.UID).Scan(&amp;remoteModifiedAt)
        if err != nil </span><span class="cov0" title="0">{
                // If no sync metadata exists, treat as modified (new from our perspective)
                return true, nil
        }</span>

        // If we don't have a remote modified timestamp, treat as modified
        <span class="cov7" title="6">if !remoteModifiedAt.Valid </span><span class="cov4" title="3">{
                return true, nil
        }</span>

        // Compare remote task's Modified timestamp with stored remote_modified_at
        // Truncate to second precision since we store timestamps as Unix seconds
        <span class="cov4" title="3">lastRemoteModified := time.Unix(remoteModifiedAt.Int64, 0)
        currentRemoteModified := time.Unix(remoteTask.Modified.Unix(), 0)

        // If remote task's Modified is newer than our stored timestamp, it's been modified
        if !remoteTask.Modified.IsZero() &amp;&amp; currentRemoteModified.After(lastRemoteModified) </span><span class="cov1" title="1">{
                return true, nil
        }</span>

        <span class="cov3" title="2">return false, nil</span>
}

// resolveConflict resolves a conflict between local and remote versions
func (sm *SyncManager) resolveConflict(listID string, localTask, remoteTask backend.Task) error <span class="cov4" title="3">{
        switch sm.strategy </span>{
        case ServerWins:<span class="cov1" title="1">
                return sm.resolveServerWins(listID, localTask, remoteTask)</span>
        case LocalWins:<span class="cov1" title="1">
                return sm.resolveLocalWins(listID, localTask, remoteTask)</span>
        case Merge:<span class="cov0" title="0">
                return sm.resolveMerge(listID, localTask, remoteTask)</span>
        case KeepBoth:<span class="cov1" title="1">
                return sm.resolveKeepBoth(listID, localTask, remoteTask)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown conflict resolution strategy: %s", sm.strategy)</span>
        }
}

// resolveServerWins discards local changes and uses server version
func (sm *SyncManager) resolveServerWins(listID string, localTask, remoteTask backend.Task) error <span class="cov1" title="1">{
        // Update local with remote version
        err := sm.updateTaskLocally(listID, remoteTask)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Clear locally modified flag AND remove pending operations
        // Server wins means we discard local changes and don't push them
        <span class="cov1" title="1">return sm.local.ClearSyncFlagsAndQueue(remoteTask.UID)</span>
}

// resolveLocalWins keeps local changes for push to server
func (sm *SyncManager) resolveLocalWins(listID string, localTask, remoteTask backend.Task) error <span class="cov1" title="1">{
        // Keep local version, mark for push
        // Local task already has locally_modified=1, so it will be pushed
        // Just update sync metadata with remote info
        if !remoteTask.Modified.IsZero() </span><span class="cov1" title="1">{
                return sm.local.UpdateSyncMetadata(localTask.UID, listID, "", remoteTask.Modified)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// resolveMerge intelligently merges local and remote changes
func (sm *SyncManager) resolveMerge(listID string, localTask, remoteTask backend.Task) error <span class="cov0" title="0">{
        mergedTask := remoteTask // Start with remote as base

        // Preserve local description if remote hasn't changed
        if localTask.Description != "" &amp;&amp; remoteTask.Description == "" </span><span class="cov0" title="0">{
                mergedTask.Description = localTask.Description
        }</span>

        // Use higher priority
        <span class="cov0" title="0">if localTask.Priority &gt; 0 &amp;&amp; localTask.Priority &lt; remoteTask.Priority </span><span class="cov0" title="0">{
                mergedTask.Priority = localTask.Priority
        }</span>

        // Union categories
        <span class="cov0" title="0">categorySet := make(map[string]bool)
        for _, cat := range remoteTask.Categories </span><span class="cov0" title="0">{
                categorySet[cat] = true
        }</span>
        <span class="cov0" title="0">for _, cat := range localTask.Categories </span><span class="cov0" title="0">{
                categorySet[cat] = true
        }</span>
        <span class="cov0" title="0">mergedTask.Categories = make([]string, 0, len(categorySet))
        for cat := range categorySet </span><span class="cov0" title="0">{
                mergedTask.Categories = append(mergedTask.Categories, cat)
        }</span>

        // Use most recent timestamps
        <span class="cov0" title="0">if localTask.DueDate != nil &amp;&amp; (remoteTask.DueDate == nil || localTask.DueDate.After(*remoteTask.DueDate)) </span><span class="cov0" title="0">{
                mergedTask.DueDate = localTask.DueDate
        }</span>

        // Update locally with merged version
        <span class="cov0" title="0">err := sm.updateTaskLocally(listID, mergedTask)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Mark for push to propagate merge
        <span class="cov0" title="0">return sm.local.MarkLocallyModified(mergedTask.UID)</span>
}

// resolveKeepBoth creates a copy of the local version
func (sm *SyncManager) resolveKeepBoth(listID string, localTask, remoteTask backend.Task) error <span class="cov1" title="1">{
        // Update local task with remote version
        err := sm.updateTaskLocally(listID, remoteTask)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create a copy of the local version with new UID
        <span class="cov1" title="1">localCopy := localTask
        localCopy.UID = sqlite.GenerateUID()
        localCopy.Summary = localTask.Summary + " (local copy)"

        // Insert the copy
        err = sm.local.AddTask(listID, localCopy)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Clear original task's sync flags AND remove pending operations
        // We're accepting the remote version for the original, local copy is separate
        <span class="cov1" title="1">return sm.local.ClearSyncFlagsAndQueue(remoteTask.UID)</span>
}

// insertTaskLocally inserts a remote task into local storage
func (sm *SyncManager) insertTaskLocally(listID string, task backend.Task) error <span class="cov7" title="6">{
        db, err := sm.local.GetDB()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="6">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov7" title="6">defer func() </span><span class="cov7" title="6">{ _ = tx.Rollback() }</span>()

        // Insert task
        <span class="cov7" title="6">_, err = tx.Exec(`
                INSERT INTO tasks (
                        id, list_id, summary, description, status, priority,
                        created_at, modified_at, due_date, start_date, completed_at,
                        parent_uid, categories
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `,
                task.UID,
                listID,
                task.Summary,
                sqlite.NullString(task.Description),
                task.Status,
                task.Priority,
                sqlite.TimeValueToNullInt64(task.Created),
                sqlite.TimeValueToNullInt64(task.Modified),
                sqlite.TimeToNullInt64(task.DueDate),
                sqlite.TimeToNullInt64(task.StartDate),
                sqlite.TimeToNullInt64(task.Completed),
                sqlite.NullString(task.ParentUID),
                sqlite.NullString(strings.Join(task.Categories, ",")),
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Insert sync metadata (not locally modified since it came from server)
        <span class="cov7" title="6">now := time.Now().Unix()
        remoteModifiedAt := int64(0)
        if !task.Modified.IsZero() </span><span class="cov7" title="6">{
                remoteModifiedAt = task.Modified.Unix()
        }</span>

        <span class="cov7" title="6">_, err = tx.Exec(`
                INSERT INTO sync_metadata (
                        task_uid, list_id, last_synced_at, remote_modified_at,
                        locally_modified, locally_deleted
                ) VALUES (?, ?, ?, ?, 0, 0)
        `, task.UID, listID, now, remoteModifiedAt)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="6">return tx.Commit()</span>
}

// updateTaskLocally updates a local task with remote data
func (sm *SyncManager) updateTaskLocally(listID string, task backend.Task) error <span class="cov5" title="4">{
        db, err := sm.local.GetDB()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="4">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="4">defer func() </span><span class="cov5" title="4">{ _ = tx.Rollback() }</span>()

        // Update task
        <span class="cov5" title="4">_, err = tx.Exec(`
                UPDATE tasks
                SET summary = ?, description = ?, status = ?, priority = ?,
                    modified_at = ?, due_date = ?, start_date = ?, completed_at = ?,
                    parent_uid = ?, categories = ?
                WHERE id = ? AND list_id = ?
        `,
                task.Summary,
                sqlite.NullString(task.Description),
                task.Status,
                task.Priority,
                sqlite.TimeValueToNullInt64(task.Modified),
                sqlite.TimeToNullInt64(task.DueDate),
                sqlite.TimeToNullInt64(task.StartDate),
                sqlite.TimeToNullInt64(task.Completed),
                sqlite.NullString(task.ParentUID),
                sqlite.NullString(strings.Join(task.Categories, ",")),
                task.UID,
                listID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update sync metadata
        <span class="cov5" title="4">now := time.Now().Unix()
        remoteModifiedAt := int64(0)
        if !task.Modified.IsZero() </span><span class="cov5" title="4">{
                remoteModifiedAt = task.Modified.Unix()
        }</span>

        <span class="cov5" title="4">_, err = tx.Exec(`
                UPDATE sync_metadata
                SET last_synced_at = ?, remote_modified_at = ?, locally_modified = 0, locally_deleted = 0
                WHERE task_uid = ?
        `, now, remoteModifiedAt, task.UID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="4">return tx.Commit()</span>
}

// deleteTaskLocally deletes a task from local storage
func (sm *SyncManager) deleteTaskLocally(listID string, taskUID string) error <span class="cov0" title="0">{
        db, err := sm.local.GetDB()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Delete task (cascade will delete sync_metadata)
        <span class="cov0" title="0">_, err = db.Exec("DELETE FROM tasks WHERE id = ? AND list_id = ?", taskUID, listID)
        return err</span>
}

// FullSync performs a complete synchronization, ignoring CTags
func (sm *SyncManager) FullSync() (*SyncResult, error) <span class="cov1" title="1">{
        // Clear all CTags to force full sync
        db, err := sm.local.GetDB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">_, err = db.Exec("UPDATE list_sync_metadata SET last_ctag = ''")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to clear CTags: %w", err)
        }</span>

        <span class="cov1" title="1">return sm.Sync()</span>
}

// GetSyncStats returns current sync statistics
func (sm *SyncManager) GetSyncStats() (*SyncStats, error) <span class="cov1" title="1">{
        db, err := sm.local.GetDB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">stats, err := db.GetStats()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return &amp;SyncStats{
                LocalTasks:        stats.TaskCount,
                LocalLists:        stats.ListCount,
                PendingOperations: stats.PendingSyncOps,
                LocallyModified:   stats.LocallyModified,
        }, nil</span>
}

// SyncStats contains sync-related statistics
type SyncStats struct {
        LocalTasks        int
        LocalLists        int
        PendingOperations int
        LocallyModified   int
}

// sortTasksByHierarchy sorts tasks so parent tasks come before child tasks.
// This is critical for respecting foreign key constraints during sync.
func sortTasksByHierarchy(tasks []backend.Task) []backend.Task <span class="cov9" title="12">{
        // Build parent-child relationships
        childrenMap := make(map[string][]int) // parentUID -&gt; child indexes
        rootIndexes := []int{}                // tasks with no parent

        for i, task := range tasks </span><span class="cov9" title="12">{
                if task.ParentUID == "" </span><span class="cov9" title="12">{
                        rootIndexes = append(rootIndexes, i)
                }</span> else<span class="cov0" title="0"> {
                        childrenMap[task.ParentUID] = append(childrenMap[task.ParentUID], i)
                }</span>
        }

        // Traverse hierarchy depth-first, collecting tasks in order
        <span class="cov9" title="12">sorted := []backend.Task{}
        visited := make(map[int]bool)

        var visit func(index int)
        visit = func(index int) </span><span class="cov9" title="12">{
                if visited[index] </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov9" title="12">visited[index] = true
                sorted = append(sorted, tasks[index])

                // Visit children
                taskUID := tasks[index].UID
                for _, childIndex := range childrenMap[taskUID] </span><span class="cov0" title="0">{
                        visit(childIndex)
                }</span>
        }

        // Visit all root tasks (and their descendants)
        <span class="cov9" title="12">for _, rootIndex := range rootIndexes </span><span class="cov9" title="12">{
                visit(rootIndex)
        }</span>

        // Add any orphaned tasks (tasks with parent_uid pointing to non-existent parents)
        <span class="cov9" title="12">for i := range tasks </span><span class="cov9" title="12">{
                if !visited[i] </span><span class="cov0" title="0">{
                        sorted = append(sorted, tasks[i])
                }</span>
        }

        <span class="cov9" title="12">return sorted</span>
}

// PushOnly executes only the push phase of sync (no pull)
// This is useful for background sync after write operations
func (sm *SyncManager) PushOnly() (*SyncResult, error) <span class="cov0" title="0">{
        startTime := time.Now()
        result := &amp;SyncResult{}

        // Only push local changes
        pushResult, err := sm.push()
        if err != nil </span><span class="cov0" title="0">{
                result.Errors = append(result.Errors, fmt.Errorf("push phase failed: %w", err))
        }</span> else<span class="cov0" title="0"> {
                result.PushedTasks = pushResult.PushedTasks
        }</span>

        <span class="cov0" title="0">result.Duration = time.Since(startTime)
        return result, nil</span>
}

// GetRemote returns the remote backend.TaskManager
func (sm *SyncManager) GetRemote() backend.TaskManager <span class="cov0" title="0">{
        return sm.remote
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package backend

import (
        "fmt"
        "net/url"
        "strings"
        "time"

        "gopkg.in/yaml.v3"
)

type UnsupportedSchemeError struct {
        Scheme string
}

func (e *UnsupportedSchemeError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("unsupported scheme: %q", e.Scheme)
}</span>

// Base config struct (deprecated - use BackendConfig for new configurations)
type ConnectorConfig struct {
        URL                 *url.URL `yaml:"url"`
        InsecureSkipVerify  bool     `yaml:"insecure_skip_verify,omitempty"`  // WARNING: Only use for self-signed certificates in dev
        SuppressSSLWarning  bool     `yaml:"suppress_ssl_warning,omitempty"`  // Suppress SSL warning when InsecureSkipVerify is true
        AllowHTTP           bool     `yaml:"allow_http,omitempty"`            // Allow HTTP connections (insecure, only for testing)
        SuppressHTTPWarning bool     `yaml:"suppress_http_warning,omitempty"` // Suppress HTTP warning when AllowHTTP is true
        // Type     string `yaml:"type" validate:"required,oneof=nextcloud local"`
        //  Timeout  int    `yaml:"timeout,omitempty"`
}

// BackendConfig represents configuration for a single backend in the multi-backend system.
// Each backend has a type (nextcloud, git, file, sqlite, todoist) and type-specific configuration.
type BackendConfig struct {
        Name                string   `yaml:"-"`                               // Backend name (set during config loading from map key)
        Type                string   `yaml:"type" validate:"required,oneof=nextcloud git file sqlite todoist"`
        Enabled             bool     `yaml:"enabled"`
        URL                 string   `yaml:"url,omitempty"`                   // Used by: nextcloud, file
        Host                string   `yaml:"host,omitempty"`                  // Alternative to URL (used with credentials from keyring/env)
        Username            string   `yaml:"username,omitempty"`              // Username hint for keyring/env credential lookup
        InsecureSkipVerify  bool     `yaml:"insecure_skip_verify,omitempty"`  // Used by: nextcloud
        SuppressSSLWarning  bool     `yaml:"suppress_ssl_warning,omitempty"`  // Used by: nextcloud
        AllowHTTP           bool     `yaml:"allow_http,omitempty"`            // Used by: nextcloud (allow insecure HTTP)
        SuppressHTTPWarning bool     `yaml:"suppress_http_warning,omitempty"` // Used by: nextcloud (suppress HTTP warning)
        File                string   `yaml:"file,omitempty"`                  // Used by: git (default: "TODO.md")
        AutoDetect          bool     `yaml:"auto_detect,omitempty"`           // Used by: git
        FallbackFiles       []string `yaml:"fallback_files,omitempty"`        // Used by: git
        AutoCommit          bool     `yaml:"auto_commit,omitempty"`           // Used by: git
        DBPath              string   `yaml:"db_path,omitempty"`               // Used by: sqlite
        APIToken            string   `yaml:"api_token,omitempty"`             // Used by: todoist (can also be stored in keyring)
}

func (c *ConnectorConfig) UnmarshalYAML(value *yaml.Node) error <span class="cov0" title="0">{
        type ConnConfig ConnectorConfig

        tmp := struct {
                *ConnConfig
                URL                 string `yaml:"url"`
                InsecureSkipVerify  bool   `yaml:"insecure_skip_verify,omitempty"`
                SuppressSSLWarning  bool   `yaml:"suppress_ssl_warning,omitempty"`
                AllowHTTP           bool   `yaml:"allow_http,omitempty"`
                SuppressHTTPWarning bool   `yaml:"suppress_http_warning,omitempty"`
        }{
                ConnConfig: (*ConnConfig)(c),
        }

        if err := value.Decode(&amp;tmp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">u, err := url.Parse(tmp.URL)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">tmp.ConnConfig.URL = u
        tmp.ConnConfig.InsecureSkipVerify = tmp.InsecureSkipVerify
        tmp.ConnConfig.SuppressSSLWarning = tmp.SuppressSSLWarning
        tmp.ConnConfig.AllowHTTP = tmp.AllowHTTP

        return nil</span>
}

func (c *ConnectorConfig) TaskManager() (TaskManager, error) <span class="cov0" title="0">{
        constructor, err := GetSchemeConstructor(c.URL.Scheme)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;UnsupportedSchemeError{
                        Scheme: c.URL.Scheme,
                }
        }</span>
        <span class="cov0" title="0">return constructor(*c)</span>
}

// TaskManager creates a TaskManager instance from BackendConfig.
// This is the new multi-backend approach for creating task managers.
func (bc *BackendConfig) TaskManager() (TaskManager, error) <span class="cov1" title="1">{
        if !bc.Enabled </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("backend is disabled")
        }</span>

        <span class="cov1" title="1">constructor, err := GetTypeConstructor(bc.Type)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;UnsupportedSchemeError{
                        Scheme: bc.Type,
                }
        }</span>

        <span class="cov1" title="1">return constructor(*bc)</span>
}

// TaskManager defines the interface for task management backends.
// Each backend (Nextcloud, File, SQLite, etc.) implements this interface
// to provide task operations with backend-specific behavior.
//
// Implementations must be safe for concurrent use if accessed from multiple goroutines.
type TaskManager interface {
        // GetTaskLists retrieves all available task lists from the backend.
        // Returns an error if the backend is unreachable or authentication fails.
        GetTaskLists() ([]TaskList, error)

        // GetTasks retrieves tasks from a specific list, optionally filtered by the provided TaskFilter.
        // The listID parameter identifies the task list to query.
        // If taskFilter is nil, all tasks are returned.
        GetTasks(listID string, taskFilter *TaskFilter) ([]Task, error)

        // FindTasksBySummary searches for tasks by summary text (case-insensitive).
        // Returns all tasks with summaries that contain the search string (exact and partial matches).
        // This is used for interactive task selection in update/delete operations.
        FindTasksBySummary(listID string, summary string) ([]Task, error)

        // AddTask creates a new task in the specified list.
        // The task.UID may be generated by the backend if not provided.
        // Returns an error if the task cannot be created.
        AddTask(listID string, task Task) error

        // UpdateTask modifies an existing task identified by task.UID.
        // All task fields will be updated to match the provided task.
        // Returns an error if the task doesn't exist or cannot be updated.
        UpdateTask(listID string, task Task) error

        // DeleteTask permanently removes a task from the specified list.
        // Returns a BackendError with IsNotFound() == true if the task doesn't exist.
        DeleteTask(listID string, taskUID string) error

        // CreateTaskList creates a new task list with the given name and optional description.
        // The color parameter is optional and may be ignored by backends that don't support it.
        // Returns the ID of the newly created list or an error if creation fails.
        CreateTaskList(name, description, color string) (string, error)

        // DeleteTaskList permanently removes a task list and all tasks within it.
        // Returns an error if the list doesn't exist or cannot be deleted.
        DeleteTaskList(listID string) error

        // RenameTaskList changes the name of an existing task list.
        // Returns an error if the list doesn't exist or the new name is already in use.
        RenameTaskList(listID, newName string) error

        // GetDeletedTaskLists retrieves all task lists that have been moved to trash.
        // This is backend-specific and may not be supported by all backends.
        // For Nextcloud, returns calendars with the DeletedAt field set.
        // Returns an empty list if trash is not supported or empty.
        GetDeletedTaskLists() ([]TaskList, error)

        // RestoreTaskList restores a deleted task list from trash.
        // The listID parameter identifies the list to restore.
        // Returns an error if the list doesn't exist in trash or cannot be restored.
        RestoreTaskList(listID string) error

        // PermanentlyDeleteTaskList permanently deletes a task list from trash.
        // This operation is irreversible and removes the list completely.
        // Returns an error if the list doesn't exist in trash or cannot be deleted.
        PermanentlyDeleteTaskList(listID string) error

        // ParseStatusFlag converts user input (abbreviations, app names, or backend names)
        // to the backend's internal status format.
        // Examples: "T"  "NEEDS-ACTION" (Nextcloud), "T"  "TODO" (File)
        // Returns an error if the status flag is invalid.
        ParseStatusFlag(statusFlag string) (string, error)

        // StatusToDisplayName converts backend-specific status to display name.
        // Returns one of: "TODO", "DONE", "PROCESSING", "CANCELLED"
        // This is used for user-facing messages and output.
        StatusToDisplayName(backendStatus string) string

        // SortTasks sorts tasks in-place according to the backend's preferred order.
        // For example, Nextcloud sorts by priority (1=highest, 0=undefined last).
        SortTasks(tasks []Task)

        // GetPriorityColor returns an ANSI color code for the given priority.
        // Returns an empty string if no color should be applied.
        // Priority range: 0-9 (0=undefined, 1=highest, 9=lowest)
        GetPriorityColor(priority int) string

        // GetBackendDisplayName returns a formatted string for display in task list headers.
        // Examples: "[nextcloud:admin@localhost]", "[sqlite  nextcloud]", "[git:gosynctasks/TODO.md]"
        // This provides user context about which backend is being used.
        GetBackendDisplayName() string

        // GetBackendType returns the backend type identifier.
        // Returns one of: "nextcloud", "git", "sqlite", "file"
        GetBackendType() string

        // GetBackendContext returns contextual details specific to the backend.
        // Examples: "admin@localhost:8080" (nextcloud), "/path/to/repo/TODO.md" (git), "/path/to/tasks.db" (sqlite)
        GetBackendContext() string
}

// DetectableBackend extends TaskManager with auto-detection capabilities.
// Backends implementing this interface can be automatically detected based on
// the current environment (e.g., git repos, file system state).
type DetectableBackend interface {
        TaskManager

        // CanDetect checks if this backend can be used in the current environment.
        // For example, a Git backend would check for a git repository and TODO.md file.
        // Returns true if the backend is detected and usable, false otherwise.
        // This method should be fast and non-destructive.
        CanDetect() (bool, error)

        // DetectionInfo returns a human-readable description of what was detected.
        // This is used for informational messages when showing detected backends.
        // Example: "Git repository with TODO.md at /path/to/repo"
        DetectionInfo() string
}

// TaskFilter specifies filtering criteria for task queries.
// All filter fields are optional (nil means no filtering on that field).
// Multiple filter criteria are combined with AND logic.
type TaskFilter struct {
        // Statuses filters tasks by their status values.
        // Should contain backend-specific status names (e.g., "NEEDS-ACTION" for Nextcloud).
        // Multiple statuses are combined with OR logic.
        Statuses *[]string

        // ExcludeStatuses filters out tasks with these status values.
        // Should contain backend-specific status names (e.g., "COMPLETED" for Nextcloud).
        // Tasks matching any of these statuses will be excluded.
        ExcludeStatuses *[]string

        // DueAfter filters tasks due after this time (inclusive).
        DueAfter *time.Time

        // DueBefore filters tasks due before this time (inclusive).
        DueBefore *time.Time

        // CreatedAfter filters tasks created after this time (inclusive).
        CreatedAfter *time.Time

        // CreatedBefore filters tasks created before this time (inclusive).
        CreatedBefore *time.Time
}

// StatusStringTranslateToStandardStatus converts app status names to CalDAV standard statuses.
// This function translates: TODONEEDS-ACTION, DONECOMPLETED, PROCESSINGIN-PROCESS.
// Unknown statuses are passed through unchanged.
//
// Deprecated: Use TaskManager.ParseStatusFlag() instead for backend-specific translation.
func StatusStringTranslateToStandardStatus(status *[]string) *[]string <span class="cov8" title="14">{
        if status == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov8" title="13">statusMap := map[string]string{
                "TODO":       "NEEDS-ACTION",
                "DONE":       "COMPLETED",
                "PROCESSING": "IN-PROCESS",
                "CANCELLED":  "CANCELLED",
        }

        result := make([]string, len(*status))
        for i, s := range *status </span><span class="cov10" title="21">{
                if normalized, ok := statusMap[strings.ToUpper(s)]; ok </span><span class="cov9" title="18">{
                        result[i] = normalized
                }</span> else<span class="cov4" title="3"> {
                        result[i] = s
                }</span>
        }

        <span class="cov8" title="13">return &amp;result</span>
}

func StatusStringTranslateToAppStatus(status *[]string) *[]string <span class="cov8" title="14">{
        if status == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov8" title="13">statusMap := map[string]string{
                "NEEDS-ACTION": "TODO",
                "COMPLETED":    "DONE",
                "IN-PROCESS":   "PROCESSING",
                "CANCELLED":    "CANCELLED",
        }

        result := make([]string, len(*status))
        for i, s := range *status </span><span class="cov10" title="21">{
                if normalized, ok := statusMap[strings.ToUpper(s)]; ok </span><span class="cov9" title="18">{
                        result[i] = normalized
                }</span> else<span class="cov4" title="3"> {
                        result[i] = s
                }</span>
        }

        <span class="cov8" title="13">return &amp;result</span>
}

// Task represents a single task/todo item.
// The struct follows the iCalendar VTODO specification for maximum compatibility.
// Status values should use backend-specific formats (e.g., CalDAV statuses for Nextcloud).
type Task struct {
        // UID uniquely identifies the task within a backend.
        // Generated automatically if not provided during creation.
        UID string `json:"uid"`

        // Summary is the task title/name (required).
        Summary string `json:"summary"`

        // Description provides additional details about the task (optional).
        Description string `json:"description,omitempty"`

        // Status indicates the task's current state.
        // Backend-specific values: NEEDS-ACTION, IN-PROCESS, COMPLETED, CANCELLED (CalDAV)
        Status string `json:"status"`

        // Priority indicates task importance: 0-9 (0=undefined, 1=highest, 9=lowest).
        // Backend-specific interpretation (e.g., Nextcloud: 1-4=high, 5=medium, 6-9=low).
        Priority int `json:"priority"`

        // Created timestamp when the task was first created.
        Created time.Time `json:"created"`

        // Modified timestamp when the task was last modified.
        Modified time.Time `json:"modified"`

        // DueDate is the deadline for task completion (optional).
        DueDate *time.Time `json:"due_date,omitempty"`

        // StartDate is when work on the task should begin (optional).
        StartDate *time.Time `json:"start_date,omitempty"`

        // Completed timestamp when the task was marked as COMPLETED (optional).
        Completed *time.Time `json:"completed,omitempty"`

        // Categories are task tags/labels for organization (optional).
        Categories []string `json:"categories,omitempty"`

        // ParentUID links this task as a subtask of another task (optional).
        ParentUID string `json:"parent_uid,omitempty"`
}

// String returns a basic formatted string representation of the task.
// For more control over formatting, use FormatWithView.
func (t Task) String() string <span class="cov0" title="0">{
        return t.FormatWithView("default", nil, "2006-01-02")
}</span>

// FormatWithView formats the task for display with customizable view options.
//
// Parameters:
//   - view: "default" (summary + status) or "all" (includes metadata like dates and priority)
//   - backend: TaskManager for priority coloring (can be nil)
//   - dateFormat: Go time format string for date display
//
// The output includes ANSI color codes for terminal display:
//   - Status symbols:  (done),  (in progress),  (cancelled),  (todo)
//   - Priority colors: determined by backend.GetPriorityColor()
//   - Start date colors: cyan (past), yellow (within 3 days), gray (future)
//   - Due date colors: red (overdue), yellow (due soon), gray (future)
func (t Task) FormatWithView(view string, backend TaskManager, dateFormat string) string <span class="cov7" title="10">{
        return t.formatWithIndent(view, backend, dateFormat, 0)
}</span>

// FormatWithIndentLevel formats the task for display with a specific indentation level.
// This is useful for displaying hierarchical task structures where subtasks should be indented.
//
// Parameters:
//   - view: "default" (summary + status) or "all" (includes metadata like dates and priority)
//   - backend: TaskManager for priority coloring (can be nil)
//   - dateFormat: Go time format string for date display
//   - indentLevel: number of indentation levels (0 = no indent, 1 = one level, etc.)
func (t Task) FormatWithIndentLevel(view string, backend TaskManager, dateFormat string, indentLevel int) string <span class="cov0" title="0">{
        return t.formatWithIndent(view, backend, dateFormat, indentLevel)
}</span>

// formatWithIndent formats the task for display with indentation for subtasks.
// The indentLevel parameter specifies how many levels deep the task is in the hierarchy.
func (t Task) formatWithIndent(view string, backend TaskManager, dateFormat string, indentLevel int) string <span class="cov7" title="10">{
        var result strings.Builder

        // Convert backend-specific status to canonical display name
        displayStatus := t.Status
        if backend != nil </span><span class="cov0" title="0">{
                displayStatus = backend.StatusToDisplayName(t.Status)
        }</span>

        // Status indicator (using canonical status names)
        <span class="cov7" title="10">var statusColor, statusSymbol string
        switch displayStatus </span>{
        case "DONE":<span class="cov0" title="0">
                statusColor = "\033[32m" // Green
                statusSymbol = ""</span>
        case "PROCESSING":<span class="cov0" title="0">
                statusColor = "\033[33m" // Yellow
                statusSymbol = ""</span>
        case "CANCELLED":<span class="cov0" title="0">
                statusColor = "\033[31m" // Red
                statusSymbol = ""</span>
        default:<span class="cov7" title="10"> // TODO or any other status
                statusColor = "\033[37m" // White
                statusSymbol = ""</span>
        }

        // Get priority color from backend
        <span class="cov7" title="10">priorityColor := ""
        if t.Priority &gt; 0 &amp;&amp; backend != nil </span><span class="cov0" title="0">{
                priorityColor = backend.GetPriorityColor(t.Priority)
        }</span>

        // Start date
        <span class="cov7" title="10">startStr := ""
        if t.StartDate != nil </span><span class="cov7" title="9">{
                now := time.Now()
                start := *t.StartDate
                hoursDiff := start.Sub(now).Hours()

                if start.Before(now) || start.Equal(now) </span><span class="cov4" title="3">{
                        // Past/present: work should have begun (cyan)
                        startStr = fmt.Sprintf(" \033[36m(starts: %s)\033[0m", start.Format(dateFormat))
                }</span> else<span class="cov6" title="6"> if hoursDiff &lt;= 72 </span><span class="cov5" title="4">{ // Within 3 days (inclusive)
                        // Within 3 days (yellow) - includes exactly 72 hours
                        startStr = fmt.Sprintf(" \033[33m(starts: %s)\033[0m", start.Format(dateFormat))
                }</span> else<span class="cov3" title="2"> {
                        // Future beyond 3 days (gray)
                        startStr = fmt.Sprintf(" \033[90m(starts: %s)\033[0m", start.Format(dateFormat))
                }</span>
        }

        // Due date
        <span class="cov7" title="10">dueStr := ""
        if t.DueDate != nil </span><span class="cov1" title="1">{
                now := time.Now()
                due := *t.DueDate
                if due.Before(now) </span><span class="cov0" title="0">{
                        dueStr = fmt.Sprintf(" \033[31m(overdue: %s)\033[0m", due.Format(dateFormat))
                }</span> else<span class="cov1" title="1"> if due.Sub(now).Hours() &lt; 24 </span><span class="cov0" title="0">{
                        dueStr = fmt.Sprintf(" \033[33m(due: %s)\033[0m", due.Format(dateFormat))
                }</span> else<span class="cov1" title="1"> {
                        dueStr = fmt.Sprintf(" \033[90m(due: %s)\033[0m", due.Format(dateFormat))
                }</span>
        }

        // Main line: status + colored summary (by priority) + start + due
        // Add indentation for subtasks (2 spaces per level, plus the base 2 spaces)
        <span class="cov7" title="10">indent := strings.Repeat("  ", indentLevel)
        summaryColor := priorityColor
        if summaryColor == "" </span><span class="cov7" title="10">{
                summaryColor = "\033[1m" // Bold if no priority color
        }</span> else<span class="cov0" title="0"> {
                summaryColor = summaryColor + "\033[1m" // Bold + priority color
        }</span>
        <span class="cov7" title="10">result.WriteString(fmt.Sprintf("  %s%s%s\033[0m %s%s\033[0m%s%s\n",
                indent, statusColor, statusSymbol, summaryColor, t.Summary, startStr, dueStr))

        // Description (if present)
        if t.Description != "" </span><span class="cov0" title="0">{
                desc := strings.ReplaceAll(t.Description, "\n", " ")
                if len(desc) &gt; 70 </span><span class="cov0" title="0">{
                        desc = desc[:67] + "..."
                }</span>
                <span class="cov0" title="0">result.WriteString(fmt.Sprintf("     %s\033[2m%s\033[0m\n", indent, desc))</span>
        }

        // Metadata line: created, modified, priority (only for "all" view)
        <span class="cov7" title="10">if view == "all" </span><span class="cov0" title="0">{
                var metadata []string

                if !t.Created.IsZero() </span><span class="cov0" title="0">{
                        metadata = append(metadata, fmt.Sprintf("Created: %s", t.Created.Format(dateFormat)))
                }</span>

                <span class="cov0" title="0">if !t.Modified.IsZero() </span><span class="cov0" title="0">{
                        metadata = append(metadata, fmt.Sprintf("Modified: %s", t.Modified.Format(dateFormat)))
                }</span>

                <span class="cov0" title="0">if t.Priority &gt; 0 </span><span class="cov0" title="0">{
                        metadata = append(metadata, fmt.Sprintf("Priority: %d", t.Priority))
                }</span>

                <span class="cov0" title="0">if len(metadata) &gt; 0 </span><span class="cov0" title="0">{
                        result.WriteString(fmt.Sprintf("     %s\033[2m%s\033[0m\n", indent, strings.Join(metadata, " | ")))
                }</span>
        }

        <span class="cov7" title="10">return result.String()</span>
}

// TaskWithLevel represents a task and its hierarchical depth level.
// This is used when displaying tasks in a hierarchy where subtasks are indented.
type TaskWithLevel struct {
        Task  Task
        Level int
}

// OrganizeTasksHierarchically organizes tasks into a hierarchical structure where
// subtasks appear immediately after their parent tasks with appropriate indentation levels.
// Tasks without parents (or whose parents don't exist in the list) are treated as root tasks.
func OrganizeTasksHierarchically(tasks []Task) []TaskWithLevel <span class="cov7" title="9">{
        if len(tasks) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Build maps for quick lookups
        <span class="cov7" title="8">taskByUID := make(map[string]*Task)
        childrenMap := make(map[string][]Task)

        for i := range tasks </span><span class="cov9" title="20">{
                task := &amp;tasks[i]
                taskByUID[task.UID] = task

                if task.ParentUID != "" </span><span class="cov8" title="11">{
                        childrenMap[task.ParentUID] = append(childrenMap[task.ParentUID], *task)
                }</span>
        }

        // Find root tasks (tasks without parents or whose parents don't exist)
        <span class="cov7" title="8">var rootTasks []Task
        for _, task := range tasks </span><span class="cov9" title="20">{
                if task.ParentUID == "" || taskByUID[task.ParentUID] == nil </span><span class="cov7" title="10">{
                        rootTasks = append(rootTasks, task)
                }</span>
        }

        // Recursively build the hierarchical list
        <span class="cov7" title="8">var result []TaskWithLevel
        visited := make(map[string]bool)

        var addTaskWithChildren func(task Task, level int)
        addTaskWithChildren = func(task Task, level int) </span><span class="cov9" title="18">{
                // Prevent infinite loops in case of circular references
                if visited[task.UID] </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov9" title="18">visited[task.UID] = true

                // Add the current task
                result = append(result, TaskWithLevel{Task: task, Level: level})

                // Add children recursively
                if children, ok := childrenMap[task.UID]; ok </span><span class="cov6" title="7">{
                        for _, child := range children </span><span class="cov7" title="8">{
                                addTaskWithChildren(child, level+1)
                        }</span>
                }
        }

        // Process all root tasks
        <span class="cov7" title="8">for _, task := range rootTasks </span><span class="cov7" title="10">{
                addTaskWithChildren(task, 0)
        }</span>

        <span class="cov7" title="8">return result</span>
}

// TaskList represents a collection/category of tasks.
// In CalDAV, this corresponds to a calendar that supports VTODO components.
// Each backend may have its own interpretation (e.g., file directory, database table).
type TaskList struct {
        // ID uniquely identifies the list within the backend.
        ID string `json:"id"`

        // Name is the human-readable list name.
        Name string `json:"name"`

        // Description provides additional context about the list (optional).
        Description string `json:"description,omitempty"`

        // Color is a hex color code for UI display (optional, e.g., "#0082c9").
        Color string `json:"color,omitempty"`

        // URL is the backend-specific URL to access the list (e.g., CalDAV URL).
        URL string `json:"url"`

        // CTags is a synchronization token that changes when the list is modified.
        // Used for efficient sync operations (CalDAV-specific, optional).
        CTags string `json:"ctags,omitempty"`

        // DeletedAt indicates when the list was deleted (moved to trash).
        // Empty string means the list is not deleted.
        // Used by Nextcloud to track trashed calendars (Nextcloud-specific, optional).
        DeletedAt string `json:"deleted_at,omitempty"`
}

func (t TaskList) String() string <span class="cov0" title="0">{
        return t.StringWithWidth(80) // Default width
}</span>

func (t TaskList) StringWithWidth(termWidth int) string <span class="cov3" title="2">{
        var result strings.Builder

        // Calculate border width
        borderWidth := termWidth - 2
        if borderWidth &lt; 40 </span><span class="cov0" title="0">{
                borderWidth = 40
        }</span>
        <span class="cov3" title="2">if borderWidth &gt; 100 </span><span class="cov0" title="0">{
                borderWidth = 100
        }</span>

        // Build the title text
        <span class="cov3" title="2">titleText := " " + t.Name
        if t.Description != "" </span><span class="cov1" title="1">{
                titleText += " - " + t.Description
        }</span>
        <span class="cov3" title="2">titleText += " "

        // Calculate padding for header
        headerPadding := borderWidth - len(titleText) - 1
        if headerPadding &lt; 0 </span><span class="cov1" title="1">{
                headerPadding = 0
        }</span>

        // Top border with corner and title
        <span class="cov3" title="2">result.WriteString(fmt.Sprintf("\n\033[1;36m%s%s\033[0m\n", titleText, strings.Repeat("", headerPadding)))

        return result.String()</span>
}

func (t TaskList) BottomBorder() string <span class="cov0" title="0">{
        return t.BottomBorderWithWidth(80) // Default width
}</span>

func (t TaskList) BottomBorderWithWidth(termWidth int) string <span class="cov0" title="0">{
        // Calculate border width
        borderWidth := termWidth - 2
        if borderWidth &lt; 40 </span><span class="cov0" title="0">{
                borderWidth = 40
        }</span>
        <span class="cov0" title="0">if borderWidth &gt; 100 </span><span class="cov0" title="0">{
                borderWidth = 100
        }</span>

        // Bottom border
        <span class="cov0" title="0">return fmt.Sprintf("\033[1;36m%s\033[0m\n", strings.Repeat("", borderWidth))</span>
}

// StringWithBackend returns the list header with backend information displayed on the right side.
// The backend parameter can be nil, in which case no backend info is shown.
func (t TaskList) StringWithBackend(backend TaskManager) string <span class="cov3" title="2">{
        return t.StringWithWidthAndBackend(80, backend)
}</span>

// StringWithWidthAndBackend formats the list header with backend information.
// The backend info is positioned on the right side of the header, adapting to terminal width.
func (t TaskList) StringWithWidthAndBackend(termWidth int, backend TaskManager) string <span class="cov4" title="3">{
        // If no backend provided, fall back to standard display
        if backend == nil </span><span class="cov1" title="1">{
                return t.StringWithWidth(termWidth)
        }</span>

        <span class="cov3" title="2">var result strings.Builder

        // Calculate border width
        borderWidth := termWidth - 2
        if borderWidth &lt; 40 </span><span class="cov0" title="0">{
                borderWidth = 40
        }</span>
        <span class="cov3" title="2">if borderWidth &gt; 100 </span><span class="cov0" title="0">{
                borderWidth = 100
        }</span>

        // Get backend display name
        <span class="cov3" title="2">backendInfo := backend.GetBackendDisplayName()

        // Build the title text
        titleText := " " + t.Name
        if t.Description != "" </span><span class="cov3" title="2">{
                titleText += " - " + t.Description
        }</span>
        <span class="cov3" title="2">titleText += " "

        // Calculate available space for padding between title and backend info
        // Format:  Title  [backend] 
        titleLen := len(titleText)
        backendLen := len(backendInfo)
        totalContentLen := titleLen + backendLen + 2 // +2 for space and corner

        if totalContentLen &gt;= borderWidth </span><span class="cov1" title="1">{
                // Not enough space, truncate description or show without backend
                maxTitleLen := borderWidth - backendLen - 3
                if maxTitleLen &lt; 10 </span><span class="cov1" title="1">{
                        // If still not enough space, show without backend info
                        return t.StringWithWidth(termWidth)
                }</span>
                // Truncate title
                <span class="cov0" title="0">if len(titleText) &gt; maxTitleLen </span><span class="cov0" title="0">{
                        titleText = titleText[:maxTitleLen-3] + "... "
                }</span>
        }

        // Calculate padding between title and backend info
        <span class="cov1" title="1">paddingLen := borderWidth - len(titleText) - len(backendInfo) - 1
        if paddingLen &lt; 1 </span><span class="cov0" title="0">{
                paddingLen = 1
        }</span>

        // Top border with corner, title, padding, backend info
        <span class="cov1" title="1">result.WriteString(fmt.Sprintf("\n\033[1;36m%s%s%s\033[0m\n",
                titleText,
                strings.Repeat("", paddingLen),
                backendInfo))

        return result.String()</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package backend

import (
        "fmt"
        "math/rand"
        "time"
)

// This file contains shared test helpers and mocks used across backend tests.
// These are available to all _test.go files in the backend package.

// generateUID generates a unique identifier for testing
func generateUID() string <span class="cov2" title="4">{
        return fmt.Sprintf("task-%d-%s", time.Now().Unix(), randomString(8))
}</span>

// randomString generates a random string of given length
func randomString(length int) string <span class="cov2" title="4">{
        const charset = "abcdefghijklmnopqrstuvwxyz0123456789"
        b := make([]byte, length)
        for i := range b </span><span class="cov5" title="32">{
                b[i] = charset[rand.Intn(len(charset))]
        }</span>
        <span class="cov2" title="4">return string(b)</span>
}

// MockBackend implements TaskManager for testing
type MockBackend struct {
        Lists         []TaskList
        Tasks         map[string][]Task // listID -&gt; tasks
        AddTaskErr    error
        UpdateTaskErr error
        DeleteTaskErr error
        Name          string // For tests that need to identify the mock
}

// NewMockBackend creates a new mock backend instance
func NewMockBackend() *MockBackend <span class="cov4" title="11">{
        return &amp;MockBackend{
                Lists: []TaskList{},
                Tasks: make(map[string][]Task),
        }
}</span>

// NewMockBackendWithName creates a new mock backend with a name
func NewMockBackendWithName(name string) *MockBackend <span class="cov1" title="1">{
        mb := NewMockBackend()
        mb.Name = name
        return mb
}</span>

func (mb *MockBackend) GetTaskLists() ([]TaskList, error) <span class="cov4" title="14">{
        return mb.Lists, nil
}</span>

func (mb *MockBackend) GetTasks(listID string, filter *TaskFilter) ([]Task, error) <span class="cov4" title="13">{
        tasks, ok := mb.Tasks[listID]
        if !ok </span><span class="cov0" title="0">{
                return []Task{}, nil
        }</span>
        <span class="cov4" title="13">return tasks, nil</span>
}

func (mb *MockBackend) FindTasksBySummary(listID string, summary string) ([]Task, error) <span class="cov0" title="0">{
        return []Task{}, nil
}</span>

func (mb *MockBackend) AddTask(listID string, task Task) error <span class="cov10" title="1019">{
        if mb.AddTaskErr != nil </span><span class="cov1" title="1">{
                return mb.AddTaskErr
        }</span>

        <span class="cov9" title="1018">tasks := mb.Tasks[listID]
        tasks = append(tasks, task)
        mb.Tasks[listID] = tasks
        return nil</span>
}

func (mb *MockBackend) UpdateTask(listID string, task Task) error <span class="cov2" title="3">{
        if mb.UpdateTaskErr != nil </span><span class="cov0" title="0">{
                return mb.UpdateTaskErr
        }</span>

        <span class="cov2" title="3">tasks := mb.Tasks[listID]
        for i, t := range tasks </span><span class="cov2" title="3">{
                if t.UID == task.UID </span><span class="cov2" title="3">{
                        tasks[i] = task
                        mb.Tasks[listID] = tasks
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return NewBackendError("UpdateTask", 404, "task not found")</span>
}

func (mb *MockBackend) DeleteTask(listID string, taskUID string) error <span class="cov0" title="0">{
        if mb.DeleteTaskErr != nil </span><span class="cov0" title="0">{
                return mb.DeleteTaskErr
        }</span>

        <span class="cov0" title="0">tasks := mb.Tasks[listID]
        for i, t := range tasks </span><span class="cov0" title="0">{
                if t.UID == taskUID </span><span class="cov0" title="0">{
                        tasks = append(tasks[:i], tasks[i+1:]...)
                        mb.Tasks[listID] = tasks
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return NewBackendError("DeleteTask", 404, "task not found")</span>
}

func (mb *MockBackend) CreateTaskList(name, description, color string) (string, error) <span class="cov2" title="4">{
        listID := generateUID()
        mb.Lists = append(mb.Lists, TaskList{
                ID:    listID,
                Name:  name,
                Color: color,
                CTags: "ctag-initial",
        })
        mb.Tasks[listID] = []Task{}
        return listID, nil
}</span>

func (mb *MockBackend) DeleteTaskList(listID string) error <span class="cov0" title="0">{
        delete(mb.Tasks, listID)
        for i, list := range mb.Lists </span><span class="cov0" title="0">{
                if list.ID == listID </span><span class="cov0" title="0">{
                        mb.Lists = append(mb.Lists[:i], mb.Lists[i+1:]...)
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return NewBackendError("DeleteTaskList", 404, "list not found")</span>
}

func (mb *MockBackend) RenameTaskList(listID, newName string) error <span class="cov0" title="0">{
        for i, list := range mb.Lists </span><span class="cov0" title="0">{
                if list.ID == listID </span><span class="cov0" title="0">{
                        mb.Lists[i].Name = newName
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return NewBackendError("RenameTaskList", 404, "list not found")</span>
}

func (mb *MockBackend) GetDeletedTaskLists() ([]TaskList, error) <span class="cov0" title="0">{
        return []TaskList{}, nil
}</span>

func (mb *MockBackend) RestoreTaskList(listID string) error <span class="cov0" title="0">{
        return nil
}</span>

func (mb *MockBackend) PermanentlyDeleteTaskList(listID string) error <span class="cov0" title="0">{
        return nil
}</span>

func (mb *MockBackend) ParseStatusFlag(statusFlag string) (string, error) <span class="cov0" title="0">{
        // Simple mock implementation
        switch statusFlag </span>{
        case "T", "TODO":<span class="cov0" title="0">
                return "NEEDS-ACTION", nil</span>
        case "D", "DONE":<span class="cov0" title="0">
                return "COMPLETED", nil</span>
        case "P", "PROCESSING":<span class="cov0" title="0">
                return "IN-PROCESS", nil</span>
        case "C", "CANCELLED":<span class="cov0" title="0">
                return "CANCELLED", nil</span>
        default:<span class="cov0" title="0">
                return statusFlag, nil</span>
        }
}

func (mb *MockBackend) StatusToDisplayName(backendStatus string) string <span class="cov0" title="0">{
        switch backendStatus </span>{
        case "NEEDS-ACTION":<span class="cov0" title="0">
                return "TODO"</span>
        case "COMPLETED":<span class="cov0" title="0">
                return "DONE"</span>
        case "IN-PROCESS":<span class="cov0" title="0">
                return "PROCESSING"</span>
        case "CANCELLED":<span class="cov0" title="0">
                return "CANCELLED"</span>
        default:<span class="cov0" title="0">
                return backendStatus</span>
        }
}

func (mb *MockBackend) SortTasks(tasks []Task) {<span class="cov0" title="0">
        // No-op for mock
}</span>

func (mb *MockBackend) GetPriorityColor(priority int) string <span class="cov0" title="0">{
        return ""
}</span>

func (mb *MockBackend) GetBackendDisplayName() string <span class="cov0" title="0">{
        if mb.Name != "" </span><span class="cov0" title="0">{
                return "[mock:" + mb.Name + "]"
        }</span>
        <span class="cov0" title="0">return "[mock]"</span>
}

func (mb *MockBackend) GetBackendType() string <span class="cov0" title="0">{
        return "mock"
}</span>

func (mb *MockBackend) GetBackendContext() string <span class="cov0" title="0">{
        if mb.Name != "" </span><span class="cov0" title="0">{
                return mb.Name
        }</span>
        <span class="cov0" title="0">return "mock-backend"</span>
}

// MockDetectableBackend is a mock that implements DetectableBackend
type MockDetectableBackend struct {
        MockBackend
        canDetect     bool
        detectionInfo string
}

// NewMockDetectableBackend creates a new mock detectable backend
func NewMockDetectableBackend(canDetect bool, detectionInfo string) *MockDetectableBackend <span class="cov0" title="0">{
        return &amp;MockDetectableBackend{
                MockBackend:   *NewMockBackend(),
                canDetect:     canDetect,
                detectionInfo: detectionInfo,
        }
}</span>

func (m *MockDetectableBackend) CanDetect() (bool, error) <span class="cov1" title="2">{
        return m.canDetect, nil
}</span>

func (m *MockDetectableBackend) DetectionInfo() string <span class="cov1" title="1">{
        return m.detectionInfo
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package todoist

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "time"
)

const (
        // Todoist REST API v2 base URL
        APIBaseURL = "https://api.todoist.com/rest/v2"

        // API rate limit: ~450 requests per 15 minutes
        // We'll implement basic retry logic with exponential backoff
)

// APIClient handles HTTP communication with Todoist REST API v2
type APIClient struct {
        baseURL    string
        apiToken   string
        httpClient *http.Client
}

// NewAPIClient creates a new Todoist API client
func NewAPIClient(apiToken string) *APIClient <span class="cov0" title="0">{
        return &amp;APIClient{
                baseURL:  APIBaseURL,
                apiToken: apiToken,
                httpClient: &amp;http.Client{
                        Timeout: 30 * time.Second,
                },
        }
}</span>

// Project represents a Todoist project (maps to TaskList)
type Project struct {
        ID             string `json:"id"`
        Name           string `json:"name"`
        CommentCount   int    `json:"comment_count"`
        Order          int    `json:"order"`
        Color          string `json:"color"`
        IsShared       bool   `json:"is_shared"`
        IsFavorite     bool   `json:"is_favorite"`
        IsInboxProject bool   `json:"is_inbox_project"`
        IsTeamInbox    bool   `json:"is_team_inbox"`
        ViewStyle      string `json:"view_style"`
        URL            string `json:"url"`
        ParentID       string `json:"parent_id,omitempty"`
}

// TodoistTask represents a task from Todoist API
type TodoistTask struct {
        ID            string   `json:"id"`
        ProjectID     string   `json:"project_id"`
        SectionID     string   `json:"section_id,omitempty"`
        Content       string   `json:"content"`
        Description   string   `json:"description"`
        IsCompleted   bool     `json:"is_completed"`
        Labels        []string `json:"labels"`
        ParentID      string   `json:"parent_id,omitempty"`
        Order         int      `json:"order"`
        Priority      int      `json:"priority"` // 1=normal, 2, 3, 4=urgent
        Due           *Due     `json:"due,omitempty"`
        URL           string   `json:"url"`
        CommentCount  int      `json:"comment_count"`
        CreatedAt     string   `json:"created_at"` // RFC3339 format
        CreatorID     string   `json:"creator_id"`
        AssigneeID    string   `json:"assignee_id,omitempty"`
        AssignerID    string   `json:"assigner_id,omitempty"`
        Duration      *Duration `json:"duration,omitempty"`
}

// Due represents task due date information
type Due struct {
        Date        string `json:"date"`           // YYYY-MM-DD
        String      string `json:"string"`         // Human-readable (e.g., "tomorrow")
        Lang        string `json:"lang,omitempty"` // Language code
        IsRecurring bool   `json:"is_recurring"`
        Datetime    string `json:"datetime,omitempty"` // RFC3339 with time
        Timezone    string `json:"timezone,omitempty"`
}

// Duration represents task duration
type Duration struct {
        Amount int    `json:"amount"`
        Unit   string `json:"unit"` // "minute" or "day"
}

// CreateTaskRequest represents request body for creating a task
type CreateTaskRequest struct {
        Content     string   `json:"content"`
        Description string   `json:"description,omitempty"`
        ProjectID   string   `json:"project_id,omitempty"`
        SectionID   string   `json:"section_id,omitempty"`
        ParentID    string   `json:"parent_id,omitempty"`
        Order       int      `json:"order,omitempty"`
        Labels      []string `json:"labels,omitempty"`
        Priority    int      `json:"priority,omitempty"` // 1-4
        DueString   string   `json:"due_string,omitempty"`
        DueDate     string   `json:"due_date,omitempty"` // YYYY-MM-DD
        DueDatetime string   `json:"due_datetime,omitempty"` // RFC3339
        DueLang     string   `json:"due_lang,omitempty"`
        AssigneeID  string   `json:"assignee_id,omitempty"`
}

// UpdateTaskRequest represents request body for updating a task
type UpdateTaskRequest struct {
        Content     string   `json:"content,omitempty"`
        Description string   `json:"description,omitempty"`
        Labels      []string `json:"labels,omitempty"`
        Priority    int      `json:"priority,omitempty"`
        DueString   string   `json:"due_string,omitempty"`
        DueDate     string   `json:"due_date,omitempty"`
        DueDatetime string   `json:"due_datetime,omitempty"`
        DueLang     string   `json:"due_lang,omitempty"`
        AssigneeID  string   `json:"assignee_id,omitempty"`
}

// CreateProjectRequest represents request body for creating a project
type CreateProjectRequest struct {
        Name       string `json:"name"`
        ParentID   string `json:"parent_id,omitempty"`
        Color      string `json:"color,omitempty"`
        IsFavorite bool   `json:"is_favorite,omitempty"`
        ViewStyle  string `json:"view_style,omitempty"` // "list" or "board"
}

// UpdateProjectRequest represents request body for updating a project
type UpdateProjectRequest struct {
        Name       string `json:"name,omitempty"`
        Color      string `json:"color,omitempty"`
        IsFavorite *bool  `json:"is_favorite,omitempty"`
        ViewStyle  string `json:"view_style,omitempty"`
}

// doRequest performs an HTTP request with authentication
func (c *APIClient) doRequest(method, endpoint string, body interface{}) (*http.Response, error) <span class="cov0" title="0">{
        var reqBody io.Reader
        if body != nil </span><span class="cov0" title="0">{
                jsonData, err := json.Marshal(body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal request body: %w", err)
                }</span>
                <span class="cov0" title="0">reqBody = bytes.NewBuffer(jsonData)</span>
        }

        <span class="cov0" title="0">url := c.baseURL + endpoint
        req, err := http.NewRequest(method, url, reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Add authentication header
        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+c.apiToken)
        if body != nil </span><span class="cov0" title="0">{
                req.Header.Set("Content-Type", "application/json")
        }</span>

        <span class="cov0" title="0">resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request failed: %w", err)
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}

// GetProjects retrieves all projects
func (c *APIClient) GetProjects() ([]Project, error) <span class="cov0" title="0">{
        resp, err := c.doRequest("GET", "/projects", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("API error (status %d): %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var projects []Project
        if err := json.NewDecoder(resp.Body).Decode(&amp;projects); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">return projects, nil</span>
}

// GetProject retrieves a single project by ID
func (c *APIClient) GetProject(projectID string) (*Project, error) <span class="cov0" title="0">{
        resp, err := c.doRequest("GET", "/projects/"+projectID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">if resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("project not found: %s", projectID)
        }</span>
        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("API error (status %d): %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var project Project
        if err := json.NewDecoder(resp.Body).Decode(&amp;project); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;project, nil</span>
}

// CreateProject creates a new project
func (c *APIClient) CreateProject(req CreateProjectRequest) (*Project, error) <span class="cov0" title="0">{
        resp, err := c.doRequest("POST", "/projects", req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("API error (status %d): %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var project Project
        if err := json.NewDecoder(resp.Body).Decode(&amp;project); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;project, nil</span>
}

// UpdateProject updates an existing project
func (c *APIClient) UpdateProject(projectID string, req UpdateProjectRequest) error <span class="cov0" title="0">{
        resp, err := c.doRequest("POST", "/projects/"+projectID, req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">if resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                return fmt.Errorf("project not found: %s", projectID)
        }</span>
        // Todoist returns either 200 (with updated project) or 204 (no content)
        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK &amp;&amp; resp.StatusCode != http.StatusNoContent </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("API error (status %d): %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteProject deletes a project
func (c *APIClient) DeleteProject(projectID string) error <span class="cov0" title="0">{
        resp, err := c.doRequest("DELETE", "/projects/"+projectID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">if resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                return fmt.Errorf("project not found: %s", projectID)
        }</span>
        <span class="cov0" title="0">if resp.StatusCode != http.StatusNoContent </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("API error (status %d): %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetTasks retrieves all tasks, optionally filtered by project
func (c *APIClient) GetTasks(projectID string) ([]TodoistTask, error) <span class="cov0" title="0">{
        endpoint := "/tasks"
        if projectID != "" </span><span class="cov0" title="0">{
                endpoint += "?project_id=" + projectID
        }</span>

        <span class="cov0" title="0">resp, err := c.doRequest("GET", endpoint, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("API error (status %d): %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var tasks []TodoistTask
        if err := json.NewDecoder(resp.Body).Decode(&amp;tasks); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">return tasks, nil</span>
}

// GetTask retrieves a single task by ID
func (c *APIClient) GetTask(taskID string) (*TodoistTask, error) <span class="cov0" title="0">{
        resp, err := c.doRequest("GET", "/tasks/"+taskID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">if resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("task not found: %s", taskID)
        }</span>
        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("API error (status %d): %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var task TodoistTask
        if err := json.NewDecoder(resp.Body).Decode(&amp;task); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;task, nil</span>
}

// CreateTask creates a new task
func (c *APIClient) CreateTask(req CreateTaskRequest) (*TodoistTask, error) <span class="cov0" title="0">{
        resp, err := c.doRequest("POST", "/tasks", req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("API error (status %d): %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var task TodoistTask
        if err := json.NewDecoder(resp.Body).Decode(&amp;task); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;task, nil</span>
}

// UpdateTask updates an existing task
func (c *APIClient) UpdateTask(taskID string, req UpdateTaskRequest) error <span class="cov0" title="0">{
        resp, err := c.doRequest("POST", "/tasks/"+taskID, req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">if resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                return fmt.Errorf("task not found: %s", taskID)
        }</span>
        // Todoist returns either 200 (with updated task) or 204 (no content)
        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK &amp;&amp; resp.StatusCode != http.StatusNoContent </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("API error (status %d): %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CloseTask marks a task as completed
func (c *APIClient) CloseTask(taskID string) error <span class="cov0" title="0">{
        resp, err := c.doRequest("POST", "/tasks/"+taskID+"/close", nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">if resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                return fmt.Errorf("task not found: %s", taskID)
        }</span>
        // Todoist returns either 200 (with updated task) or 204 (no content)
        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK &amp;&amp; resp.StatusCode != http.StatusNoContent </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("API error (status %d): %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ReopenTask marks a completed task as not completed
func (c *APIClient) ReopenTask(taskID string) error <span class="cov0" title="0">{
        resp, err := c.doRequest("POST", "/tasks/"+taskID+"/reopen", nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">if resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                return fmt.Errorf("task not found: %s", taskID)
        }</span>
        // Todoist returns either 200 (with updated task) or 204 (no content)
        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK &amp;&amp; resp.StatusCode != http.StatusNoContent </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("API error (status %d): %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteTask deletes a task
func (c *APIClient) DeleteTask(taskID string) error <span class="cov0" title="0">{
        resp, err := c.doRequest("DELETE", "/tasks/"+taskID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">if resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                return fmt.Errorf("task not found: %s", taskID)
        }</span>
        <span class="cov0" title="0">if resp.StatusCode != http.StatusNoContent </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("API error (status %d): %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package todoist

import (
        "gosynctasks/backend"
        "gosynctasks/internal/credentials"
        "fmt"
        "strings"
)

func init() <span class="cov1" title="1">{
        // Register Todoist backend for config type "todoist"
        backend.RegisterType("todoist", newTodoistBackendWrapper)
}</span>

// newTodoistBackendWrapper wraps NewTodoistBackend to match BackendConfigConstructor signature
func newTodoistBackendWrapper(config backend.BackendConfig) (backend.TaskManager, error) <span class="cov0" title="0">{
        return NewTodoistBackend(config)
}</span>

// TodoistBackend implements backend.TaskManager for Todoist
type TodoistBackend struct {
        config         backend.BackendConfig
        apiClient      *APIClient
        apiToken       string
        BackendName    string // Backend name for credential resolution
        ConfigUsername string // Username hint from config (typically "token" for API keys)
}

// NewTodoistBackend creates a new Todoist backend instance
func NewTodoistBackend(config backend.BackendConfig) (*TodoistBackend, error) <span class="cov1" title="1">{
        tb := &amp;TodoistBackend{
                config:         config,
                BackendName:    config.Name,
                ConfigUsername: config.Username,
        }

        // Resolve API token from credentials (keyring &gt; env &gt; config)
        apiToken, err := tb.getAPIToken()
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tb.apiToken = apiToken
        tb.apiClient = NewAPIClient(apiToken)

        // Validate token by attempting to fetch projects
        if _, err := tb.apiClient.GetProjects(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to validate Todoist API token: %w", err)
        }</span>

        <span class="cov0" title="0">return tb, nil</span>
}

// getAPIToken retrieves the API token from credentials with priority:
// 1. Keyring (if username is provided, typically "token")
// 2. Environment variable (GOSYNCTASKS_TODOIST_PASSWORD or GOSYNCTASKS_&lt;BACKEND_NAME&gt;_PASSWORD)
// 3. Config file (api_token field)
func (tb *TodoistBackend) getAPIToken() (string, error) <span class="cov1" title="1">{
        // Try credential resolver first if backend name is available
        if tb.BackendName != "" </span><span class="cov0" title="0">{
                resolver := credentials.NewResolver()

                // For Todoist, we use username as a hint (typically "token")
                // The API token is stored as the "password" in the keyring
                username := tb.ConfigUsername
                if username == "" </span><span class="cov0" title="0">{
                        username = "token" // Default username hint for API tokens
                }</span>

                <span class="cov0" title="0">creds, err := resolver.Resolve(tb.BackendName, username, "", nil)
                if err == nil &amp;&amp; creds.Password != "" </span><span class="cov0" title="0">{
                        // API token found in keyring or environment
                        return creds.Password, nil
                }</span>
                // If error is not "not found", log but continue to fallback
        }

        // Fallback to config.APIToken
        <span class="cov1" title="1">if tb.config.APIToken != "" </span><span class="cov0" title="0">{
                return tb.config.APIToken, nil
        }</span>

        // No token found anywhere
        <span class="cov1" title="1">return "", fmt.Errorf("todoist API token not found (tried: keyring, environment variables, config)\n" +
                "Set it with: gosynctasks credentials set %s token --prompt\n" +
                "Or add 'api_token' to your config file", tb.BackendName)</span>
}

// GetTaskLists retrieves all Todoist projects as task lists
func (tb *TodoistBackend) GetTaskLists() ([]backend.TaskList, error) <span class="cov0" title="0">{
        projects, err := tb.apiClient.GetProjects()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get projects: %w", err)
        }</span>

        <span class="cov0" title="0">lists := make([]backend.TaskList, len(projects))
        for i, project := range projects </span><span class="cov0" title="0">{
                lists[i] = toTaskList(&amp;project)
        }</span>

        <span class="cov0" title="0">return lists, nil</span>
}

// GetTasks retrieves tasks from a specific project
func (tb *TodoistBackend) GetTasks(listID string, filter *backend.TaskFilter) ([]backend.Task, error) <span class="cov0" title="0">{
        todoistTasks, err := tb.apiClient.GetTasks(listID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get tasks: %w", err)
        }</span>

        <span class="cov0" title="0">var tasks []backend.Task
        for i := range todoistTasks </span><span class="cov0" title="0">{
                task := toTask(&amp;todoistTasks[i])

                // Apply filter if provided
                if filter != nil &amp;&amp; !tb.matchesFilter(task, filter) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">tasks = append(tasks, task)</span>
        }

        // Sort tasks
        <span class="cov0" title="0">tb.SortTasks(tasks)

        return tasks, nil</span>
}

// matchesFilter checks if a task matches the given filter
func (tb *TodoistBackend) matchesFilter(task backend.Task, filter *backend.TaskFilter) bool <span class="cov0" title="0">{
        // Check status filter
        if filter.Statuses != nil &amp;&amp; len(*filter.Statuses) &gt; 0 </span><span class="cov0" title="0">{
                matchesStatus := false
                for _, status := range *filter.Statuses </span><span class="cov0" title="0">{
                        if task.Status == status </span><span class="cov0" title="0">{
                                matchesStatus = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !matchesStatus </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Check due date filters
        <span class="cov0" title="0">if filter.DueAfter != nil &amp;&amp; task.DueDate != nil &amp;&amp; !task.DueDate.IsZero() </span><span class="cov0" title="0">{
                if task.DueDate.Before(*filter.DueAfter) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">if filter.DueBefore != nil &amp;&amp; task.DueDate != nil &amp;&amp; !task.DueDate.IsZero() </span><span class="cov0" title="0">{
                if task.DueDate.After(*filter.DueBefore) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Check created after filter
        <span class="cov0" title="0">if filter.CreatedAfter != nil &amp;&amp; !task.Created.IsZero() </span><span class="cov0" title="0">{
                if task.Created.Before(*filter.CreatedAfter) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// FindTasksBySummary searches for tasks by content
func (tb *TodoistBackend) FindTasksBySummary(listID string, summary string) ([]backend.Task, error) <span class="cov0" title="0">{
        tasks, err := tb.GetTasks(listID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">summary = strings.ToLower(summary)
        var matches []backend.Task

        for _, task := range tasks </span><span class="cov0" title="0">{
                if strings.Contains(strings.ToLower(task.Summary), summary) </span><span class="cov0" title="0">{
                        matches = append(matches, task)
                }</span>
        }

        <span class="cov0" title="0">return matches, nil</span>
}

// AddTask creates a new task in Todoist
func (tb *TodoistBackend) AddTask(listID string, task backend.Task) error <span class="cov0" title="0">{
        req := toCreateTaskRequest(task, listID)

        _, err := tb.apiClient.CreateTask(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create task: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateTask modifies an existing task
func (tb *TodoistBackend) UpdateTask(listID string, task backend.Task) error <span class="cov0" title="0">{
        // Handle status changes separately
        if task.Status == "DONE" </span><span class="cov0" title="0">{
                // Close the task
                if err := tb.apiClient.CloseTask(task.UID); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to close task: %w", err)
                }</span>
        } else<span class="cov0" title="0"> if task.Status == "TODO" </span><span class="cov0" title="0">{
                // Reopen if it was completed
                // We'll try to update first, and if needed reopen
                if err := tb.apiClient.ReopenTask(task.UID); err != nil </span>{<span class="cov0" title="0">
                        // It might not be closed, so we'll continue with update
                }</span>
        }

        // Update other task properties
        <span class="cov0" title="0">req := toUpdateTaskRequest(task)
        if err := tb.apiClient.UpdateTask(task.UID, req); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update task: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteTask removes a task from Todoist
func (tb *TodoistBackend) DeleteTask(listID string, taskUID string) error <span class="cov0" title="0">{
        if err := tb.apiClient.DeleteTask(taskUID); err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                        return backend.NewBackendError("DeleteTask", 404, fmt.Sprintf("task %q not found", taskUID))
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to delete task: %w", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// CreateTaskList creates a new Todoist project
func (tb *TodoistBackend) CreateTaskList(name, description, color string) (string, error) <span class="cov0" title="0">{
        req := CreateProjectRequest{
                Name:  name,
                Color: color,
        }

        project, err := tb.apiClient.CreateProject(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create project: %w", err)
        }</span>

        <span class="cov0" title="0">return project.ID, nil</span>
}

// DeleteTaskList deletes a Todoist project
func (tb *TodoistBackend) DeleteTaskList(listID string) error <span class="cov0" title="0">{
        if err := tb.apiClient.DeleteProject(listID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete project: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RenameTaskList renames a Todoist project
func (tb *TodoistBackend) RenameTaskList(listID, newName string) error <span class="cov0" title="0">{
        req := UpdateProjectRequest{
                Name: newName,
        }

        if err := tb.apiClient.UpdateProject(listID, req); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to rename project: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDeletedTaskLists retrieves deleted projects (not supported by Todoist)
func (tb *TodoistBackend) GetDeletedTaskLists() ([]backend.TaskList, error) <span class="cov0" title="0">{
        // Todoist doesn't have a trash/archive API for projects
        return []backend.TaskList{}, nil
}</span>

// RestoreTaskList restores a deleted project (not supported by Todoist)
func (tb *TodoistBackend) RestoreTaskList(listID string) error <span class="cov0" title="0">{
        return fmt.Errorf("TodoistBackend.RestoreTaskList not supported (Todoist has no trash feature)")
}</span>

// PermanentlyDeleteTaskList permanently deletes a project (not supported separately)
func (tb *TodoistBackend) PermanentlyDeleteTaskList(listID string) error <span class="cov0" title="0">{
        // In Todoist, delete is already permanent
        return tb.DeleteTaskList(listID)
}</span>

// ParseStatusFlag converts user input to Todoist status
func (tb *TodoistBackend) ParseStatusFlag(statusFlag string) (string, error) <span class="cov10" title="6">{
        return parseStatusFlag(statusFlag)
}</span>

// StatusToDisplayName converts Todoist status to display name
func (tb *TodoistBackend) StatusToDisplayName(backendStatus string) string <span class="cov0" title="0">{
        return statusToDisplayName(backendStatus)
}</span>

// SortTasks sorts tasks by priority and creation date
func (tb *TodoistBackend) SortTasks(tasks []backend.Task) <span class="cov0" title="0">{
        // Simple bubble sort (sufficient for typical task lists)
        for i := 0; i &lt; len(tasks); i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(tasks); j++ </span><span class="cov0" title="0">{
                        // Priority 0 goes last
                        iPrio := tasks[i].Priority
                        jPrio := tasks[j].Priority
                        if iPrio == 0 </span><span class="cov0" title="0">{
                                iPrio = 100
                        }</span>
                        <span class="cov0" title="0">if jPrio == 0 </span><span class="cov0" title="0">{
                                jPrio = 100
                        }</span>

                        // Lower priority number = higher priority
                        <span class="cov0" title="0">if iPrio &gt; jPrio </span><span class="cov0" title="0">{
                                tasks[i], tasks[j] = tasks[j], tasks[i]
                        }</span> else<span class="cov0" title="0"> if iPrio == jPrio </span><span class="cov0" title="0">{
                                // Same priority, sort by creation date (older first)
                                if tasks[i].Created.After(tasks[j].Created) </span><span class="cov0" title="0">{
                                        tasks[i], tasks[j] = tasks[j], tasks[i]
                                }</span>
                        }
                }
        }
}

// GetPriorityColor returns ANSI color code for priority
func (tb *TodoistBackend) GetPriorityColor(priority int) string <span class="cov9" title="5">{
        switch </span>{
        case priority &gt;= 1 &amp;&amp; priority &lt;= 2:<span class="cov1" title="1"> // Urgent
                return "\033[31m"</span> // Red
        case priority &gt;= 3 &amp;&amp; priority &lt;= 4:<span class="cov1" title="1"> // High
                return "\033[33m"</span> // Yellow
        case priority &gt;= 5 &amp;&amp; priority &lt;= 6:<span class="cov1" title="1"> // Medium
                return "\033[36m"</span> // Cyan
        case priority &gt;= 7 &amp;&amp; priority &lt;= 9:<span class="cov1" title="1"> // Low
                return "\033[34m"</span> // Blue
        default:<span class="cov1" title="1">
                return ""</span> // No color
        }
}

// GetBackendDisplayName returns formatted display name
func (tb *TodoistBackend) GetBackendDisplayName() string <span class="cov1" title="1">{
        return "[todoist]"
}</span>

// GetBackendType returns the backend type identifier
func (tb *TodoistBackend) GetBackendType() string <span class="cov1" title="1">{
        return "todoist"
}</span>

// GetBackendContext returns contextual details
func (tb *TodoistBackend) GetBackendContext() string <span class="cov0" title="0">{
        // We could fetch user info from API, but for now just return the type
        return "todoist"
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package todoist

import (
        "gosynctasks/backend"
        "fmt"
        "strings"
        "time"
)

// toTask converts a Todoist task to gosynctasks Task
func toTask(todoistTask *TodoistTask) backend.Task <span class="cov0" title="0">{
        task := backend.Task{
                UID:         todoistTask.ID,
                Summary:     todoistTask.Content,
                Description: todoistTask.Description,
                Categories:  todoistTask.Labels,
                ParentUID:   todoistTask.ParentID,
        }

        // Map status (Todoist only has completed/not completed)
        if todoistTask.IsCompleted </span><span class="cov0" title="0">{
                task.Status = "DONE"
        }</span> else<span class="cov0" title="0"> {
                task.Status = "TODO"
        }</span>

        // Map priority (Todoist: 1=normal, 4=urgent; gosynctasks: 1=highest, 9=lowest)
        // Conversion: priority 4  1, priority 3  3, priority 2  5, priority 1  7
        <span class="cov0" title="0">switch todoistTask.Priority </span>{
        case 4:<span class="cov0" title="0"> // Urgent
                task.Priority = 1</span>
        case 3:<span class="cov0" title="0"> // High
                task.Priority = 3</span>
        case 2:<span class="cov0" title="0"> // Medium
                task.Priority = 5</span>
        case 1:<span class="cov0" title="0"> // Normal
                task.Priority = 7</span>
        default:<span class="cov0" title="0">
                task.Priority = 0</span> // Undefined
        }

        // Parse due date
        <span class="cov0" title="0">if todoistTask.Due != nil </span><span class="cov0" title="0">{
                if todoistTask.Due.Datetime != "" </span><span class="cov0" title="0">{
                        // Has specific datetime
                        if dueTime, err := time.Parse(time.RFC3339, todoistTask.Due.Datetime); err == nil </span><span class="cov0" title="0">{
                                task.DueDate = &amp;dueTime
                        }</span>
                } else<span class="cov0" title="0"> if todoistTask.Due.Date != "" </span><span class="cov0" title="0">{
                        // Has only date (no specific time)
                        if dueTime, err := time.Parse("2006-01-02", todoistTask.Due.Date); err == nil </span><span class="cov0" title="0">{
                                task.DueDate = &amp;dueTime
                        }</span>
                }
        }

        // Parse created timestamp
        <span class="cov0" title="0">if todoistTask.CreatedAt != "" </span><span class="cov0" title="0">{
                if createdTime, err := time.Parse(time.RFC3339, todoistTask.CreatedAt); err == nil </span><span class="cov0" title="0">{
                        task.Created = createdTime
                }</span>
        }

        // Todoist doesn't provide modified timestamp directly
        // We'll use created time as fallback
        <span class="cov0" title="0">task.Modified = task.Created

        return task</span>
}

// toTaskList converts a Todoist project to gosynctasks TaskList
func toTaskList(project *Project) backend.TaskList <span class="cov0" title="0">{
        return backend.TaskList{
                ID:          project.ID,
                Name:        project.Name,
                Description: fmt.Sprintf("%d comments", project.CommentCount),
                Color:       project.Color,
        }
}</span>

// toCreateTaskRequest converts gosynctasks Task to Todoist create request
func toCreateTaskRequest(task backend.Task, projectID string) CreateTaskRequest <span class="cov0" title="0">{
        req := CreateTaskRequest{
                Content:     task.Summary,
                Description: task.Description,
                ProjectID:   projectID,
                ParentID:    task.ParentUID,
                Labels:      task.Categories,
        }

        // Map priority (gosynctasks: 1=highest; Todoist: 4=urgent)
        switch </span>{
        case task.Priority &gt;= 1 &amp;&amp; task.Priority &lt;= 2:<span class="cov0" title="0">
                req.Priority = 4</span> // Urgent
        case task.Priority &gt;= 3 &amp;&amp; task.Priority &lt;= 4:<span class="cov0" title="0">
                req.Priority = 3</span> // High
        case task.Priority &gt;= 5 &amp;&amp; task.Priority &lt;= 6:<span class="cov0" title="0">
                req.Priority = 2</span> // Medium
        case task.Priority &gt;= 7 &amp;&amp; task.Priority &lt;= 9:<span class="cov0" title="0">
                req.Priority = 1</span> // Normal
        default:<span class="cov0" title="0">
                req.Priority = 1</span> // Default to normal
        }

        // Set due date
        <span class="cov0" title="0">if task.DueDate != nil &amp;&amp; !task.DueDate.IsZero() </span><span class="cov0" title="0">{
                // Check if it has time component
                if task.DueDate.Hour() == 0 &amp;&amp; task.DueDate.Minute() == 0 &amp;&amp; task.DueDate.Second() == 0 </span><span class="cov0" title="0">{
                        // Date only
                        req.DueDate = task.DueDate.Format("2006-01-02")
                }</span> else<span class="cov0" title="0"> {
                        // Date and time
                        req.DueDatetime = task.DueDate.Format(time.RFC3339)
                }</span>
        }

        <span class="cov0" title="0">return req</span>
}

// toUpdateTaskRequest converts gosynctasks Task to Todoist update request
func toUpdateTaskRequest(task backend.Task) UpdateTaskRequest <span class="cov0" title="0">{
        req := UpdateTaskRequest{
                Content:     task.Summary,
                Description: task.Description,
                Labels:      task.Categories,
        }

        // Map priority
        switch </span>{
        case task.Priority &gt;= 1 &amp;&amp; task.Priority &lt;= 2:<span class="cov0" title="0">
                req.Priority = 4</span> // Urgent
        case task.Priority &gt;= 3 &amp;&amp; task.Priority &lt;= 4:<span class="cov0" title="0">
                req.Priority = 3</span> // High
        case task.Priority &gt;= 5 &amp;&amp; task.Priority &lt;= 6:<span class="cov0" title="0">
                req.Priority = 2</span> // Medium
        case task.Priority &gt;= 7 &amp;&amp; task.Priority &lt;= 9:<span class="cov0" title="0">
                req.Priority = 1</span> // Normal
        default:<span class="cov0" title="0">
                req.Priority = 1</span> // Default to normal
        }

        // Set due date
        <span class="cov0" title="0">if task.DueDate != nil &amp;&amp; !task.DueDate.IsZero() </span><span class="cov0" title="0">{
                if task.DueDate.Hour() == 0 &amp;&amp; task.DueDate.Minute() == 0 &amp;&amp; task.DueDate.Second() == 0 </span><span class="cov0" title="0">{
                        req.DueDate = task.DueDate.Format("2006-01-02")
                }</span> else<span class="cov0" title="0"> {
                        req.DueDatetime = task.DueDate.Format(time.RFC3339)
                }</span>
        }

        <span class="cov0" title="0">return req</span>
}

// parseStatusFlag converts CLI status input to Todoist-compatible status
func parseStatusFlag(statusFlag string) (string, error) <span class="cov10" title="6">{
        upper := strings.ToUpper(statusFlag)

        // Handle abbreviations
        switch upper </span>{
        case "T":<span class="cov1" title="1">
                return "TODO", nil</span>
        case "D":<span class="cov1" title="1">
                return "DONE", nil</span>
        case "P":<span class="cov0" title="0">
                // Todoist doesn't have "PROCESSING" - we'll use TODO with a label
                return "PROCESSING", nil</span>
        case "C":<span class="cov0" title="0">
                // Todoist doesn't have "CANCELLED" - we'll use a label
                return "CANCELLED", nil</span>
        }

        // Handle full names
        <span class="cov7" title="4">switch upper </span>{
        case "TODO", "DONE", "PROCESSING", "CANCELLED":<span class="cov6" title="3">
                return upper, nil</span>
        }

        <span class="cov1" title="1">return "", fmt.Errorf("invalid status flag: %s (use TODO/T, DONE/D, PROCESSING/P, CANCELLED/C)", statusFlag)</span>
}

// statusToDisplayName converts backend status to display name
func statusToDisplayName(backendStatus string) string <span class="cov0" title="0">{
        // Todoist backend uses app-style status names directly
        return backendStatus
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package main

import (
        "log"
        "time"

        "gosynctasks/backend"
        "gosynctasks/backend/sqlite"
        "gosynctasks/backend/sync"
        "gosynctasks/internal/config"

        "github.com/spf13/cobra"
)

// newBackgroundSyncCmd creates a hidden command that runs sync in background
// This is spawned as a separate process to allow the main CLI to exit immediately
func newBackgroundSyncCmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:    "_internal_background_sync",
                Hidden: true, // Don't show in help
                Short:  "Internal command for background sync (do not call directly)",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        // Load config
                        cfg := config.GetConfig()

                        // Check if sync is enabled
                        if !cfg.Sync.Enabled || !cfg.Sync.AutoSync </span><span class="cov0" title="0">{
                                return nil // Nothing to do
                        }</span>

                        // Get backends
                        <span class="cov0" title="0">localBackend, err := getBackend(cfg, cfg.Sync.LocalBackend)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("[BackgroundSync] Failed to get local backend: %v", err)
                                return nil // Silent fail
                        }</span>

                        <span class="cov0" title="0">remoteBackend, err := getBackend(cfg, cfg.Sync.RemoteBackend)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("[BackgroundSync] Failed to get remote backend: %v", err)
                                return nil // Silent fail
                        }</span>

                        // Ensure local is SQLite
                        <span class="cov0" title="0">sqliteBackend, ok := localBackend.(*sqlite.SQLiteBackend)
                        if !ok </span><span class="cov0" title="0">{
                                return nil // Not SQLite, can't sync
                        }</span>

                        // Create sync manager
                        <span class="cov0" title="0">strategy := sync.ConflictResolutionStrategy(cfg.Sync.ConflictResolution)
                        syncManager := sync.NewSyncManager(sqliteBackend, remoteBackend, strategy)

                        // Give it a moment to ensure parent process has exited
                        time.Sleep(100 * time.Millisecond)

                        // Execute sync with timeout
                        done := make(chan struct{})
                        go func() </span><span class="cov0" title="0">{
                                // Process pending operations
                                _, err := syncManager.PushOnly()
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("[BackgroundSync] Push error: %v", err)
                                }</span>
                                <span class="cov0" title="0">close(done)</span>
                        }()

                        // Wait up to 10 seconds for sync to complete
                        <span class="cov0" title="0">select </span>{
                        case &lt;-done:<span class="cov0" title="0"></span>
                                // Success - exit silently
                        case &lt;-time.After(10 * time.Second):<span class="cov0" title="0"></span>
                                // Timeout - operations remain queued
                        }

                        <span class="cov0" title="0">return nil</span>
                },
        }

        <span class="cov0" title="0">return cmd</span>
}

// getBackend is a helper to get a backend by name from config
func getBackend(cfg *config.Config, name string) (backend.TaskManager, error) <span class="cov0" title="0">{
        // Create registry
        registry, err := backend.NewBackendRegistry(cfg.GetEnabledBackends())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get backend
        <span class="cov0" title="0">return registry.GetBackend(name)</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package main

import (
        "fmt"
        "strings"
        "syscall"

        "github.com/spf13/cobra"
        "golang.org/x/term"

        "gosynctasks/internal/config"
        "gosynctasks/internal/credentials"
)

func newCredentialsCmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "credentials",
                Short: "Manage backend credentials",
                Long: `Securely manage credentials using system keyring.

Credentials can be stored in three ways (in priority order):
  1. System keyring (most secure) - recommended
  2. Environment variables (good for CI/CD)
  3. Config file URL (legacy - least secure)

Examples:
  # Store credentials in keyring (interactive password prompt)
  gosynctasks credentials set nextcloud myuser --prompt

  # Store credentials in keyring (non-interactive)
  gosynctasks credentials set nextcloud myuser mypassword

  # Check if credentials exist
  gosynctasks credentials get nextcloud myuser

  # Remove credentials from keyring
  gosynctasks credentials delete nextcloud myuser`,
        }

        cmd.AddCommand(newCredentialsSetCmd())
        cmd.AddCommand(newCredentialsGetCmd())
        cmd.AddCommand(newCredentialsDeleteCmd())

        return cmd
}</span>

func newCredentialsSetCmd() *cobra.Command <span class="cov0" title="0">{
        var promptPassword bool

        cmd := &amp;cobra.Command{
                Use:   "set &lt;backend&gt; [username] [password]",
                Short: "Store credentials in system keyring",
                Long: `Store backend credentials securely in the system keyring.

If username is not provided, it will be read from the backend configuration.
If --prompt is specified, password will be read interactively (recommended for security).

Examples:
  # Interactive password prompt (most secure)
  gosynctasks credentials set nextcloud myuser --prompt

  # Non-interactive (less secure - password visible in shell history)
  gosynctasks credentials set nextcloud myuser mypassword

  # Use username from config
  gosynctasks credentials set nextcloud --prompt`,
                Args: cobra.RangeArgs(1, 3),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        backendName := args[0]

                        // Get backend config to validate it exists
                        cfg := config.GetConfig()
                        backendConfig, exists := cfg.Backends[backendName]
                        if !exists </span><span class="cov0" title="0">{
                                return fmt.Errorf("backend %q not found in configuration", backendName)
                        }</span>

                        // Determine username
                        <span class="cov0" title="0">var username string
                        if len(args) &gt;= 2 </span><span class="cov0" title="0">{
                                username = args[1]
                        }</span> else<span class="cov0" title="0"> if backendConfig.Username != "" </span><span class="cov0" title="0">{
                                username = backendConfig.Username
                        }</span> else<span class="cov0" title="0"> {
                                return fmt.Errorf("username is required (not found in config for backend %q)", backendName)
                        }</span>

                        // Determine password
                        <span class="cov0" title="0">var password string
                        if promptPassword </span><span class="cov0" title="0">{
                                // Interactive password prompt
                                fmt.Printf("Enter password for %s@%s: ", username, backendName)
                                passwordBytes, err := term.ReadPassword(int(syscall.Stdin))
                                fmt.Println() // New line after password input
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to read password: %w", err)
                                }</span>
                                <span class="cov0" title="0">password = string(passwordBytes)

                                if password == "" </span><span class="cov0" title="0">{
                                        return fmt.Errorf("password cannot be empty")
                                }</span>
                        } else<span class="cov0" title="0"> if len(args) &gt;= 3 </span><span class="cov0" title="0">{
                                password = args[2]
                        }</span> else<span class="cov0" title="0"> {
                                return fmt.Errorf("password is required (use --prompt for interactive input)")
                        }</span>

                        // Store in keyring
                        <span class="cov0" title="0">if err := credentials.Set(backendName, username, password); err != nil </span><span class="cov0" title="0">{
                                // Check if keyring is available
                                if !credentials.IsAvailable() </span><span class="cov0" title="0">{
                                        return fmt.Errorf("system keyring is not available. Try using environment variables instead:\n  export GOSYNCTASKS_%s_USERNAME=%s\n  export GOSYNCTASKS_%s_PASSWORD=&lt;password&gt;",
                                                strings.ToUpper(strings.ReplaceAll(backendName, "-", "_")),
                                                username,
                                                strings.ToUpper(strings.ReplaceAll(backendName, "-", "_")))
                                }</span>
                                <span class="cov0" title="0">return err</span>
                        }

                        <span class="cov0" title="0">fmt.Printf(" Credentials stored successfully for %s@%s\n", username, backendName)
                        fmt.Println("\nNext steps:")
                        fmt.Printf("  1. Update your config to use keyring credentials:\n")
                        if backendConfig.URL != "" </span><span class="cov0" title="0">{
                                fmt.Printf("     - Remove password from URL\n")
                        }</span>
                        <span class="cov0" title="0">if backendConfig.Host == "" </span><span class="cov0" title="0">{
                                fmt.Printf("     - Add 'host: &lt;hostname&gt;' to backend config\n")
                        }</span>
                        <span class="cov0" title="0">if backendConfig.Username == "" </span><span class="cov0" title="0">{
                                fmt.Printf("     - Add 'username: %s' to backend config\n", username)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("  2. Test the connection: gosynctasks %s\n", backendName)

                        return nil</span>
                },
        }

        <span class="cov0" title="0">cmd.Flags().BoolVar(&amp;promptPassword, "prompt", false, "Prompt for password interactively (recommended)")

        return cmd</span>
}

func newCredentialsGetCmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "get &lt;backend&gt; [username]",
                Short: "Check credential status for a backend",
                Long: `Check which credential source is being used for a backend.

This command shows where credentials are found (keyring, environment, or config URL)
but does not display the actual password for security reasons.

Examples:
  # Check credentials for backend
  gosynctasks credentials get nextcloud myuser

  # Use username from config
  gosynctasks credentials get nextcloud`,
                Args: cobra.RangeArgs(1, 2),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        backendName := args[0]

                        // Get backend config
                        cfg := config.GetConfig()
                        backendConfig, exists := cfg.Backends[backendName]
                        if !exists </span><span class="cov0" title="0">{
                                return fmt.Errorf("backend %q not found in configuration", backendName)
                        }</span>

                        // Determine username
                        <span class="cov0" title="0">var username string
                        if len(args) &gt;= 2 </span><span class="cov0" title="0">{
                                username = args[1]
                        }</span> else<span class="cov0" title="0"> if backendConfig.Username != "" </span><span class="cov0" title="0">{
                                username = backendConfig.Username
                        }</span>

                        // Try to resolve credentials
                        <span class="cov0" title="0">resolver := credentials.NewResolver()
                        creds, err := resolver.ResolveWithConfig(backendName, username, backendConfig.Host, backendConfig.URL)

                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf(" No credentials found for backend %q\n", backendName)
                                fmt.Println("\nAvailable options:")
                                fmt.Println("  1. Store in keyring:")
                                fmt.Printf("     gosynctasks credentials set %s &lt;username&gt; --prompt\n", backendName)
                                fmt.Println("  2. Set environment variables:")
                                fmt.Printf("     export GOSYNCTASKS_%s_USERNAME=&lt;username&gt;\n", strings.ToUpper(strings.ReplaceAll(backendName, "-", "_")))
                                fmt.Printf("     export GOSYNCTASKS_%s_PASSWORD=&lt;password&gt;\n", strings.ToUpper(strings.ReplaceAll(backendName, "-", "_")))
                                fmt.Println("  3. Add to config URL (not recommended):")
                                fmt.Printf("     url: \"nextcloud://username:password@host\"\n")
                                return err
                        }</span>

                        <span class="cov0" title="0">fmt.Printf(" Credentials found for backend %q\n", backendName)
                        fmt.Printf("  Username: %s\n", creds.Username)
                        fmt.Printf("  Source: %s\n", creds.Source)
                        if creds.Host != "" </span><span class="cov0" title="0">{
                                fmt.Printf("  Host: %s\n", creds.Host)
                        }</span>

                        <span class="cov0" title="0">switch creds.Source </span>{
                        case credentials.SourceKeyring:<span class="cov0" title="0">
                                fmt.Println("\n Using secure keyring storage (recommended)")</span>
                        case credentials.SourceEnv:<span class="cov0" title="0">
                                fmt.Println("\n Using environment variables")
                                fmt.Println("  Consider using keyring for better security:")
                                fmt.Printf("    gosynctasks credentials set %s %s --prompt\n", backendName, creds.Username)</span>
                        case credentials.SourceURL:<span class="cov0" title="0">
                                fmt.Println("\n Using credentials from config URL (not recommended)")
                                fmt.Println("  Consider migrating to keyring:")
                                fmt.Printf("    gosynctasks credentials set %s %s --prompt\n", backendName, creds.Username)
                                fmt.Println("  Then update config to remove credentials from URL")</span>
                        }

                        <span class="cov0" title="0">return nil</span>
                },
        }

        <span class="cov0" title="0">return cmd</span>
}

func newCredentialsDeleteCmd() *cobra.Command <span class="cov0" title="0">{
        var force bool

        cmd := &amp;cobra.Command{
                Use:   "delete &lt;backend&gt; [username]",
                Short: "Remove credentials from system keyring",
                Long: `Remove stored credentials from the system keyring.

This only removes credentials from the keyring. Credentials in environment
variables or config file URL are not affected.

Examples:
  # Delete credentials (with confirmation)
  gosynctasks credentials delete nextcloud myuser

  # Delete credentials (skip confirmation)
  gosynctasks credentials delete nextcloud myuser --force

  # Use username from config
  gosynctasks credentials delete nextcloud`,
                Args: cobra.RangeArgs(1, 2),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        backendName := args[0]

                        // Get backend config
                        cfg := config.GetConfig()
                        backendConfig, exists := cfg.Backends[backendName]
                        if !exists </span><span class="cov0" title="0">{
                                return fmt.Errorf("backend %q not found in configuration", backendName)
                        }</span>

                        // Determine username
                        <span class="cov0" title="0">var username string
                        if len(args) &gt;= 2 </span><span class="cov0" title="0">{
                                username = args[1]
                        }</span> else<span class="cov0" title="0"> if backendConfig.Username != "" </span><span class="cov0" title="0">{
                                username = backendConfig.Username
                        }</span> else<span class="cov0" title="0"> {
                                return fmt.Errorf("username is required (not found in config for backend %q)", backendName)
                        }</span>

                        // Confirm deletion unless --force
                        <span class="cov0" title="0">if !force </span><span class="cov0" title="0">{
                                fmt.Printf("Delete credentials for %s@%s from keyring? [y/N]: ", username, backendName)
                                var response string
                                n, err := fmt.Scanln(&amp;response)
                                if err != nil </span><span class="cov0" title="0">{
                                                fmt.Println("Error reading input:", err)
                                                return nil
                                }</span>
                                <span class="cov0" title="0">if n == 0 </span><span class="cov0" title="0">{
                                                fmt.Println("No input was provided")
                                                return nil
                                }</span>
                                <span class="cov0" title="0">response = strings.ToLower(strings.TrimSpace(response))
                                if response != "y" &amp;&amp; response != "yes" </span><span class="cov0" title="0">{
                                        fmt.Println("Cancelled")
                                        return nil
                                }</span>
                        }

                        // Delete from keyring
                        <span class="cov0" title="0">if err := credentials.Delete(backendName, username); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">fmt.Printf(" Credentials removed for %s@%s\n", username, backendName)
                        fmt.Println("\n Note: This only removed keyring credentials.")
                        fmt.Println("  Environment variables and config URL credentials are not affected.")

                        return nil</span>
                },
        }

        <span class="cov0" title="0">cmd.Flags().BoolVar(&amp;force, "force", false, "Skip confirmation prompt")

        return cmd</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package main

import (
        "fmt"
        "gosynctasks/backend"
        "gosynctasks/internal/operations"
        "gosynctasks/internal/utils"

        "github.com/spf13/cobra"
)

// newListCmd creates the list management command with all subcommands
func newListCmd() *cobra.Command <span class="cov0" title="0">{
        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "Manage task lists",
                Long: `Manage task lists (create, delete, rename, info).

Task lists are collections/categories of tasks. In Nextcloud, these are
calendars that support VTODO components. In Git backend, these are
markdown headers (##).

Examples:
  gosynctasks list                                      # Show all lists (simple)
  gosynctasks list create "Work Tasks"                  # Create new list
  gosynctasks list create "Project" -d "Tasks for XYZ"  # With description
  gosynctasks list create "Urgent" --color "#ff0000"    # With color (Nextcloud)

  gosynctasks list delete "Old Tasks"                   # Delete list (with confirmation)
  gosynctasks list delete "Archive" --force             # Skip confirmation

  gosynctasks list rename "Old Name" "New Name"         # Rename list

  gosynctasks list info "Work Tasks"                    # Show list details
  gosynctasks list info --all                           # Show all lists with details
  gosynctasks list info "Work Tasks" --json             # JSON output`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        // Default action: show all lists (simple view)
                        taskLists := application.GetTaskLists()
                        if len(taskLists) == 0 </span><span class="cov0" title="0">{
                                fmt.Println("No task lists found.")
                                return nil
                        }</span>

                        <span class="cov0" title="0">fmt.Println("\nAvailable task lists:")
                        for _, list := range taskLists </span><span class="cov0" title="0">{
                                if list.Description != "" </span><span class="cov0" title="0">{
                                        fmt.Printf("   %s - %s\n", list.Name, list.Description)
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("   %s\n", list.Name)
                                }</span>
                        }
                        <span class="cov0" title="0">fmt.Println()
                        return nil</span>
                },
        }

        // Add subcommands
        <span class="cov0" title="0">listCmd.AddCommand(newListCreateCmd())
        listCmd.AddCommand(newListDeleteCmd())
        listCmd.AddCommand(newListRenameCmd())
        listCmd.AddCommand(newListInfoCmd())
        listCmd.AddCommand(newListTrashCmd())

        return listCmd</span>
}

// newListCreateCmd creates the 'list create' command
func newListCreateCmd() *cobra.Command <span class="cov0" title="0">{
        var description string
        var color string

        cmd := &amp;cobra.Command{
                Use:   "create &lt;name&gt;",
                Short: "Create a new task list",
                Long: `Create a new task list with the given name.

For Nextcloud backend, this creates a new calendar that supports VTODO.
For Git backend, this creates a new header (##) in the markdown file.

The color parameter is Nextcloud-specific and will be ignored by other backends.`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        name := args[0]

                        // Get task manager from application
                        taskManager := application.GetTaskManager()
                        if taskManager == nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("task manager not initialized")
                        }</span>

                        // Create the list
                        <span class="cov0" title="0">listID, err := taskManager.CreateTaskList(name, description, color)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create list: %w", err)
                        }</span>

                        // Clear cache
                        <span class="cov0" title="0">application.RefreshTaskListsOrWarn()

                        fmt.Printf("List '%s' created successfully (ID: %s)\n", name, listID)
                        return nil</span>
                },
        }

        <span class="cov0" title="0">cmd.Flags().StringVarP(&amp;description, "description", "d", "", "List description")
        cmd.Flags().StringVar(&amp;color, "color", "", "List color in hex format (e.g., #ff0000) - Nextcloud only")

        return cmd</span>
}

// newListDeleteCmd creates the 'list delete' command
func newListDeleteCmd() *cobra.Command <span class="cov0" title="0">{
        var force bool

        cmd := &amp;cobra.Command{
                Use:   "delete &lt;name&gt;",
                Short: "Delete a task list",
                Long: `Delete a task list and all tasks within it.

By default, prompts for confirmation showing the task count.
Use --force to skip the confirmation prompt.

WARNING: This permanently deletes the list and all its tasks.`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        name := args[0]

                        // Get task manager from application
                        taskManager := application.GetTaskManager()
                        if taskManager == nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("task manager not initialized")
                        }</span>

                        // Find the list by name
                        <span class="cov0" title="0">taskLists := application.GetTaskLists()
                        listID, err := operations.FindListByName(taskLists, name)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Get task count
                        <span class="cov0" title="0">var taskCount int
                        tasks, err := taskManager.GetTasks(listID, nil)
                        if err == nil </span><span class="cov0" title="0">{
                                taskCount = len(tasks)
                        }</span>

                        // Confirm deletion unless --force
                        <span class="cov0" title="0">if !force </span><span class="cov0" title="0">{
                                fmt.Printf("This will delete the list '%s' and all %d tasks in it.\n", name, taskCount)
                                confirmed, err := utils.PromptConfirmation("Are you sure?")
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">if !confirmed </span><span class="cov0" title="0">{
                                        fmt.Println("Deletion cancelled.")
                                        return nil
                                }</span>
                        }

                        // Delete the list
                        <span class="cov0" title="0">if err := taskManager.DeleteTaskList(listID); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to delete list: %w", err)
                        }</span>

                        // Clear cache
                        <span class="cov0" title="0">application.RefreshTaskListsOrWarn()

                        fmt.Printf("List '%s' deleted successfully.\n", name)
                        return nil</span>
                },
        }

        <span class="cov0" title="0">cmd.Flags().BoolVarP(&amp;force, "force", "f", false, "Skip confirmation prompt")

        return cmd</span>
}

// newListRenameCmd creates the 'list rename' command
func newListRenameCmd() *cobra.Command <span class="cov0" title="0">{
        var force bool

        cmd := &amp;cobra.Command{
                Use:   "rename &lt;old-name&gt; &lt;new-name&gt;",
                Short: "Rename a task list",
                Long: `Rename a task list while preserving all tasks and metadata.

The new name must not already exist.
By default, prompts for confirmation.`,
                Args: cobra.ExactArgs(2),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        oldName := args[0]
                        newName := args[1]

                        // Get task manager from application
                        taskManager := application.GetTaskManager()
                        if taskManager == nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("task manager not initialized")
                        }</span>

                        // Find the old list by name
                        <span class="cov0" title="0">taskLists := application.GetTaskLists()
                        listID, err := operations.FindListByName(taskLists, oldName)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Check if new name already exists
                        <span class="cov0" title="0">_, err = operations.FindListByName(taskLists, newName)
                        if err == nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("list '%s' already exists", newName)
                        }</span>

                        // Confirm rename unless --force
                        <span class="cov0" title="0">if !force </span><span class="cov0" title="0">{
                                confirmed, err := utils.PromptConfirmation(fmt.Sprintf("Rename list '%s' to '%s'?", oldName, newName))
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">if !confirmed </span><span class="cov0" title="0">{
                                        fmt.Println("Rename cancelled.")
                                        return nil
                                }</span>
                        }

                        // Rename the list
                        <span class="cov0" title="0">if err := taskManager.RenameTaskList(listID, newName); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to rename list: %w", err)
                        }</span>

                        // Clear cache
                        <span class="cov0" title="0">application.RefreshTaskListsOrWarn()

                        fmt.Printf("List renamed from '%s' to '%s' successfully.\n", oldName, newName)
                        return nil</span>
                },
        }

        <span class="cov0" title="0">cmd.Flags().BoolVarP(&amp;force, "force", "f", false, "Skip confirmation prompt")

        return cmd</span>
}

// newListInfoCmd creates the 'list info' command
func newListInfoCmd() *cobra.Command <span class="cov0" title="0">{
        var showAll bool
        var jsonOutput bool
        var yamlOutput bool

        cmd := &amp;cobra.Command{
                Use:   "info [name]",
                Short: "Show task list details",
                Long: `Display detailed information about a task list including:
- Name, description, and metadata
- Task count by status (TODO, DONE, PROCESSING, CANCELLED)
- Backend-specific information (URL, color, etc.)

Use --all to show info for all lists.
Use --json or --yaml for machine-readable output.`,
                Args: cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        // Get task manager from application
                        taskManager := application.GetTaskManager()
                        if taskManager == nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("task manager not initialized")
                        }</span>

                        <span class="cov0" title="0">taskLists := application.GetTaskLists()

                        // Determine which lists to show
                        var listsToShow []interface{}

                        if showAll </span><span class="cov0" title="0">{
                                // Show all lists
                                for _, list := range taskLists </span><span class="cov0" title="0">{
                                        info := buildListInfo(taskManager, list)
                                        listsToShow = append(listsToShow, info)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Show specific list
                                if len(args) == 0 </span><span class="cov0" title="0">{
                                        return fmt.Errorf("list name required (or use --all)")
                                }</span>

                                <span class="cov0" title="0">name := args[0]
                                list, err := operations.FindListByNameFull(taskLists, name)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">info := buildListInfo(taskManager, *list)
                                listsToShow = append(listsToShow, info)</span>
                        }

                        // Output in requested format
                        <span class="cov0" title="0">if jsonOutput </span><span class="cov0" title="0">{
                                if err := utils.OutputJSON(listsToShow); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        } else<span class="cov0" title="0"> if yamlOutput </span><span class="cov0" title="0">{
                                if err := utils.OutputYAML(listsToShow); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Human-readable format
                                for i, item := range listsToShow </span><span class="cov0" title="0">{
                                        if i &gt; 0 </span><span class="cov0" title="0">{
                                                fmt.Println()
                                        }</span>
                                        <span class="cov0" title="0">printListInfo(item.(map[string]interface{}))</span>
                                }
                        }

                        <span class="cov0" title="0">return nil</span>
                },
        }

        <span class="cov0" title="0">cmd.Flags().BoolVar(&amp;showAll, "all", false, "Show info for all lists")
        cmd.Flags().BoolVar(&amp;jsonOutput, "json", false, "Output in JSON format")
        cmd.Flags().BoolVar(&amp;yamlOutput, "yaml", false, "Output in YAML format")

        return cmd</span>
}

// buildListInfo builds a map of list information
func buildListInfo(tm backend.TaskManager, list backend.TaskList) map[string]interface{} <span class="cov0" title="0">{
        listMap := make(map[string]interface{})

        // Basic info
        listMap["name"] = list.Name
        listMap["id"] = list.ID
        listMap["description"] = list.Description
        listMap["url"] = list.URL
        listMap["color"] = list.Color
        listMap["ctag"] = list.CTags

        // Get tasks to count them
        tasks, err := tm.GetTasks(list.ID, nil)
        if err != nil </span><span class="cov0" title="0">{
                listMap["task_count"] = 0
                listMap["tasks_by_status"] = map[string]int{}
                listMap["error"] = err.Error()
                return listMap
        }</span>

        // Count total and by status
        <span class="cov0" title="0">listMap["task_count"] = len(tasks)
        statusCounts := map[string]int{
                "TODO":       0,
                "DONE":       0,
                "PROCESSING": 0,
                "CANCELLED":  0,
        }

        for _, task := range tasks </span><span class="cov0" title="0">{
                // Convert backend status to display name
                displayStatus := tm.StatusToDisplayName(task.Status)
                statusCounts[displayStatus]++
        }</span>

        <span class="cov0" title="0">listMap["tasks_by_status"] = statusCounts

        return listMap</span>
}

// printListInfo prints list information in human-readable format
func printListInfo(info map[string]interface{}) <span class="cov0" title="0">{
        fmt.Printf("List: %s\n", info["name"])
        if id, ok := info["id"].(string); ok &amp;&amp; id != "" </span><span class="cov0" title="0">{
                fmt.Printf("ID: %s\n", id)
        }</span>
        <span class="cov0" title="0">if desc, ok := info["description"].(string); ok &amp;&amp; desc != "" </span><span class="cov0" title="0">{
                fmt.Printf("Description: %s\n", desc)
        }</span>

        <span class="cov0" title="0">if count, ok := info["task_count"].(int); ok </span><span class="cov0" title="0">{
                fmt.Printf("Total tasks: %d\n", count)
        }</span>

        <span class="cov0" title="0">if statusCounts, ok := info["tasks_by_status"].(map[string]int); ok </span><span class="cov0" title="0">{
                fmt.Println("Tasks by status:")
                for status, count := range statusCounts </span><span class="cov0" title="0">{
                        if count &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("  %s: %d\n", status, count)
                        }</span>
                }
        }

        // Print backend-specific info if available
        <span class="cov0" title="0">if url, ok := info["url"].(string); ok &amp;&amp; url != "" </span><span class="cov0" title="0">{
                fmt.Printf("URL: %s\n", url)
        }</span>
        <span class="cov0" title="0">if color, ok := info["color"].(string); ok &amp;&amp; color != "" </span><span class="cov0" title="0">{
                fmt.Printf("Color: %s\n", color)
        }</span>
        <span class="cov0" title="0">if ctag, ok := info["ctag"].(string); ok &amp;&amp; ctag != "" </span><span class="cov0" title="0">{
                fmt.Printf("CTag: %s\n", ctag)
        }</span>
}

// newListTrashCmd creates the 'list trash' command with subcommands
func newListTrashCmd() *cobra.Command <span class="cov0" title="0">{
        trashCmd := &amp;cobra.Command{
                Use:   "trash",
                Short: "Manage deleted task lists (trash)",
                Long: `View and manage task lists that have been deleted (moved to trash).

Subcommands:
  gosynctasks list trash              # Show all deleted lists
  gosynctasks list trash restore &lt;name&gt;  # Restore a deleted list
  gosynctasks list trash empty &lt;name&gt;    # Permanently delete a list from trash
  gosynctasks list trash empty --all     # Empty entire trash (dangerous!)`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        // Default action: show deleted lists
                        taskManager := application.GetTaskManager()
                        if taskManager == nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("task manager not initialized")
                        }</span>

                        // Get deleted lists
                        <span class="cov0" title="0">deletedLists, err := taskManager.GetDeletedTaskLists()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get deleted lists: %w", err)
                        }</span>

                        <span class="cov0" title="0">if len(deletedLists) == 0 </span><span class="cov0" title="0">{
                                fmt.Println("No deleted lists in trash.")
                                return nil
                        }</span>

                        <span class="cov0" title="0">fmt.Println("\nDeleted task lists (in trash):")
                        for _, list := range deletedLists </span><span class="cov0" title="0">{
                                deletedInfo := ""
                                if list.DeletedAt != "" </span><span class="cov0" title="0">{
                                        deletedInfo = fmt.Sprintf(" (deleted: %s)", list.DeletedAt)
                                }</span>

                                <span class="cov0" title="0">if list.Description != "" </span><span class="cov0" title="0">{
                                        fmt.Printf("   %s - %s%s\n", list.Name, list.Description, deletedInfo)
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("   %s%s\n", list.Name, deletedInfo)
                                }</span>
                        }
                        <span class="cov0" title="0">fmt.Println()
                        return nil</span>
                },
        }

        // Add subcommands
        <span class="cov0" title="0">trashCmd.AddCommand(newListTrashRestoreCmd())
        trashCmd.AddCommand(newListTrashEmptyCmd())

        return trashCmd</span>
}

// newListTrashRestoreCmd creates the 'list trash restore' command
func newListTrashRestoreCmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "restore &lt;name&gt;",
                Short: "Restore a deleted list from trash",
                Long: `Restore a task list from trash, bringing back all its tasks.

The list will be restored to its original state before deletion.`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        name := args[0]

                        // Get task manager from application
                        taskManager := application.GetTaskManager()
                        if taskManager == nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("task manager not initialized")
                        }</span>

                        // Find the list in trash by name
                        <span class="cov0" title="0">deletedLists, err := taskManager.GetDeletedTaskLists()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get deleted lists: %w", err)
                        }</span>

                        <span class="cov0" title="0">listID, err := operations.FindListByName(deletedLists, name)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("list '%s' not found in trash", name)
                        }</span>

                        // Restore the list
                        <span class="cov0" title="0">if err := taskManager.RestoreTaskList(listID); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to restore list: %w", err)
                        }</span>

                        // Clear cache
                        <span class="cov0" title="0">application.RefreshTaskListsOrWarn()

                        fmt.Printf("List '%s' restored successfully.\n", name)
                        return nil</span>
                },
        }

        <span class="cov0" title="0">return cmd</span>
}

// newListTrashEmptyCmd creates the 'list trash empty' command
func newListTrashEmptyCmd() *cobra.Command <span class="cov0" title="0">{
        var emptyAll bool
        var force bool

        cmd := &amp;cobra.Command{
                Use:   "empty [name]",
                Short: "Permanently delete a list from trash",
                Long: `Permanently delete a task list from trash. This operation is irreversible.

By default, prompts for confirmation.
Use --all to empty the entire trash (WARNING: very dangerous!).
Use --force to skip the confirmation prompt.

WARNING: This permanently and irreversibly deletes the list and all its tasks.`,
                Args: cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        // Get task manager from application
                        taskManager := application.GetTaskManager()
                        if taskManager == nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("task manager not initialized")
                        }</span>

                        // Get deleted lists
                        <span class="cov0" title="0">deletedLists, err := taskManager.GetDeletedTaskLists()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get deleted lists: %w", err)
                        }</span>

                        <span class="cov0" title="0">if len(deletedLists) == 0 </span><span class="cov0" title="0">{
                                fmt.Println("Trash is already empty.")
                                return nil
                        }</span>

                        // Determine which lists to delete
                        <span class="cov0" title="0">var listsToDelete []backend.TaskList

                        if emptyAll </span><span class="cov0" title="0">{
                                // Delete all lists in trash
                                listsToDelete = deletedLists
                        }</span> else<span class="cov0" title="0"> {
                                // Delete specific list
                                if len(args) == 0 </span><span class="cov0" title="0">{
                                        return fmt.Errorf("list name required (or use --all)")
                                }</span>

                                <span class="cov0" title="0">name := args[0]
                                list, err := operations.FindListByNameFull(deletedLists, name)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("list '%s' not found in trash", name)
                                }</span>
                                <span class="cov0" title="0">listsToDelete = append(listsToDelete, *list)</span>
                        }

                        // Confirm deletion unless --force
                        <span class="cov0" title="0">if !force </span><span class="cov0" title="0">{
                                if emptyAll </span><span class="cov0" title="0">{
                                        fmt.Printf("This will PERMANENTLY delete ALL %d lists in trash.\n", len(listsToDelete))
                                        fmt.Println("This operation is IRREVERSIBLE and will delete all tasks in these lists.")
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("This will PERMANENTLY delete the list '%s' from trash.\n", listsToDelete[0].Name)
                                        fmt.Println("This operation is IRREVERSIBLE and will delete all tasks in this list.")
                                }</span>
                                <span class="cov0" title="0">confirmed, err := utils.PromptConfirmation("Are you sure?")
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">if !confirmed </span><span class="cov0" title="0">{
                                        fmt.Println("Operation cancelled.")
                                        return nil
                                }</span>
                        }

                        // Delete the lists
                        <span class="cov0" title="0">deletedCount := 0
                        for _, list := range listsToDelete </span><span class="cov0" title="0">{
                                if err := taskManager.PermanentlyDeleteTaskList(list.ID); err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Warning: failed to delete '%s': %v\n", list.Name, err)
                                        continue</span>
                                }
                                <span class="cov0" title="0">deletedCount++</span>
                        }

                        // Clear cache
                        <span class="cov0" title="0">application.RefreshTaskListsOrWarn()

                        if emptyAll </span><span class="cov0" title="0">{
                                fmt.Printf("Successfully permanently deleted %d lists from trash.\n", deletedCount)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("List '%s' permanently deleted from trash.\n", listsToDelete[0].Name)
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                },
        }

        <span class="cov0" title="0">cmd.Flags().BoolVar(&amp;emptyAll, "all", false, "Empty entire trash (delete all lists permanently)")
        cmd.Flags().BoolVarP(&amp;force, "force", "f", false, "Skip confirmation prompt")

        return cmd</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package main

import (
        "gosynctasks/internal/app"
        "gosynctasks/internal/cli"
        "gosynctasks/internal/config"
        "log"
        "os"
        "os/signal"
        "syscall"

        "github.com/spf13/cobra"
)

var (
        configPath     string
        backendName    string
        listBackends   bool
        detectBackends bool
        application    *app.App
)

func main() <span class="cov0" title="0">{
        rootCmd := &amp;cobra.Command{
                Use:   "gosynctasks [list-name] [action] [task-summary]",
                Short: "Task synchronization tool",
                Long: `Task synchronization tool for managing tasks across different backends.

Actions (abbreviations in parentheses):
  get (g)       - List tasks from a task list (default action)
  add (a)       - Add a new task to a list
  update (u)    - Update an existing task by summary
  complete (c)  - Change task status by summary (defaults to DONE)
  delete (d)    - Delete a task by summary

Examples:
  gosynctasks                           # Interactive list selection, show tasks
  gosynctasks MyList                    # Show tasks from "MyList"
  gosynctasks MyList get                # Show tasks from "MyList" (g also works)
  gosynctasks MyList -s TODO,PROCESSING # Filter tasks by status

  gosynctasks MyList add "New task"     # Add a task to "MyList"
  gosynctasks MyList a "New task"       # Same using abbreviation
  gosynctasks MyList add                # Add a task (will prompt for summary)
  gosynctasks MyList add "Task" -d "Details" -p 1 -S done  # Add with options
  gosynctasks MyList add "Report" --due-date 2025-01-31 --start-date 2025-01-15  # With dates
  gosynctasks MyList add "Subtask" -P "Parent Task"  # Add subtask under parent
  gosynctasks MyList add "Fix bug" -P "Feature/Code"  # Path-based parent reference
  gosynctasks MyList add "parent/child/grandchild"  # Shorthand: auto-creates hierarchy
  gosynctasks MyList add -l "be a good/generous person"  # Use -l to disable path parsing

  gosynctasks MyList update "Buy groceries" -s DONE  # Update task status
  gosynctasks MyList u "groceries" --summary "Buy milk"  # Partial match + rename
  gosynctasks MyList update "task" -p 5              # Partial match + set priority
  gosynctasks MyList update "task" --due-date 2025-02-15  # Update due date

  gosynctasks MyList complete "Buy groceries"      # Mark as DONE (default)
  gosynctasks MyList c "groceries"

  gosynctasks MyList delete "Buy groceries"        # Delete a task
  gosynctasks MyList d "groceries"                 # Same using abbreviation

Config:
  --config .                            # Use ./gosynctasks/config.json
  --config /path/to/config.json         # Use specific config file
  --config /path/to/dir                 # Use /path/to/dir/config.json
`,
                PersistentPreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        // Set custom config path if specified
                        if configPath != "" </span><span class="cov0" title="0">{
                                config.SetCustomConfigPath(configPath)
                        }</span>

                        // Initialize app after config path is set
                        <span class="cov0" title="0">var err error
                        application, err = app.NewApp(backendName)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Handle --list-backends flag
                        <span class="cov0" title="0">if listBackends </span><span class="cov0" title="0">{
                                return application.ListBackends()
                        }</span>

                        // Handle --detect-backend flag
                        <span class="cov0" title="0">if detectBackends </span><span class="cov0" title="0">{
                                return application.DetectBackends()
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                },
                Args: cobra.MaximumNArgs(3),
                ValidArgsFunction: func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) <span class="cov0" title="0">{
                        if application == nil </span><span class="cov0" title="0">{
                                return []string{}, cobra.ShellCompDirectiveNoFileComp
                        }</span>
                        <span class="cov0" title="0">return cli.SmartCompletion(application.GetTaskLists())(cmd, args, toComplete)</span>
                },
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                        return application.Run(cmd, args)
                }</span>,
        }

        // Persistent flags (available to all commands)
        <span class="cov0" title="0">rootCmd.PersistentFlags().StringVar(&amp;configPath, "config", "", "config file path (default: $XDG_CONFIG_HOME/gosynctasks/config.json, use '.' for ./gosynctasks/config.json)")
        rootCmd.PersistentFlags().StringVar(&amp;backendName, "backend", "", "backend to use (overrides config default and auto-detection)")
        rootCmd.PersistentFlags().BoolVar(&amp;listBackends, "list-backends", false, "list all configured backends and exit")
        rootCmd.PersistentFlags().BoolVar(&amp;detectBackends, "detect-backend", false, "show auto-detected backends and exit")

        // Command flags
        rootCmd.Flags().StringArrayP("status", "s", []string{}, "filter by status (for get) or set status (for update): [T]ODO, [D]ONE, [P]ROCESSING, [C]ANCELLED")
        rootCmd.Flags().StringP("view", "v", "default", "view mode (default, all, or custom view name)")
        rootCmd.Flags().StringP("description", "d", "", "task description (for add/update)")
        rootCmd.Flags().IntP("priority", "p", 0, "task priority (for add/update, 0-9: 0=undefined, 1=highest, 9=lowest)")
        rootCmd.Flags().StringP("add-status", "S", "", "task status when adding (TODO/T, DONE/D, PROCESSING/P, CANCELLED/C)")
        rootCmd.Flags().String("summary", "", "task summary (for update)")
        rootCmd.Flags().String("due-date", "", "task due date (for add/update, format: YYYY-MM-DD, empty string to clear)")
        rootCmd.Flags().String("start-date", "", "task start date (for add/update, format: YYYY-MM-DD, empty string to clear)")
        rootCmd.Flags().StringP("parent", "P", "", "parent task reference (for add): task summary or path like 'Parent/Child'")
        rootCmd.Flags().BoolP("literal", "l", false, "treat task summary literally (for add): disable automatic path-based hierarchy creation")

        // Register flag value completion for status flags
        _ = rootCmd.RegisterFlagCompletionFunc("status", func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) </span><span class="cov0" title="0">{
                return []string{"TODO", "DONE", "PROCESSING", "CANCELLED"}, cobra.ShellCompDirectiveNoFileComp
        }</span>)
        <span class="cov0" title="0">_ = rootCmd.RegisterFlagCompletionFunc("add-status", func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) </span><span class="cov0" title="0">{
                return []string{"TODO", "DONE", "PROCESSING", "CANCELLED"}, cobra.ShellCompDirectiveNoFileComp
        }</span>)

        // Register view flag completion
        <span class="cov0" title="0">_ = rootCmd.RegisterFlagCompletionFunc("view", func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) </span><span class="cov0" title="0">{
                if application == nil </span><span class="cov0" title="0">{
                        return []string{"default", "all"}, cobra.ShellCompDirectiveNoFileComp
                }</span>
                <span class="cov0" title="0">viewNames, err := cli.ListViewNames()
                if err != nil </span><span class="cov0" title="0">{
                        return []string{"default", "all"}, cobra.ShellCompDirectiveNoFileComp
                }</span>
                <span class="cov0" title="0">return viewNames, cobra.ShellCompDirectiveNoFileComp</span>
        })

        // Add subcommands
        <span class="cov0" title="0">rootCmd.AddCommand(newViewCmd())
        rootCmd.AddCommand(newListCmd())
        rootCmd.AddCommand(newSyncCmd())
        rootCmd.AddCommand(newCredentialsCmd())

        // Set up graceful shutdown on Ctrl+C / SIGTERM
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)
        go func() </span><span class="cov0" title="0">{
                &lt;-sigChan
                if application != nil </span><span class="cov0" title="0">{
                        application.Shutdown()
                }</span>
                <span class="cov0" title="0">os.Exit(0)</span>
        }()

        // Execute command
        <span class="cov0" title="0">if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // Exit immediately - background sync runs in detached process
        // Operations are queued in sqlite and synced by background daemon
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package main

import (
        "fmt"
        "gosynctasks/backend"
        "gosynctasks/backend/sqlite"
        "gosynctasks/backend/sync"
        "gosynctasks/internal/config"
        "net"
        "net/url"
        "time"

        "github.com/spf13/cobra"
)

// newSyncCmd creates the sync command with all subcommands
func newSyncCmd() *cobra.Command <span class="cov0" title="0">{
        var fullSync bool
        var dryRun bool
        var listName string
        var quiet bool

        syncCmd := &amp;cobra.Command{
                Use:   "sync",
                Short: "Synchronize tasks with remote backend",
                Long: `Synchronize local SQLite cache with remote backend (e.g., Nextcloud).

The sync command performs bidirectional synchronization:
- Pull: Download remote changes to local cache
- Push: Upload local changes to remote backend

Conflict resolution is handled according to the configured strategy
(server_wins, local_wins, merge, or keep_both).

Examples:
  gosynctasks sync                  # Perform sync
  gosynctasks sync --full          # Force full re-sync (ignore CTags)
  gosynctasks sync --dry-run       # Preview changes without applying
  gosynctasks sync -l "Work"       # Sync specific list only

  gosynctasks sync status          # Show sync status
  gosynctasks sync queue           # Show pending operations
  gosynctasks sync queue clear     # Clear failed operations`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        // Get sync configuration
                        cfg := config.GetConfig()
                        if cfg.Sync == nil || !cfg.Sync.Enabled </span><span class="cov0" title="0">{
                                return fmt.Errorf("sync is not enabled in configuration")
                        }</span>

                        // Get backends for sync
                        <span class="cov0" title="0">localBackend, remoteBackend, err := getSyncBackends(cfg)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Check if offline
                        <span class="cov0" title="0">isOffline, offlineReason := isBackendOffline(remoteBackend)
                        if isOffline </span><span class="cov0" title="0">{
                                if !quiet </span><span class="cov0" title="0">{
                                        fmt.Printf(" Offline mode: %s\n", offlineReason)
                                        fmt.Println("Working with local cache. Changes will be synced when online.")
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        }

                        // Create sync manager
                        <span class="cov0" title="0">strategy := sync.ConflictResolutionStrategy(cfg.Sync.ConflictResolution)
                        if strategy == "" </span><span class="cov0" title="0">{
                                strategy = sync.ServerWins // Default
                        }</span>

                        <span class="cov0" title="0">sm := sync.NewSyncManager(localBackend, remoteBackend, strategy)

                        if dryRun </span><span class="cov0" title="0">{
                                if !quiet </span><span class="cov0" title="0">{
                                        fmt.Println("Dry run mode - no changes will be made")
                                }</span>
                                // TODO: Implement dry run preview
                                <span class="cov0" title="0">return nil</span>
                        }

                        // Perform sync
                        <span class="cov0" title="0">if !quiet </span><span class="cov0" title="0">{
                                fmt.Println("Syncing...")
                        }</span>
                        <span class="cov0" title="0">var result *sync.SyncResult
                        if fullSync </span><span class="cov0" title="0">{
                                result, err = sm.FullSync()
                        }</span> else<span class="cov0" title="0"> {
                                result, err = sm.Sync()
                        }</span>

                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                if !quiet </span><span class="cov0" title="0">{
                                        return fmt.Errorf("sync failed: %w", err)
                                }</span>
                                <span class="cov0" title="0">return nil</span> // Silent fail in background
                        }

                        // Display results
                        <span class="cov0" title="0">if !quiet </span><span class="cov0" title="0">{
                                printSyncResult(result)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                },
        }

        <span class="cov0" title="0">syncCmd.Flags().BoolVar(&amp;fullSync, "full", false, "Force full re-sync (ignore CTags)")
        syncCmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Preview changes without applying")
        syncCmd.Flags().StringVarP(&amp;listName, "list", "l", "", "Sync specific list only")
        syncCmd.Flags().BoolVar(&amp;quiet, "quiet", false, "Suppress output (for background sync)")

        // Add subcommands
        syncCmd.AddCommand(newSyncStatusCmd())
        syncCmd.AddCommand(newSyncQueueCmd())

        return syncCmd</span>
}

// newSyncStatusCmd creates the 'sync status' command
func newSyncStatusCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "status",
                Short: "Show sync status",
                Long: `Display current synchronization status including:
- Last sync time
- Number of tasks synced
- Pending operations
- Locally modified tasks
- Offline/online status`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        cfg := config.GetConfig()
                        if cfg.Sync == nil || !cfg.Sync.Enabled </span><span class="cov0" title="0">{
                                fmt.Println("Sync is not enabled in configuration")
                                return nil
                        }</span>

                        // Get backends
                        <span class="cov0" title="0">localBackend, remoteBackend, err := getSyncBackends(cfg)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Check connection status
                        <span class="cov0" title="0">isOffline, offlineReason := isBackendOffline(remoteBackend)

                        // Get sync stats
                        sm := sync.NewSyncManager(localBackend, remoteBackend, sync.ServerWins)
                        stats, err := sm.GetSyncStats()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get sync stats: %w", err)
                        }</span>

                        // Display status
                        <span class="cov0" title="0">fmt.Println("\n=== Sync Status ===")
                        if isOffline </span><span class="cov0" title="0">{
                                fmt.Printf("Connection: Offline (%s)\n", offlineReason)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println("Connection: Online")
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("Local tasks: %d\n", stats.LocalTasks)
                        fmt.Printf("Local lists: %d\n", stats.LocalLists)
                        fmt.Printf("Pending operations: %d\n", stats.PendingOperations)
                        fmt.Printf("Locally modified: %d\n", stats.LocallyModified)
                        fmt.Printf("Strategy: %s\n", cfg.Sync.ConflictResolution)

                        // Get last sync time
                        lastSync, err := getLastSyncTime(localBackend)
                        if err == nil &amp;&amp; !lastSync.IsZero() </span><span class="cov0" title="0">{
                                timeSince := time.Since(lastSync)
                                fmt.Printf("Last sync: %s ago\n", formatDuration(timeSince))
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println("Last sync: Never")
                        }</span>

                        <span class="cov0" title="0">fmt.Println()
                        return nil</span>
                },
        }
}

// newSyncQueueCmd creates the 'sync queue' command
func newSyncQueueCmd() *cobra.Command <span class="cov0" title="0">{
        queueCmd := &amp;cobra.Command{
                Use:   "queue",
                Short: "Manage sync queue",
                Long:  `Display and manage pending sync operations.`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        cfg := config.GetConfig()
                        if cfg.Sync == nil || !cfg.Sync.Enabled </span><span class="cov0" title="0">{
                                return fmt.Errorf("sync is not enabled")
                        }</span>

                        <span class="cov0" title="0">localBackend, _, err := getSyncBackends(cfg)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Get pending operations
                        <span class="cov0" title="0">ops, err := localBackend.GetPendingSyncOperations()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get pending operations: %w", err)
                        }</span>

                        <span class="cov0" title="0">if len(ops) == 0 </span><span class="cov0" title="0">{
                                fmt.Println("No pending operations")
                                return nil
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("\nPending Operations (%d):\n\n", len(ops))
                        for _, op := range ops </span><span class="cov0" title="0">{
                                fmt.Printf("  %s: %s (list: %s)\n", op.Operation, op.TaskUID, op.ListID)
                                fmt.Printf("    Created: %s\n", op.CreatedAt.Format("2006-01-02 15:04:05"))
                                if op.RetryCount &gt; 0 </span><span class="cov0" title="0">{
                                        fmt.Printf("    Retries: %d\n", op.RetryCount)
                                }</span>
                                <span class="cov0" title="0">if op.LastError != "" </span><span class="cov0" title="0">{
                                        fmt.Printf("    Error: %s\n", op.LastError)
                                }</span>
                                <span class="cov0" title="0">fmt.Println()</span>
                        }

                        <span class="cov0" title="0">return nil</span>
                },
        }

        <span class="cov0" title="0">queueCmd.AddCommand(newSyncQueueClearCmd())
        queueCmd.AddCommand(newSyncQueueRetryCmd())

        return queueCmd</span>
}

// newSyncQueueClearCmd creates the 'sync queue clear' command
func newSyncQueueClearCmd() *cobra.Command <span class="cov0" title="0">{
        var failed bool

        cmd := &amp;cobra.Command{
                Use:   "clear",
                Short: "Clear sync queue",
                Long:  `Clear pending sync operations. Use --failed to clear only failed operations.`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        cfg := config.GetConfig()
                        if cfg.Sync == nil || !cfg.Sync.Enabled </span><span class="cov0" title="0">{
                                return fmt.Errorf("sync is not enabled")
                        }</span>

                        <span class="cov0" title="0">localBackend, _, err := getSyncBackends(cfg)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Get pending operations
                        <span class="cov0" title="0">ops, err := localBackend.GetPendingSyncOperations()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get pending operations: %w", err)
                        }</span>

                        <span class="cov0" title="0">cleared := 0
                        for _, op := range ops </span><span class="cov0" title="0">{
                                if failed &amp;&amp; op.RetryCount == 0 </span><span class="cov0" title="0">{
                                        continue</span> // Skip non-failed operations
                                }

                                <span class="cov0" title="0">err := localBackend.RemoveSyncOperation(op.TaskUID, op.Operation)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Warning: failed to remove operation for %s: %v\n", op.TaskUID, err)
                                        continue</span>
                                }
                                <span class="cov0" title="0">cleared++</span>
                        }

                        <span class="cov0" title="0">fmt.Printf("Cleared %d operations\n", cleared)
                        return nil</span>
                },
        }

        <span class="cov0" title="0">cmd.Flags().BoolVar(&amp;failed, "failed", false, "Clear only failed operations")
        return cmd</span>
}

// newSyncQueueRetryCmd creates the 'sync queue retry' command
func newSyncQueueRetryCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "retry",
                Short: "Retry failed sync operations",
                Long:  `Retry all failed sync operations by resetting their retry count.`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        cfg := config.GetConfig()
                        if cfg.Sync == nil || !cfg.Sync.Enabled </span><span class="cov0" title="0">{
                                return fmt.Errorf("sync is not enabled")
                        }</span>

                        <span class="cov0" title="0">localBackend, _, err := getSyncBackends(cfg)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Get failed operations
                        <span class="cov0" title="0">ops, err := localBackend.GetPendingSyncOperations()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get pending operations: %w", err)
                        }</span>

                        <span class="cov0" title="0">retried := 0
                        for _, op := range ops </span><span class="cov0" title="0">{
                                if op.RetryCount == 0 </span><span class="cov0" title="0">{
                                        continue</span> // Skip non-failed
                                }

                                // Reset retry count by updating database directly
                                <span class="cov0" title="0">db, err := localBackend.GetDB()
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">_, err = db.Exec("UPDATE sync_queue SET retry_count = 0, last_error = '' WHERE id = ?", op.ID)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Warning: failed to reset retry for operation %d: %v\n", op.ID, err)
                                        continue</span>
                                }
                                <span class="cov0" title="0">retried++</span>
                        }

                        <span class="cov0" title="0">fmt.Printf("Reset %d failed operations for retry\n", retried)
                        return nil</span>
                },
        }
}

// Helper functions

// getSyncBackends returns the local and remote backends for sync
func getSyncBackends(cfg *config.Config) (*sqlite.SQLiteBackend, backend.TaskManager, error) <span class="cov0" title="0">{
        if cfg.Sync.LocalBackend == "" </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("local_backend not configured for sync")
        }</span>
        <span class="cov0" title="0">if cfg.Sync.RemoteBackend == "" </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("remote_backend not configured for sync")
        }</span>

        // Get local backend
        <span class="cov0" title="0">localCfg, err := cfg.GetBackend(cfg.Sync.LocalBackend)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to get local backend config: %w", err)
        }</span>

        <span class="cov0" title="0">if localCfg.Type != "sqlite" </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("local backend must be SQLite, got %s", localCfg.Type)
        }</span>

        <span class="cov0" title="0">local, err := sqlite.NewSQLiteBackend(*localCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to create local backend: %w", err)
        }</span>

        // Get remote backend
        <span class="cov0" title="0">remoteCfg, err := cfg.GetBackend(cfg.Sync.RemoteBackend)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to get remote backend config: %w", err)
        }</span>

        <span class="cov0" title="0">remote, err := remoteCfg.TaskManager()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to create remote backend: %w", err)
        }</span>

        <span class="cov0" title="0">return local, remote, nil</span>
}

// isBackendOffline checks if the backend is reachable
func isBackendOffline(taskManager backend.TaskManager) (bool, string) <span class="cov0" title="0">{
        // Try to get task lists with timeout
        done := make(chan error, 1)
        go func() </span><span class="cov0" title="0">{
                _, err := taskManager.GetTaskLists()
                done &lt;- err
        }</span>()

        <span class="cov0" title="0">select </span>{
        case err := &lt;-done:<span class="cov0" title="0">
                if err == nil </span><span class="cov0" title="0">{
                        return false, ""
                }</span>

                // Analyze error to determine offline reason
                <span class="cov0" title="0">if isNetworkError(err) </span><span class="cov0" title="0">{
                        return true, "Network unreachable"
                }</span>
                <span class="cov0" title="0">if isDNSError(err) </span><span class="cov0" title="0">{
                        return true, "DNS resolution failed"
                }</span>
                <span class="cov0" title="0">if isConnectionRefused(err) </span><span class="cov0" title="0">{
                        return true, "Connection refused"
                }</span>
                <span class="cov0" title="0">if isTimeout(err) </span><span class="cov0" title="0">{
                        return true, "Connection timeout"
                }</span>

                // Unknown error - assume online but backend issue
                <span class="cov0" title="0">return false, ""</span>

        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0">
                return true, "Connection timeout"</span>
        }
}

// isNetworkError checks if error is a network error
func isNetworkError(err error) bool <span class="cov0" title="0">{
        if _, ok := err.(*net.OpError); ok </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if _, ok := err.(*url.Error); ok </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

// isDNSError checks if error is a DNS resolution error
func isDNSError(err error) bool <span class="cov0" title="0">{
        if dnsErr, ok := err.(*net.DNSError); ok </span><span class="cov0" title="0">{
                return dnsErr != nil
        }</span>
        <span class="cov0" title="0">return false</span>
}

// isConnectionRefused checks if error is connection refused
func isConnectionRefused(err error) bool <span class="cov0" title="0">{
        if opErr, ok := err.(*net.OpError); ok </span><span class="cov0" title="0">{
                return opErr.Op == "dial"
        }</span>
        <span class="cov0" title="0">return false</span>
}

// isTimeout checks if error is a timeout
func isTimeout(err error) bool <span class="cov0" title="0">{
        if netErr, ok := err.(net.Error); ok </span><span class="cov0" title="0">{
                return netErr.Timeout()
        }</span>
        <span class="cov0" title="0">if urlErr, ok := err.(*url.Error); ok </span><span class="cov0" title="0">{
                return urlErr.Timeout()
        }</span>
        <span class="cov0" title="0">return false</span>
}

// printSyncResult displays sync result in a user-friendly format
func printSyncResult(result *sync.SyncResult) <span class="cov0" title="0">{
        fmt.Println("\n=== Sync Complete ===")
        fmt.Printf("Pulled tasks: %d\n", result.PulledTasks)
        fmt.Printf("Pushed tasks: %d\n", result.PushedTasks)

        if result.ConflictsFound &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Conflicts found: %d\n", result.ConflictsFound)
                fmt.Printf("Conflicts resolved: %d\n", result.ConflictsResolved)
        }</span>

        <span class="cov0" title="0">if len(result.Errors) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\n Errors: %d\n", len(result.Errors))
                for _, err := range result.Errors </span><span class="cov0" title="0">{
                        fmt.Printf("  - %v\n", err)
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("Duration: %s\n", result.Duration.Round(time.Millisecond))
        fmt.Println()</span>
}

// getLastSyncTime retrieves the most recent sync timestamp
func getLastSyncTime(local *sqlite.SQLiteBackend) (time.Time, error) <span class="cov0" title="0">{
        db, err := local.GetDB()
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>

        <span class="cov0" title="0">var lastSync int64
        err = db.QueryRow("SELECT MAX(last_full_sync) FROM list_sync_metadata").Scan(&amp;lastSync)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>

        <span class="cov0" title="0">if lastSync == 0 </span><span class="cov0" title="0">{
                return time.Time{}, nil
        }</span>

        <span class="cov0" title="0">return time.Unix(lastSync, 0), nil</span>
}

// formatDuration formats a duration in a human-readable way
func formatDuration(d time.Duration) string <span class="cov0" title="0">{
        if d &lt; time.Minute </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d seconds", int(d.Seconds()))
        }</span>
        <span class="cov0" title="0">if d &lt; time.Hour </span><span class="cov0" title="0">{
                minutes := int(d.Minutes())
                if minutes == 1 </span><span class="cov0" title="0">{
                        return "1 minute"
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%d minutes", minutes)</span>
        }
        <span class="cov0" title="0">if d &lt; 24*time.Hour </span><span class="cov0" title="0">{
                hours := int(d.Hours())
                if hours == 1 </span><span class="cov0" title="0">{
                        return "1 hour"
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%d hours", hours)</span>
        }
        <span class="cov0" title="0">days := int(d.Hours() / 24)
        if days == 1 </span><span class="cov0" title="0">{
                return "1 day"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%d days", days)</span>
}

// Auto-sync functionality

// shouldAutoSync checks if auto-sync should run
func shouldAutoSync(cfg *config.Config) bool <span class="cov0" title="0">{
        if cfg.Sync == nil || !cfg.Sync.Enabled || !cfg.Sync.AutoSync </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if enough time has passed since last sync
        <span class="cov0" title="0">if cfg.Sync.SyncInterval &lt;= 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        // TODO: Implement last sync time checking
        <span class="cov0" title="0">return false</span>
}

// performAutoSync runs auto-sync in the background
func performAutoSync(cfg *config.Config) <span class="cov0" title="0">{
        if !shouldAutoSync(cfg) </span><span class="cov0" title="0">{
                return
        }</span>

        // Run sync in background (non-blocking)
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                localBackend, remoteBackend, err := getSyncBackends(cfg)
                if err != nil </span><span class="cov0" title="0">{
                        return // Silently fail for auto-sync
                }</span>

                // Check if online
                <span class="cov0" title="0">isOffline, _ := isBackendOffline(remoteBackend)
                if isOffline </span><span class="cov0" title="0">{
                        return // Skip auto-sync if offline
                }</span>

                <span class="cov0" title="0">strategy := sync.ConflictResolutionStrategy(cfg.Sync.ConflictResolution)
                if strategy == "" </span><span class="cov0" title="0">{
                        strategy = sync.ServerWins
                }</span>

                <span class="cov0" title="0">sm := sync.NewSyncManager(localBackend, remoteBackend, strategy)
                _, _ = sm.Sync()</span>
        }()
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package main

import (
        "fmt"
        "gosynctasks/internal/utils"
        "gosynctasks/internal/views"
        "gosynctasks/internal/views/builder"
        "os"
        "os/exec"
        "strings"

        "github.com/spf13/cobra"
        "gopkg.in/yaml.v3"
)

// newViewCmd creates the view management command with all subcommands
func newViewCmd() *cobra.Command <span class="cov0" title="0">{
        viewCmd := &amp;cobra.Command{
                Use:   "view",
                Short: "Manage custom views",
                Long: `Manage custom view configurations for task display.

Views control how tasks are formatted and displayed, including which fields
to show, their order, formatting options, and colors.

Examples:
  gosynctasks view list                    # List all views
  gosynctasks view show minimal            # Show view configuration
  gosynctasks view create myview           # Create from editor
  gosynctasks view create myview --template minimal  # Create from template
  gosynctasks view edit myview             # Edit in $EDITOR
  gosynctasks view delete myview           # Delete user view
  gosynctasks view copy minimal custom     # Copy view
  gosynctasks view validate myview         # Validate configuration`,
        }

        // Add subcommands
        viewCmd.AddCommand(newViewListCmd())
        viewCmd.AddCommand(newViewShowCmd())
        viewCmd.AddCommand(newViewCreateCmd())
        viewCmd.AddCommand(newViewEditCmd())
        viewCmd.AddCommand(newViewDeleteCmd())
        viewCmd.AddCommand(newViewCopyCmd())
        viewCmd.AddCommand(newViewValidateCmd())

        return viewCmd
}</span>

// newViewListCmd creates the 'view list' command
func newViewListCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "list",
                Short: "List all available views",
                Long:  "List all available views including built-in and user-created views.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        viewNames, err := views.ListViews()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to list views: %w", err)
                        }</span>

                        <span class="cov0" title="0">if len(viewNames) == 0 </span><span class="cov0" title="0">{
                                fmt.Println("No views found.")
                                return nil
                        }</span>

                        <span class="cov0" title="0">fmt.Println("Available views:")
                        fmt.Println()

                        for _, name := range viewNames </span><span class="cov0" title="0">{
                                // Try to load view to get description
                                view, err := views.ResolveView(name)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("  %-20s (error loading)\n", name)
                                        continue</span>
                                }

                                // Mark built-in views
                                <span class="cov0" title="0">marker := ""
                                if views.IsBuiltInView(name) </span><span class="cov0" title="0">{
                                        marker = " [built-in]"
                                }</span>

                                <span class="cov0" title="0">desc := view.Description
                                if desc == "" </span><span class="cov0" title="0">{
                                        desc = "No description"
                                }</span>

                                <span class="cov0" title="0">fmt.Printf("  %-20s %s%s\n", name, desc, marker)</span>
                        }

                        <span class="cov0" title="0">return nil</span>
                },
        }
}

// newViewShowCmd creates the 'view show' command
func newViewShowCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "show &lt;view-name&gt;",
                Short: "Show view configuration",
                Long:  "Display the complete configuration of a view including fields, order, and display options.",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        viewName := args[0]

                        view, err := views.ResolveView(viewName)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("view '%s' not found: %w", viewName, err)
                        }</span>

                        // Marshal to YAML for display
                        <span class="cov0" title="0">data, err := utils.MarshalYAML(view)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("View: %s\n", view.Name)
                        if views.IsBuiltInView(viewName) </span><span class="cov0" title="0">{
                                fmt.Println("Type: Built-in")
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println("Type: User-defined")
                        }</span>
                        <span class="cov0" title="0">fmt.Println()
                        fmt.Println(string(data))

                        return nil</span>
                },
        }
}

// newViewCreateCmd creates the 'view create' command
func newViewCreateCmd() *cobra.Command <span class="cov0" title="0">{
        var templateName string
        var interactive bool

        cmd := &amp;cobra.Command{
                Use:   "create &lt;view-name&gt;",
                Short: "Create a new view",
                Long: `Create a new view configuration.

By default, opens your editor ($EDITOR) to create the view.
Use --template to create from a built-in template.
Use --interactive to use the interactive builder.

Available templates:
  minimal  - Minimalist view (status, summary, due date)
  full     - Complete view with all fields
  kanban   - Kanban-style view
  timeline - Timeline view focused on dates
  compact  - Single-line compact view`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        viewName := args[0]

                        // Check if view already exists
                        if views.ViewExists(viewName) </span><span class="cov0" title="0">{
                                return fmt.Errorf("view '%s' already exists (use 'edit' to modify)", viewName)
                        }</span>

                        <span class="cov0" title="0">var view *views.View

                        if interactive </span><span class="cov0" title="0">{
                                // Use interactive builder
                                built, err := builder.Run(viewName)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">view = built</span>
                        } else<span class="cov0" title="0"> if templateName != "" </span><span class="cov0" title="0">{
                                // Create from built-in view (templates are now built-in views)
                                template, err := views.ResolveView(templateName)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("template '%s' not found (available: minimal, full, kanban, timeline, compact)", templateName)
                                }</span>

                                // Copy the view and update name
                                <span class="cov0" title="0">viewCopy := *template
                                viewCopy.Name = viewName
                                view = &amp;viewCopy</span>
                        } else<span class="cov0" title="0"> {
                                // Create from editor
                                trueVal := true
                                falseVal := false
                                view = &amp;views.View{
                                        Name:        viewName,
                                        Description: "New view",
                                        Fields: []views.FieldConfig{
                                                {Name: "summary", Format: "full", Show: &amp;trueVal},
                                                {Name: "description", Format: "full", Show: &amp;falseVal, Width: 70},
                                                {Name: "status", Format: "symbol", Show: &amp;trueVal, Color: true},
                                                {Name: "priority", Format: "number", Show: &amp;trueVal, Color: true},
                                                {Name: "due_date", Format: "relative", Show: &amp;trueVal, Color: true},
                                                {Name: "start_date", Format: "short", Show: &amp;falseVal, Color: true},
                                                {Name: "created", Format: "relative", Show: &amp;falseVal},
                                                {Name: "modified", Format: "relative", Show: &amp;falseVal},
                                                {Name: "completed", Format: "short", Show: &amp;falseVal},
                                                {Name: "tags", Format: "comma", Show: &amp;falseVal},
                                        },
                                        Filters: &amp;views.ViewFilters{
                                                Status: []string{"NEEDS-ACTION", "IN-PROCESS"},
                                        },
                                        Display: views.DisplayOptions{
                                                ShowHeader:  true,
                                                ShowBorder:  true,
                                                CompactMode: false,
                                                DateFormat:  "2006-01-02",
                                                SortBy:      "priority",
                                                SortOrder:   "asc",
                                        },
                                }

                                // Open in editor
                                edited, err := editViewInEditor(view)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">view = edited</span>
                        }

                        // Save view
                        <span class="cov0" title="0">if err := views.SaveView(view); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to save view: %w", err)
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("View '%s' created successfully.\n", viewName)
                        return nil</span>
                },
        }

        <span class="cov0" title="0">cmd.Flags().StringVarP(&amp;templateName, "template", "t", "", "Create from template (minimal, full, kanban, timeline, compact)")
        cmd.Flags().BoolVarP(&amp;interactive, "interactive", "i", false, "Use interactive builder")

        return cmd</span>
}

// newViewEditCmd creates the 'view edit' command
func newViewEditCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "edit &lt;view-name&gt;",
                Short: "Edit a view",
                Long:  "Edit a view configuration in your editor ($EDITOR).\nBuilt-in views cannot be edited.",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        viewName := args[0]

                        // Prevent editing built-in views
                        if views.IsBuiltInView(viewName) </span><span class="cov0" title="0">{
                                return fmt.Errorf("cannot edit built-in view '%s' (use 'copy' to create an editable version)", viewName)
                        }</span>

                        // Load view
                        <span class="cov0" title="0">view, err := views.ResolveView(viewName)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("view '%s' not found: %w", viewName, err)
                        }</span>

                        // Edit in editor
                        <span class="cov0" title="0">edited, err := editViewInEditor(view)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Save
                        <span class="cov0" title="0">if err := views.SaveView(edited); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to save view: %w", err)
                        }</span>

                        // Clear cache
                        <span class="cov0" title="0">views.InvalidateViewCache(viewName)

                        fmt.Printf("View '%s' updated successfully.\n", viewName)
                        return nil</span>
                },
        }
}

// newViewDeleteCmd creates the 'view delete' command
func newViewDeleteCmd() *cobra.Command <span class="cov0" title="0">{
        var force bool

        cmd := &amp;cobra.Command{
                Use:   "delete &lt;view-name&gt;",
                Short: "Delete a view",
                Long:  "Delete a user-defined view.\nBuilt-in views cannot be deleted.",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        viewName := args[0]

                        // Confirm deletion unless --force
                        if !force </span><span class="cov0" title="0">{
                                confirmed, err := utils.PromptConfirmation(fmt.Sprintf("Delete view '%s'?", viewName))
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">if !confirmed </span><span class="cov0" title="0">{
                                        fmt.Println("Deletion cancelled.")
                                        return nil
                                }</span>
                        }

                        // Delete view
                        <span class="cov0" title="0">if err := views.DeleteView(viewName); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Clear cache
                        <span class="cov0" title="0">views.InvalidateViewCache(viewName)

                        fmt.Printf("View '%s' deleted successfully.\n", viewName)
                        return nil</span>
                },
        }

        <span class="cov0" title="0">cmd.Flags().BoolVarP(&amp;force, "force", "f", false, "Skip confirmation prompt")

        return cmd</span>
}

// newViewCopyCmd creates the 'view copy' command
func newViewCopyCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "copy &lt;source&gt; &lt;destination&gt;",
                Short: "Copy a view",
                Long:  "Create a copy of an existing view with a new name.",
                Args:  cobra.ExactArgs(2),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        sourceName := args[0]
                        destName := args[1]

                        // Check if destination exists
                        if views.ViewExists(destName) </span><span class="cov0" title="0">{
                                return fmt.Errorf("view '%s' already exists", destName)
                        }</span>

                        // Load source view
                        <span class="cov0" title="0">sourceView, err := views.ResolveView(sourceName)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("source view '%s' not found: %w", sourceName, err)
                        }</span>

                        // Create copy with new name
                        <span class="cov0" title="0">destView := *sourceView
                        destView.Name = destName

                        // Save
                        if err := views.SaveView(&amp;destView); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to save view: %w", err)
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("View '%s' copied to '%s' successfully.\n", sourceName, destName)
                        return nil</span>
                },
        }
}

// newViewValidateCmd creates the 'view validate' command
func newViewValidateCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "validate &lt;view-name&gt;",
                Short: "Validate a view",
                Long:  "Check if a view configuration is valid and can be loaded.",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        viewName := args[0]

                        // Try to load view
                        view, err := views.ResolveView(viewName)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf(" View '%s' is INVALID:\n", viewName)
                                fmt.Printf("   %v\n", err)
                                return nil // Don't return error, we want to show validation result
                        }</span>

                        <span class="cov0" title="0">fmt.Printf(" View '%s' is valid\n", viewName)
                        fmt.Printf("  Name: %s\n", view.Name)
                        fmt.Printf("  Fields: %d\n", len(view.Fields))
                        if view.Description != "" </span><span class="cov0" title="0">{
                                fmt.Printf("  Description: %s\n", view.Description)
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                },
        }
}

// editViewInEditor opens a view in the user's editor with validation loop
func editViewInEditor(view *views.View) (*views.View, error) <span class="cov0" title="0">{
        // Get editor from environment
        editor := os.Getenv("EDITOR")
        if editor == "" </span><span class="cov0" title="0">{
                editor = "vi" // Default to vi
        }</span>

        // Create temp file
        <span class="cov0" title="0">tmpfile, err := os.CreateTemp("", "gosynctasks-view-*.yaml")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create temp file: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = os.Remove(tmpfile.Name()) }</span>()

        // Marshal initial view to YAML
        <span class="cov0" title="0">data, err := utils.MarshalYAML(view)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">currentContent := data

        // Validation loop
        for </span><span class="cov0" title="0">{
                // Write current content to temp file
                if err := os.WriteFile(tmpfile.Name(), currentContent, 0644); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to write temp file: %w", err)
                }</span>

                // Open in editor
                <span class="cov0" title="0">cmd := exec.Command(editor, tmpfile.Name())
                cmd.Stdin = os.Stdin
                cmd.Stdout = os.Stdout
                cmd.Stderr = os.Stderr

                if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("editor failed: %w", err)
                }</span>

                // Read edited content
                <span class="cov0" title="0">editedData, err := os.ReadFile(tmpfile.Name())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read edited file: %w", err)
                }</span>

                // Try to parse the YAML first
                <span class="cov0" title="0">var parsedView views.View
                if err := yaml.Unmarshal(editedData, &amp;parsedView); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("\n YAML parsing failed: %v\n\n", err)
                        fmt.Print("The YAML syntax is invalid. Would you like to:\n")
                        fmt.Print("  [r] Retry - reopen editor to fix errors\n")
                        fmt.Print("  [c] Cancel - discard changes\n")
                        fmt.Print("Choice (r/c): ")

                        var choice string
                        if _, err := fmt.Scanf("%s", &amp;choice); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to read choice: %w", err)
                        }</span>

                        <span class="cov0" title="0">choice = strings.ToLower(strings.TrimSpace(choice))
                        if choice == "c" || choice == "cancel" </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("edit cancelled by user")
                        }</span>

                        // User wants to retry - keep current content with YAML error at top
                        <span class="cov0" title="0">errorComment := fmt.Sprintf("# YAML SYNTAX ERROR:\n# %s\n# Please fix the YAML syntax above and try again.\n\n", err.Error())
                        currentContent = append([]byte(errorComment), editedData...)
                        continue</span>
                }

                // Set the view name if not in YAML
                <span class="cov0" title="0">if parsedView.Name == "" </span><span class="cov0" title="0">{
                        parsedView.Name = view.Name
                }</span>

                // Perform comprehensive validation
                <span class="cov0" title="0">validationErrors := views.ValidateViewComprehensive(&amp;parsedView)

                if validationErrors != nil &amp;&amp; len(validationErrors.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        // Validation failed - show errors
                        fmt.Printf("\n Validation failed with %d error(s):\n", len(validationErrors.Errors))
                        for i, err := range validationErrors.Errors </span><span class="cov0" title="0">{
                                fmt.Printf("  %d. %s: %s\n", i+1, err.Field, err.Message)
                                if err.Hint != "" </span><span class="cov0" title="0">{
                                        fmt.Printf("     Hint: %s\n", err.Hint)
                                }</span>
                        }
                        <span class="cov0" title="0">fmt.Println()

                        // Ask user what to do
                        fmt.Print("Would you like to:\n")
                        fmt.Print("  [r] Retry - reopen editor with inline error comments\n")
                        fmt.Print("  [c] Cancel - discard changes\n")
                        fmt.Print("Choice (r/c): ")

                        var choice string
                        if _, err := fmt.Scanf("%s", &amp;choice); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to read choice: %w", err)
                        }</span>

                        <span class="cov0" title="0">choice = strings.ToLower(strings.TrimSpace(choice))
                        if choice == "c" || choice == "cancel" </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("edit cancelled by user")
                        }</span>

                        // User wants to retry - annotate YAML with errors
                        <span class="cov0" title="0">annotatedYAML := views.AnnotateYAMLWithErrors(string(editedData), validationErrors)
                        currentContent = []byte(annotatedYAML)
                        continue</span>
                }

                // Validation passed! Apply defaults and return
                <span class="cov0" title="0">edited, err := views.LoadViewFromBytes(editedData, view.Name)
                if err != nil </span><span class="cov0" title="0">{
                        // This shouldn't happen since we already validated, but handle it
                        return nil, fmt.Errorf("failed to load view: %w", err)
                }</span>

                <span class="cov0" title="0">return edited, nil</span>
        }
}

// getViewTemplate is deprecated and removed.
// Templates are now built-in views loaded from embedded YAML files.
// Use views.ResolveView(name) to load any built-in view.
</pre>
		
		<pre class="file" id="file23" style="display: none">package app

import (
        "fmt"
        "gosynctasks/backend"
        "gosynctasks/backend/sqlite"
        "gosynctasks/internal/cache"
        "gosynctasks/internal/config"
        "gosynctasks/internal/operations"
        "gosynctasks/internal/sync"
        "log"
        "time"

        "github.com/spf13/cobra"
)

// App holds the application state
type App struct {
        taskLists       []backend.TaskList
        taskManager     backend.TaskManager
        config          *config.Config
        registry        *backend.BackendRegistry
        selector        *backend.BackendSelector
        selectedBackend string
        syncCoordinator *sync.SyncCoordinator
}

// NewApp creates and initializes a new App instance
// explicitBackend can be empty (will use default/auto-detection)
func NewApp(explicitBackend string) (*App, error) <span class="cov0" title="0">{
        cfg := config.GetConfig()

        // Create backend registry
        registry, err := backend.NewBackendRegistry(cfg.GetEnabledBackends())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create backend registry: %w", err)
        }</span>

        // Create backend selector
        <span class="cov0" title="0">selector := backend.NewBackendSelector(registry)

        // Prepare sync configuration
        syncEnabled := cfg.Sync != nil &amp;&amp; cfg.Sync.Enabled
        syncLocalBackend := ""
        if cfg.Sync != nil </span><span class="cov0" title="0">{
                syncLocalBackend = cfg.Sync.LocalBackend
        }</span>

        // Select backend based on priority
        // When sync is enabled, the local backend is automatically selected
        <span class="cov0" title="0">selectedBackend, taskManager, err := selector.Select(
                explicitBackend,
                cfg.AutoDetectBackend,
                cfg.DefaultBackend,
                cfg.BackendPriority,
                syncEnabled,
                syncLocalBackend,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to select backend: %w", err)
        }</span>

        <span class="cov0" title="0">app := &amp;App{
                config:          cfg,
                taskManager:     taskManager,
                registry:        registry,
                selector:        selector,
                selectedBackend: selectedBackend,
        }

        // Load task lists with cache fallback
        app.taskLists, err = cache.LoadTaskListsWithFallback(taskManager)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Could not load task lists: %v", err)
        }</span>

        // Initialize sync coordinator if auto-sync is enabled
        <span class="cov0" title="0">if cfg.Sync != nil &amp;&amp; cfg.Sync.Enabled &amp;&amp; cfg.Sync.AutoSync </span><span class="cov0" title="0">{
                err := app.initializeSyncCoordinator()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Could not initialize auto-sync: %v", err)
                        log.Printf("Auto-sync will be disabled. Check that both backends are configured and enabled.")
                        // Continue without auto-sync
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("Auto-sync initialized successfully (local: %s, remote: %s)",
                                cfg.Sync.LocalBackend, cfg.Sync.RemoteBackend)
                }</span>
        }

        <span class="cov0" title="0">return app, nil</span>
}

// GetTaskLists returns the cached task lists
func (a *App) GetTaskLists() []backend.TaskList <span class="cov1" title="1">{
        return a.taskLists
}</span>

// GetTaskManager returns the task manager
func (a *App) GetTaskManager() backend.TaskManager <span class="cov1" title="1">{
        return a.taskManager
}</span>

// RefreshTaskLists refreshes the task list cache from the backend
func (a *App) RefreshTaskLists() error <span class="cov10" title="2">{
        lists, err := cache.RefreshAndCacheTaskLists(a.taskManager)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">a.taskLists = lists
        return nil</span>
}

// RefreshTaskListsOrWarn refreshes the task list cache, printing a warning on error
// This is a convenience wrapper for non-critical cache refresh operations
func (a *App) RefreshTaskListsOrWarn() <span class="cov0" title="0">{
        if err := a.RefreshTaskLists(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Warning: failed to refresh cache: %v\n", err)
        }</span>
}

// ListBackends displays all configured backends and their status
func (a *App) ListBackends() error <span class="cov1" title="1">{
        fmt.Println("\n=== Configured Backends ===")

        infos := a.registry.ListBackends()
        if len(infos) == 0 </span><span class="cov1" title="1">{
                fmt.Println("No backends configured")
                return nil
        }</span>

        <span class="cov0" title="0">for _, info := range infos </span><span class="cov0" title="0">{
                fmt.Println(info.String())
                if info.Name == a.selectedBackend </span><span class="cov0" title="0">{
                        fmt.Println("   Currently selected")
                }</span>
        }

        <span class="cov0" title="0">fmt.Println()
        return nil</span>
}

// DetectBackends displays all auto-detected backends
func (a *App) DetectBackends() error <span class="cov1" title="1">{
        fmt.Println("\n=== Auto-Detected Backends ===")

        detected := a.selector.DetectAll()
        if len(detected) == 0 </span><span class="cov1" title="1">{
                fmt.Println("No backends detected in current environment")
                return nil
        }</span>

        <span class="cov0" title="0">for _, info := range detected </span><span class="cov0" title="0">{
                fmt.Printf("%s | %s\n", info.Name, info.Type)
                if info.DetectionInfo != "" </span><span class="cov0" title="0">{
                        fmt.Printf("  %s\n", info.DetectionInfo)
                }</span>
        }

        <span class="cov0" title="0">fmt.Println()
        return nil</span>
}

// Run is a thin wrapper that delegates to operations
func (a *App) Run(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Refresh task lists from remote for actual operations
        lists, err := cache.RefreshAndCacheTaskLists(a.taskManager)
        if err != nil </span><span class="cov0" title="0">{
                // Check if it's a backend error that should be surfaced to the user
                if backendErr, ok := err.(*backend.BackendError); ok </span><span class="cov0" title="0">{
                        // Authentication or connection errors should stop execution
                        if backendErr.IsUnauthorized() </span><span class="cov0" title="0">{
                                return backendErr
                        }</span>
                        // Other HTTP errors should also stop execution
                        <span class="cov0" title="0">if backendErr.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                                return backendErr
                        }</span>
                }
                // For other errors, log warning but try to continue
                <span class="cov0" title="0">log.Printf("Warning: Could not refresh task lists: %v", err)</span>
        } else<span class="cov0" title="0"> {
                a.taskLists = lists
        }</span>

        <span class="cov0" title="0">return operations.ExecuteAction(a.taskManager, a.config, a.taskLists, cmd, args, a)</span>
}

// initializeSyncCoordinator sets up the sync coordinator with local and remote backends
func (a *App) initializeSyncCoordinator() error <span class="cov0" title="0">{
        cfg := a.config

        // Get local backend (must be SQLite)
        localBackend, err := a.registry.GetBackend(cfg.Sync.LocalBackend)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get local backend '%s': %w", cfg.Sync.LocalBackend, err)
        }</span>

        <span class="cov0" title="0">sqliteBackend, ok := localBackend.(*sqlite.SQLiteBackend)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("local backend must be SQLite, got %T", localBackend)
        }</span>

        // Get remote backend
        <span class="cov0" title="0">remoteBackend, err := a.registry.GetBackend(cfg.Sync.RemoteBackend)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get remote backend '%s': %w", cfg.Sync.RemoteBackend, err)
        }</span>

        // Create sync coordinator
        <span class="cov0" title="0">coordinator, err := sync.NewSyncCoordinator(cfg, sqliteBackend, remoteBackend)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create sync coordinator: %w", err)
        }</span>

        <span class="cov0" title="0">a.syncCoordinator = coordinator
        log.Printf("Auto-sync enabled: local=%s, remote=%s, interval=%dm",
                cfg.Sync.LocalBackend, cfg.Sync.RemoteBackend, cfg.Sync.SyncInterval)

        return nil</span>
}

// GetSyncCoordinator returns the sync coordinator (may be nil if auto-sync is disabled)
// Returns interface{} to avoid circular dependencies
func (a *App) GetSyncCoordinator() interface{} <span class="cov0" title="0">{
        return a.syncCoordinator
}</span>

// Shutdown gracefully shuts down the application, waiting for pending syncs
func (a *App) Shutdown() <span class="cov0" title="0">{
        a.ShutdownWithTimeout(5 * time.Second)
}</span>

// ShutdownWithTimeout gracefully shuts down with a custom timeout
func (a *App) ShutdownWithTimeout(timeout time.Duration) <span class="cov0" title="0">{
        if a.syncCoordinator != nil </span><span class="cov0" title="0">{
                a.syncCoordinator.Shutdown(timeout)
        }</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package cache

import (
        "encoding/json"
        "gosynctasks/backend"
        "os"
        "path/filepath"
        "time"
)

// CachedData represents the structure of cached task lists
type CachedData struct {
        Lists     []backend.TaskList `json:"lists"`
        Timestamp int64              `json:"timestamp"`
}

// GetCacheDir returns the XDG-compliant cache directory path
func GetCacheDir() (string, error) <span class="cov10" title="20">{
        cacheDir := os.Getenv("XDG_CACHE_HOME")
        if cacheDir == "" </span><span class="cov0" title="0">{
                home, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">cacheDir = filepath.Join(home, ".cache")</span>
        }
        <span class="cov10" title="20">cacheDir = filepath.Join(cacheDir, "gosynctasks")
        return cacheDir, os.MkdirAll(cacheDir, 0755)</span>
}

// GetCacheFile returns the full path to the task lists cache file
func GetCacheFile() (string, error) <span class="cov9" title="19">{
        cacheDir, err := GetCacheDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov9" title="19">return filepath.Join(cacheDir, "lists.json"), nil</span>
}

// LoadTaskListsFromCache loads task lists from the cache file
func LoadTaskListsFromCache() ([]backend.TaskList, error) <span class="cov7" title="9">{
        cacheFile, err := GetCacheFile()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="9">data, err := os.ReadFile(cacheFile)
        if err != nil </span><span class="cov4" title="3">{
                return nil, err
        }</span>

        <span class="cov6" title="6">var cached CachedData
        if err := json.Unmarshal(data, &amp;cached); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov5" title="5">return cached.Lists, nil</span>
}

// SaveTaskListsToCache saves task lists to the cache file with timestamp
func SaveTaskListsToCache(lists []backend.TaskList) error <span class="cov6" title="7">{
        cacheFile, err := GetCacheFile()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="7">cached := CachedData{
                Lists:     lists,
                Timestamp: time.Now().Unix(),
        }

        data, err := json.MarshalIndent(cached, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="7">return os.WriteFile(cacheFile, data, 0644)</span>
}

// LoadTaskListsWithFallback attempts to load from cache, falls back to fetching from remote
func LoadTaskListsWithFallback(taskManager backend.TaskManager) ([]backend.TaskList, error) <span class="cov4" title="3">{
        // Try cache first
        lists, err := LoadTaskListsFromCache()
        if err == nil </span><span class="cov1" title="1">{
                return lists, nil
        }</span>

        // Fetch from remote
        <span class="cov3" title="2">lists, err = taskManager.GetTaskLists()
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Save to cache for next time
        <span class="cov1" title="1">_ = SaveTaskListsToCache(lists)
        return lists, nil</span>
}

// RefreshAndCacheTaskLists force-fetches task lists from remote and updates cache
func RefreshAndCacheTaskLists(taskManager backend.TaskManager) ([]backend.TaskList, error) <span class="cov3" title="2">{
        lists, err := taskManager.GetTaskLists()
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">_ = SaveTaskListsToCache(lists)
        return lists, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package config

import (
        "fmt"
        "strings"

        // "gosynctasks/backend"
        "gosynctasks/backend"
        // "gosynctasks/connectors"
        "gosynctasks/internal/utils"
        "gosynctasks/internal/views"
        "log"
        "os"
        "path/filepath"
        "sync"

        "github.com/go-playground/validator/v10"
        "gopkg.in/yaml.v3"

        _ "embed"
)

var configOnce sync.Once

var globalConfig *Config

var customConfigPath string // Custom config path set via --config flag

// var globalConnector *connectors.TaskConnector

//go:embed config.sample.yaml
var sampleConfig []byte

const (
        CONFIG_DIR_PATH  = "gosynctasks"
        CONFIG_FILE_PATH = "config.yaml"
        CONFIG_DIR_PERM  = 0755
        CONFIG_FILE_PERM = 0644
)

// expandPath expands ~ and $HOME in paths while respecting escaped versions.
// Escaping rules:
//   - \~ becomes literal ~
//   - \$HOME or \$ becomes literal $HOME or $
//   - ~ at start of path expands to user home directory
//   - $HOME anywhere in path expands to user home directory
func expandPath(path string) string <span class="cov10" title="21">{
        if path == "" </span><span class="cov1" title="1">{
                return path
        }</span>

        <span class="cov9" title="20">homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                // If we can't get home dir, return path unchanged
                return path
        }</span>

        // Use a placeholder to protect escaped sequences during expansion
        <span class="cov9" title="20">const escapedTildePlaceholder = "\x00ESCAPED_TILDE\x00"
        const escapedDollarPlaceholder = "\x00ESCAPED_DOLLAR\x00"

        // Step 1: Replace escaped sequences with placeholders
        path = strings.ReplaceAll(path, `\~`, escapedTildePlaceholder)
        path = strings.ReplaceAll(path, `\$`, escapedDollarPlaceholder)

        // Step 2: Expand ~ at the start of the path
        if strings.HasPrefix(path, "~/") || path == "~" </span><span class="cov5" title="5">{
                if path == "~" </span><span class="cov1" title="1">{
                        path = homeDir
                }</span> else<span class="cov5" title="4"> {
                        path = filepath.Join(homeDir, path[2:])
                }</span>
        }

        // Step 3: Expand $HOME anywhere in the path
        <span class="cov9" title="20">path = strings.ReplaceAll(path, "$HOME", homeDir)

        // Step 4: Restore escaped sequences (unescape them)
        path = strings.ReplaceAll(path, escapedTildePlaceholder, "~")
        path = strings.ReplaceAll(path, escapedDollarPlaceholder, "$")

        return path</span>
}

// Config represents the application configuration.
type Config struct {
        CanWriteConfig bool `yaml:"canWriteConfig"`

        // Backend configuration
        Backends          map[string]backend.BackendConfig `yaml:"backends,omitempty"`
        DefaultBackend    string                           `yaml:"default_backend,omitempty"`
        AutoDetectBackend bool                             `yaml:"auto_detect_backend,omitempty"`
        BackendPriority   []string                         `yaml:"backend_priority,omitempty"`

        // Common settings
        UI         string      `yaml:"ui" validate:"oneof=cli tui"`
        DateFormat string      `yaml:"date_format,omitempty"` // Go time format string, defaults to "2006-01-02"
        Sync       *SyncConfig `yaml:"sync,omitempty"`        // Sync configuration
}

// SyncConfig represents sync-related settings
type SyncConfig struct {
        Enabled            bool   `yaml:"enabled"`                       // Enable sync functionality
        ConflictResolution string `yaml:"conflict_resolution,omitempty"` // Strategy: server_wins, local_wins, merge, keep_both
        AutoSync           bool   `yaml:"auto_sync,omitempty"`           // Auto-sync on command execution
        SyncInterval       int    `yaml:"sync_interval,omitempty"`       // Minutes between auto-syncs (0=disabled)
        OfflineMode        string `yaml:"offline_mode,omitempty"`        // Mode: auto, online, offline
        LocalBackend       string `yaml:"local_backend,omitempty"`       // Name of local SQLite backend for sync
        RemoteBackend      string `yaml:"remote_backend,omitempty"`      // Name of remote backend to sync with
}

// GetBackend returns the backend configuration for the given name
func (c *Config) GetBackend(name string) (*backend.BackendConfig, error) <span class="cov1" title="1">{
        backendConfig, exists := c.Backends[name]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("backend %q not found in config", name)
        }</span>

        <span class="cov1" title="1">return &amp;backendConfig, nil</span>
}

// GetDefaultBackend returns the default backend configuration
func (c *Config) GetDefaultBackend() (*backend.BackendConfig, error) <span class="cov4" title="3">{
        if c.DefaultBackend == "" </span><span class="cov3" title="2">{
                // Try to find the first enabled backend
                for _, backendConfig := range c.Backends </span><span class="cov1" title="1">{
                        if backendConfig.Enabled </span><span class="cov1" title="1">{
                                return &amp;backendConfig, nil
                        }</span>
                }
                <span class="cov1" title="1">return nil, fmt.Errorf("no default backend specified and no enabled backends found")</span>
        }

        <span class="cov1" title="1">return c.GetBackend(c.DefaultBackend)</span>
}

// GetEnabledBackends returns all enabled backend configurations
func (c *Config) GetEnabledBackends() map[string]backend.BackendConfig <span class="cov3" title="2">{
        enabled := make(map[string]backend.BackendConfig)

        for name, backendConfig := range c.Backends </span><span class="cov5" title="4">{
                if backendConfig.Enabled </span><span class="cov3" title="2">{
                        enabled[name] = backendConfig
                }</span>
        }

        <span class="cov3" title="2">return enabled</span>
}

func (c Config) Validate() error <span class="cov7" title="9">{
        validate := validator.New()
        if err := validate.Struct(c); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // Validate that backends map is not empty
        <span class="cov7" title="8">if len(c.Backends) == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("no backends configured")
        }</span>

        // Validate each backend config
        <span class="cov6" title="7">for name, backendConfig := range c.Backends </span><span class="cov7" title="10">{
                if err := validate.Struct(backendConfig); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("backend %q validation failed: %w", name, err)
                }</span>

                // Type-specific validation
                <span class="cov7" title="10">switch backendConfig.Type </span>{
                case "nextcloud", "file":<span class="cov6" title="6">
                        // Accept either:
                        // - Full URL with credentials (legacy)
                        // - URL without credentials + username (keyring/env)
                        // - Host + username (keyring/env)
                        // - Neither (all from env vars)
                        hasURL := backendConfig.URL != ""
                        hasHost := backendConfig.Host != ""

                        if !hasURL &amp;&amp; !hasHost </span><span class="cov1" title="1">{
                                // Must have username for env var lookup
                                if backendConfig.Username == "" </span><span class="cov1" title="1">{
                                        return fmt.Errorf("backend %q: URL, host, or username is required for %s backend", name, backendConfig.Type)
                                }</span>
                        }
                case "git":<span class="cov1" title="1">
                        if backendConfig.File == "" </span><span class="cov0" title="0">{
                                // Use default
                                backendConfig.File = "TODO.md"
                        }</span>
                case "sqlite":<span class="cov4" title="3"></span>
                        // db_path is optional - empty string means use XDG default
                        // No validation needed
                }
        }

        // Validate default backend exists and is enabled
        <span class="cov6" title="6">if c.DefaultBackend != "" </span><span class="cov4" title="3">{
                backend, exists := c.Backends[c.DefaultBackend]
                if !exists </span><span class="cov1" title="1">{
                        return fmt.Errorf("default backend %q not found in configured backends", c.DefaultBackend)
                }</span>
                <span class="cov3" title="2">if !backend.Enabled </span><span class="cov1" title="1">{
                        return fmt.Errorf("default backend %q is disabled", c.DefaultBackend)
                }</span>
        }

        // Validate backend priority list references valid backends
        <span class="cov5" title="4">for _, name := range c.BackendPriority </span><span class="cov3" title="2">{
                if _, exists := c.Backends[name]; !exists </span><span class="cov1" title="1">{
                        return fmt.Errorf("backend_priority references unknown backend %q", name)
                }</span>
        }

        <span class="cov4" title="3">return nil</span>
}

func (c *Config) GetDateFormat() string <span class="cov0" title="0">{
        if c.DateFormat == "" </span><span class="cov0" title="0">{
                return "2006-01-02" // Default to yyyy-mm-dd
        }</span>
        <span class="cov0" title="0">return c.DateFormat</span>
}

// expandAllPaths expands ~ and $HOME in all path fields throughout the config
func (c *Config) expandAllPaths() <span class="cov1" title="1">{
        // Expand paths in each backend config
        for name, backendCfg := range c.Backends </span><span class="cov5" title="4">{
                // Expand DBPath (sqlite)
                if backendCfg.DBPath != "" </span><span class="cov3" title="2">{
                        backendCfg.DBPath = expandPath(backendCfg.DBPath)
                }</span>

                // Expand File (git)
                <span class="cov5" title="4">if backendCfg.File != "" </span><span class="cov1" title="1">{
                        backendCfg.File = expandPath(backendCfg.File)
                }</span>

                // Expand FallbackFiles (git)
                <span class="cov5" title="4">if len(backendCfg.FallbackFiles) &gt; 0 </span><span class="cov1" title="1">{
                        for i, file := range backendCfg.FallbackFiles </span><span class="cov3" title="2">{
                                backendCfg.FallbackFiles[i] = expandPath(file)
                        }</span>
                }

                // Expand URL if it looks like a file path (file:// scheme)
                <span class="cov5" title="4">if backendCfg.URL != "" &amp;&amp; strings.HasPrefix(backendCfg.URL, "file://") </span><span class="cov1" title="1">{
                        // Extract path part after file://
                        pathPart := strings.TrimPrefix(backendCfg.URL, "file://")
                        expandedPath := expandPath(pathPart)
                        backendCfg.URL = "file://" + expandedPath
                }</span>

                // Update the backend config in the map
                <span class="cov5" title="4">c.Backends[name] = backendCfg</span>
        }
}

// SetCustomConfigPath sets a custom config path to use instead of the default user config directory.
// If path is empty or ".", it uses "./gosynctasks/config.yaml" (current directory).
// If path is a directory (or looks like one), it looks for "config.yaml" inside it.
// If path is a file, it uses that file directly.
// This must be called before GetConfig() is called for the first time.
// If GetConfig() was already called, this function will reset it to allow reloading with the new path.
func SetCustomConfigPath(path string) <span class="cov7" title="8">{
        if path == "" || path == "." </span><span class="cov3" title="2">{
                customConfigPath = filepath.Join(".", CONFIG_DIR_PATH, CONFIG_FILE_PATH)
        }</span> else<span class="cov6" title="6"> {
                // Check if path exists and is a directory
                info, err := os.Stat(path)
                if err == nil &amp;&amp; info.IsDir() </span><span class="cov1" title="1">{
                        // Path exists and is a directory
                        customConfigPath = filepath.Join(path, CONFIG_FILE_PATH)
                }</span> else<span class="cov5" title="5"> if err != nil </span><span class="cov5" title="4">{
                        // Path doesn't exist - determine intent from path structure
                        // If path ends with config file extension, treat as file path
                        // Otherwise, assume it's a directory path
                        ext := filepath.Ext(path)
                        if ext == ".yaml" || ext == ".yml" || ext == ".YAML" || ext == ".YML" || ext == ".json" || ext == ".JSON" </span><span class="cov4" title="3">{
                                customConfigPath = path
                        }</span> else<span class="cov1" title="1"> {
                                // Assume directory, join with config.yaml
                                customConfigPath = filepath.Join(path, CONFIG_FILE_PATH)
                        }</span>
                } else<span class="cov1" title="1"> {
                        // Path exists and is a file
                        customConfigPath = path
                }</span>
        }

        // Reset the sync.Once to force config reload with new path
        // This is necessary if GetConfig() was already called before this function
        <span class="cov7" title="8">configOnce = sync.Once{}
        globalConfig = nil</span>
}

func GetConfig() *Config <span class="cov0" title="0">{
        configOnce.Do(func() </span><span class="cov0" title="0">{
                config, err := loadUserOrSampleConfig()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
                <span class="cov0" title="0">globalConfig = config</span>
        })
        <span class="cov0" title="0">return globalConfig</span>
}

func loadUserOrSampleConfig() (*Config, error) <span class="cov0" title="0">{

        configPath, err := GetConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Config path couldn't be retrieved")
                return nil, err
        }</span>
        <span class="cov0" title="0">configData, err := configDataFromPath(configPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Config data couldn't be retrieved")
                return nil, err
        }</span>
        <span class="cov0" title="0">configObj, err := parseConfig(configData, configPath)
        return configObj, err</span>
}

func GetConfigPath() (string, error) <span class="cov0" title="0">{
        // If a custom config path was set, check if it exists
        if customConfigPath != "" </span><span class="cov0" title="0">{
                if _, err := os.Stat(customConfigPath); err == nil </span><span class="cov0" title="0">{
                        return customConfigPath, nil
                }</span>
                // Custom path was set but doesn't exist, still return it
                // (allows creation of config in custom location)
                <span class="cov0" title="0">return customConfigPath, nil</span>
        }

        // Otherwise, use the default user config directory
        <span class="cov0" title="0">dir, err := os.UserConfigDir()

        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get user config dir: %w", err)
        }</span>
        <span class="cov0" title="0">return filepath.Join(dir, CONFIG_DIR_PATH, CONFIG_FILE_PATH), nil</span>
}

func createConfigDir(configPath string) error <span class="cov0" title="0">{
        return os.MkdirAll(filepath.Dir(configPath), CONFIG_DIR_PERM)
}</span>
func WriteConfigFile(configPath string, data []byte) error <span class="cov0" title="0">{
        return os.WriteFile(configPath, data, CONFIG_FILE_PERM)
}</span>

func createConfigFromSample(configPath string) []byte <span class="cov0" title="0">{
        var (
                configData []byte
                err        error
        )
        err = createConfigDir(configPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">configData = sampleConfig

        err = WriteConfigFile(configPath, configData)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // Copy built-in views to user config on first run
        <span class="cov0" title="0">copied, err := views.CopyBuiltInViewsToUserConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Failed to copy built-in views: %v", err)
        }</span> else<span class="cov0" title="0"> if copied </span><span class="cov0" title="0">{
                fmt.Println("Built-in views copied to user config directory")
        }</span>

        <span class="cov0" title="0">return configData</span>
}

func parseConfig(configData []byte, configPath string) (*Config, error) <span class="cov1" title="1">{
        var configObj Config
        err := yaml.Unmarshal(configData, &amp;configObj)

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Invalid YAML in config file %s: %v", configPath, err)
        }</span>

        // Set backend names from map keys
        <span class="cov1" title="1">for name, backendConfig := range configObj.Backends </span><span class="cov5" title="4">{
                backendConfig.Name = name
                configObj.Backends[name] = backendConfig
        }</span>

        // Expand ~ and $HOME in all path fields
        <span class="cov1" title="1">configObj.expandAllPaths()

        if err = configObj.Validate(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Missing field(s) in YAML config file %s: %v", configPath, err)
        }</span>
        <span class="cov1" title="1">return &amp;configObj, err</span>
}

func configDataFromPath(configPath string) ([]byte, error) <span class="cov0" title="0">{
        var (
                configData []byte
                err        error
        )

        configData, err = os.ReadFile(configPath)
        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                fmt.Println("No config exist at ", configPath)

                shouldCopySample := utils.PromptYesNo("Do you want to copy config sample to " + configPath + "?")
                if shouldCopySample </span><span class="cov0" title="0">{
                        configData = createConfigFromSample(configPath)

                }</span> else<span class="cov0" title="0"> {
                        configData = sampleConfig
                }</span>
        }

        <span class="cov0" title="0">return configData, nil</span>

}
</pre>
		
		<pre class="file" id="file26" style="display: none">package credentials

import (
        "os"
        "strings"
)

// normalizeBackendName converts a backend name to the format used in environment variables
// Example: "nextcloud-work" becomes "NEXTCLOUD_WORK"
func normalizeBackendName(backendName string) string <span class="cov10" title="39">{
        // Convert to uppercase
        normalized := strings.ToUpper(backendName)
        // Replace hyphens with underscores
        normalized = strings.ReplaceAll(normalized, "-", "_")
        return normalized
}</span>

// getEnvVarName returns the environment variable name for a backend field
func getEnvVarName(backendName, field string) string <span class="cov9" title="35">{
        return "GOSYNCTASKS_" + normalizeBackendName(backendName) + "_" + strings.ToUpper(field)
}</span>

// GetUsername retrieves the username from environment variables
// Looks for: GOSYNCTASKS_{BACKEND_NAME}_USERNAME
func GetUsername(backendName string) string <span class="cov7" title="14">{
        if backendName == "" </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov7" title="13">return os.Getenv(getEnvVarName(backendName, "USERNAME"))</span>
}

// GetPassword retrieves the password from environment variables
// Looks for: GOSYNCTASKS_{BACKEND_NAME}_PASSWORD
func GetPassword(backendName string) string <span class="cov7" title="13">{
        if backendName == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov7" title="13">return os.Getenv(getEnvVarName(backendName, "PASSWORD"))</span>
}

// GetHost retrieves the host from environment variables
// Looks for: GOSYNCTASKS_{BACKEND_NAME}_HOST
func GetHost(backendName string) string <span class="cov5" title="6">{
        if backendName == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov5" title="6">return os.Getenv(getEnvVarName(backendName, "HOST"))</span>
}

// HasCredentials checks if credentials exist in environment variables
func HasCredentials(backendName string) bool <span class="cov3" title="3">{
        username := GetUsername(backendName)
        password := GetPassword(backendName)
        return username != "" &amp;&amp; password != ""
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package credentials

import (
        "fmt"

        "github.com/zalando/go-keyring"
)

const (
        // KeyringServicePrefix is the prefix for all gosynctasks keyring entries
        KeyringServicePrefix = "gosynctasks"
)

// KeyringEntry represents a credential stored in the keyring
type KeyringEntry struct {
        BackendName string
        Username    string
}

// getServiceName returns the keyring service name for a backend
func getServiceName(backendName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s-%s", KeyringServicePrefix, backendName)
}</span>

// Set stores credentials in the OS keyring
func Set(backendName, username, password string) error <span class="cov0" title="0">{
        if backendName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("backend name cannot be empty")
        }</span>
        <span class="cov0" title="0">if username == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("username cannot be empty")
        }</span>
        <span class="cov0" title="0">if password == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("password cannot be empty")
        }</span>

        <span class="cov0" title="0">serviceName := getServiceName(backendName)
        err := keyring.Set(serviceName, username, password)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to store credentials in keyring: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Get retrieves a password from the OS keyring
func Get(backendName, username string) (string, error) <span class="cov0" title="0">{
        if backendName == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("backend name cannot be empty")
        }</span>
        <span class="cov0" title="0">if username == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("username cannot be empty")
        }</span>

        <span class="cov0" title="0">serviceName := getServiceName(backendName)
        password, err := keyring.Get(serviceName, username)
        if err != nil </span><span class="cov0" title="0">{
                // Check if it's a "not found" error
                if err == keyring.ErrNotFound </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("no credentials found in keyring for backend %q and user %q", backendName, username)
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("failed to retrieve credentials from keyring: %w", err)</span>
        }

        <span class="cov0" title="0">return password, nil</span>
}

// Delete removes credentials from the OS keyring
func Delete(backendName, username string) error <span class="cov0" title="0">{
        if backendName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("backend name cannot be empty")
        }</span>
        <span class="cov0" title="0">if username == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("username cannot be empty")
        }</span>

        <span class="cov0" title="0">serviceName := getServiceName(backendName)
        err := keyring.Delete(serviceName, username)
        if err != nil </span><span class="cov0" title="0">{
                if err == keyring.ErrNotFound </span><span class="cov0" title="0">{
                        return fmt.Errorf("no credentials found in keyring for backend %q and user %q", backendName, username)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to delete credentials from keyring: %w", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// IsAvailable checks if the keyring is accessible
// This is useful for providing helpful error messages when keyring is not available
func IsAvailable() bool <span class="cov0" title="0">{
        // Try to access the keyring with a test operation
        // Use a unique service name that won't conflict with real credentials
        testService := "gosynctasks-keyring-test"
        testUser := "test"

        // Try to get a non-existent item - if keyring is available, we'll get ErrNotFound
        // If keyring is not available, we'll get a different error
        _, err := keyring.Get(testService, testUser)

        // Keyring is available if we get ErrNotFound (meaning keyring works but item doesn't exist)
        // or if we get no error (meaning the test item exists, which is unlikely but means keyring works)
        return err == nil || err == keyring.ErrNotFound
}</span>

// List returns all keyring entries for gosynctasks
// Note: go-keyring doesn't provide a native list function, so this is a stub
// that would require platform-specific implementation or storing metadata separately
func List() ([]KeyringEntry, error) <span class="cov0" title="0">{
        // Unfortunately, go-keyring doesn't provide a way to list all entries
        // This would require platform-specific code or maintaining a separate registry
        // For now, we'll return an error indicating this limitation
        return nil, fmt.Errorf("listing keyring entries is not supported by the current keyring library")
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package credentials

import (
        "fmt"
        "net/url"
)

// Source indicates where credentials were found
type Source string

const (
        SourceKeyring Source = "keyring"
        SourceEnv     Source = "env"
        SourceURL     Source = "url"
        SourceNone    Source = "none"
)

// Credentials represents resolved authentication credentials
type Credentials struct {
        Username string
        Password string
        Host     string
        Source   Source
}

// Resolver handles credential resolution from multiple sources with priority order
type Resolver struct {
        // Priority order: Keyring &gt; Environment Variables &gt; Config URL
}

// NewResolver creates a new credential resolver
func NewResolver() *Resolver <span class="cov8" title="7">{
        return &amp;Resolver{}
}</span>

// Resolve attempts to find credentials using the priority order:
// 1. Keyring (if username is provided)
// 2. Environment variables
// 3. URL credentials (backward compatible)
//
// Parameters:
//   - backendName: Name of the backend (e.g., "nextcloud")
//   - username: Optional username hint (used for keyring lookup)
//   - configURL: Optional URL from config (may contain credentials)
//
// Returns credentials with Source indicating where they were found
func (r *Resolver) Resolve(backendName, username string, host string, configURL *url.URL) (*Credentials, error) <span class="cov10" title="9">{
        if backendName == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("backend name is required for credential resolution")
        }</span>

        <span class="cov9" title="8">creds := &amp;Credentials{
                Username: username,
                Host:     host,
                Source:   SourceNone,
        }

        // Priority 1: Try keyring if username is known
        if username != "" &amp;&amp; IsAvailable() </span><span class="cov0" title="0">{
                password, err := Get(backendName, username)
                if err == nil </span><span class="cov0" title="0">{
                        creds.Password = password
                        creds.Source = SourceKeyring

                        // Get host from env if not provided
                        if creds.Host == "" </span><span class="cov0" title="0">{
                                if envHost := GetHost(backendName); envHost != "" </span><span class="cov0" title="0">{
                                        creds.Host = envHost
                                }</span> else<span class="cov0" title="0"> if configURL != nil </span><span class="cov0" title="0">{
                                        creds.Host = configURL.Host
                                }</span>
                        }

                        <span class="cov0" title="0">return creds, nil</span>
                }
                // If error is not "not found", it's a keyring access issue
                // Log but continue to next source
        }

        // Priority 2: Try environment variables
        <span class="cov9" title="8">envUsername := GetUsername(backendName)
        envPassword := GetPassword(backendName)
        if envUsername != "" &amp;&amp; envPassword != "" </span><span class="cov7" title="5">{
                creds.Username = envUsername
                creds.Password = envPassword
                creds.Source = SourceEnv

                // Get host from env if not provided
                if creds.Host == "" </span><span class="cov6" title="4">{
                        if envHost := GetHost(backendName); envHost != "" </span><span class="cov3" title="2">{
                                creds.Host = envHost
                        }</span> else<span class="cov3" title="2"> if configURL != nil </span><span class="cov1" title="1">{
                                creds.Host = configURL.Host
                        }</span>
                }

                <span class="cov7" title="5">return creds, nil</span>
        }

        // Priority 3: Try URL credentials (backward compatible)
        <span class="cov5" title="3">if configURL != nil &amp;&amp; configURL.User != nil </span><span class="cov3" title="2">{
                urlUsername := configURL.User.Username()
                urlPassword, _ := configURL.User.Password()

                if urlUsername != "" &amp;&amp; urlPassword != "" </span><span class="cov3" title="2">{
                        creds.Username = urlUsername
                        creds.Password = urlPassword
                        creds.Host = configURL.Host
                        creds.Source = SourceURL
                        return creds, nil
                }</span>
        }

        // No credentials found
        <span class="cov1" title="1">return nil, fmt.Errorf("no credentials found for backend %q (tried: keyring, environment variables, config URL)", backendName)</span>
}

// ResolveWithConfig is a convenience method that accepts config values
// and constructs the URL internally if needed
func (r *Resolver) ResolveWithConfig(backendName, configUsername, configHost, configURL string) (*Credentials, error) <span class="cov5" title="3">{
        var parsedURL *url.URL
        var err error

        if configURL != "" </span><span class="cov3" title="2">{
                parsedURL, err = url.Parse(configURL)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("invalid URL: %w", err)
                }</span>
        }

        // Use username from config if provided
        <span class="cov3" title="2">username := configUsername

        // Use host from config if provided
        host := configHost

        return r.Resolve(backendName, username, host, parsedURL)</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package operations

import (
        "fmt"
        "gosynctasks/backend"
        "gosynctasks/internal/cli"
        "gosynctasks/internal/config"
        "gosynctasks/internal/utils"
        "gosynctasks/internal/views"
        "reflect"
        "strings"

        "github.com/spf13/cobra"
)

// SyncCoordinatorProvider is an interface for getting the sync coordinator
// This avoids circular dependencies while allowing sync triggers
type SyncCoordinatorProvider interface {
        GetSyncCoordinator() interface{}
}

// ExecuteAction parses arguments and routes to the appropriate action handler
func ExecuteAction(taskManager backend.TaskManager, cfg *config.Config, taskLists []backend.TaskList, cmd *cobra.Command, args []string, syncProvider SyncCoordinatorProvider) error <span class="cov0" title="0">{
        var listName string
        var taskSummary string
        var searchSummary string
        action := "get"

        // Argument order: &lt;list&gt; [action] [task-summary]
        if len(args) &gt;= 1 </span><span class="cov0" title="0">{
                listName = args[0]
        }</span>
        <span class="cov0" title="0">if len(args) &gt;= 2 </span><span class="cov0" title="0">{
                action = args[1]
        }</span>
        <span class="cov0" title="0">if len(args) &gt;= 3 </span><span class="cov0" title="0">{
                // For update/complete/delete: arg[2] is summary to search for
                // For add: arg[2] is task summary to create
                if strings.ToLower(action) == "update" || strings.ToLower(action) == "u" ||
                        strings.ToLower(action) == "complete" || strings.ToLower(action) == "c" ||
                        strings.ToLower(action) == "delete" || strings.ToLower(action) == "d" </span><span class="cov0" title="0">{
                        searchSummary = args[2]
                }</span> else<span class="cov0" title="0"> {
                        taskSummary = args[2]
                }</span>
        }

        // Normalize action (support abbreviations)
        <span class="cov0" title="0">action = NormalizeAction(action)

        selectedList, err := GetSelectedList(taskLists, taskManager, listName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">filter, err := BuildFilter(cmd, taskManager)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">switch action </span>{
        case "get":<span class="cov0" title="0">
                return HandleGetAction(cmd, taskManager, cfg, selectedList, filter, syncProvider)</span>

        case "add":<span class="cov0" title="0">
                return HandleAddAction(cmd, taskManager, selectedList, taskSummary, syncProvider)</span>

        case "update":<span class="cov0" title="0">
                return HandleUpdateAction(cmd, taskManager, cfg, selectedList, searchSummary, syncProvider)</span>

        case "complete":<span class="cov0" title="0">
                return HandleCompleteAction(cmd, taskManager, cfg, selectedList, searchSummary, syncProvider)</span>

        case "delete":<span class="cov0" title="0">
                return HandleDeleteAction(cmd, taskManager, cfg, selectedList, searchSummary, syncProvider)</span>

        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown action: %s (supported: get/g, add/a, update/u, complete/c, delete/d)", action)</span>
        }
}

// NormalizeAction converts action abbreviations to full action names
func NormalizeAction(action string) string <span class="cov0" title="0">{
        action = strings.ToLower(action)
        switch action </span>{
        case "g":<span class="cov0" title="0">
                return "get"</span>
        case "a":<span class="cov0" title="0">
                return "add"</span>
        case "u":<span class="cov0" title="0">
                return "update"</span>
        case "c":<span class="cov0" title="0">
                return "complete"</span>
        case "d":<span class="cov0" title="0">
                return "delete"</span>
        default:<span class="cov0" title="0">
                return action</span>
        }
}

// HandleGetAction lists tasks from a task list
func HandleGetAction(cmd *cobra.Command, taskManager backend.TaskManager, cfg *config.Config, selectedList *backend.TaskList, filter *backend.TaskFilter, syncProvider SyncCoordinatorProvider) error <span class="cov0" title="0">{
        // Check staleness and trigger pull if needed (for auto-sync)
        if syncProvider != nil </span><span class="cov0" title="0">{
                if coord := syncProvider.GetSyncCoordinator(); coord != nil </span><span class="cov0" title="0">{
                        // Type assert to get the actual SyncCoordinator
                        // We use interface{} in the provider to avoid circular dependencies
                        // The actual type will be *sync.SyncCoordinator from internal/sync package
                        triggerPullIfStale(coord, selectedList.ID)
                }</span>
        }

        <span class="cov0" title="0">tasks, err := taskManager.GetTasks(selectedList.ID, filter)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error retrieving tasks: %w", err)
        }</span>

        // Sort using backend-specific sorting
        <span class="cov0" title="0">taskManager.SortTasks(tasks)

        // Get optional flags (errors ignored as flags are always defined by the command)
        viewName, _ := cmd.Flags().GetString("view")
        dateFormat := cfg.GetDateFormat()
        termWidth := cli.GetTerminalWidth()

        // Try to use custom view rendering first
        // Note: Custom views currently don't support hierarchical display
        // This will be added in a future enhancement
        rendered, err := RenderWithCustomView(tasks, viewName, taskManager, dateFormat)
        if err == nil </span><span class="cov0" title="0">{
                // Custom view found and rendered successfully
                fmt.Print(selectedList.StringWithWidthAndBackend(termWidth, taskManager))
                fmt.Print(rendered)
                fmt.Print(selectedList.BottomBorderWithWidth(termWidth))
                return nil
        }</span>

        // Fall back to tree-based hierarchical display
        <span class="cov0" title="0">fmt.Print(selectedList.StringWithWidthAndBackend(termWidth, taskManager))

        // Build task tree
        tree := BuildTaskTree(tasks)

        // Format and display tree
        treeOutput := FormatTaskTree(tree, viewName, taskManager, dateFormat)
        fmt.Print(treeOutput)

        fmt.Print(selectedList.BottomBorderWithWidth(termWidth))
        return nil</span>
}

// HandleAddAction adds a new task to a list
func HandleAddAction(cmd *cobra.Command, taskManager backend.TaskManager, selectedList *backend.TaskList, taskSummary string, syncProvider SyncCoordinatorProvider) error <span class="cov0" title="0">{
        // If no task summary provided in args, prompt for it
        if taskSummary == "" </span><span class="cov0" title="0">{
                fmt.Print("Enter task summary: ")
                var input string
                if _, err := fmt.Scanln(&amp;input); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read task summary: %w", err)
                }</span>
                <span class="cov0" title="0">taskSummary = input</span>
        }

        <span class="cov0" title="0">if taskSummary == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("task summary cannot be empty")
        }</span>

        // Get optional flags (errors ignored as flags are always defined by the command)
        <span class="cov0" title="0">description, _ := cmd.Flags().GetString("description")
        priority, _ := cmd.Flags().GetInt("priority")
        statusFlag, _ := cmd.Flags().GetString("add-status")
        dueDateStr, _ := cmd.Flags().GetString("due-date")
        startDateStr, _ := cmd.Flags().GetString("start-date")
        parentRef, _ := cmd.Flags().GetString("parent")
        literal, _ := cmd.Flags().GetBool("literal")

        // Default status: use backend's parser with "TODO" as default
        var taskStatus string
        var err error
        if statusFlag != "" </span><span class="cov0" title="0">{
                taskStatus, err = taskManager.ParseStatusFlag(statusFlag)
        }</span> else<span class="cov0" title="0"> {
                taskStatus, err = taskManager.ParseStatusFlag("TODO")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate priority
        <span class="cov0" title="0">if err := utils.ValidatePriority(priority); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Parse and validate dates
        <span class="cov0" title="0">dueDate, err := utils.ParseDateFlag(dueDateStr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">startDate, err := utils.ParseDateFlag(startDateStr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := utils.ValidateDates(startDate, dueDate); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">cfg := config.GetConfig()
        var parentUID string
        var actualTaskName string

        // Handle path-based task creation or parent resolution
        if parentRef != "" </span><span class="cov0" title="0">{
                // Explicit parent provided via -P flag
                parentUID, err = ResolveParentTask(taskManager, cfg, selectedList.ID, parentRef, taskStatus)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to resolve parent task: %w", err)
                }</span>
                <span class="cov0" title="0">actualTaskName = taskSummary</span>
        } else<span class="cov0" title="0"> if !literal &amp;&amp; strings.Contains(taskSummary, "/") </span><span class="cov0" title="0">{
                // Path-based shorthand: "parent/child/task" creates hierarchy automatically
                // Skip if --literal flag is set
                fmt.Printf("Detected path-based task creation: '%s'\n", taskSummary)
                parentUID, actualTaskName, err = CreateOrFindTaskPath(taskManager, cfg, selectedList.ID, taskSummary, taskStatus)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create task path: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                // Simple task with no parent (or literal mode)
                actualTaskName = taskSummary
        }</span>

        <span class="cov0" title="0">task := backend.Task{
                Summary:     actualTaskName,
                Description: description,
                Status:      taskStatus,
                Priority:    priority,
                DueDate:     dueDate,
                StartDate:   startDate,
                ParentUID:   parentUID,
        }

        if err := taskManager.AddTask(selectedList.ID, task); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error adding task: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Task '%s' added successfully to list '%s'\n", actualTaskName, selectedList.Name)

        // Trigger background push sync
        triggerPushSync(syncProvider)

        return nil</span>
}

// HandleUpdateAction updates an existing task
func HandleUpdateAction(cmd *cobra.Command, taskManager backend.TaskManager, cfg *config.Config, selectedList *backend.TaskList, searchSummary string, syncProvider SyncCoordinatorProvider) error <span class="cov0" title="0">{
        var taskToUpdate *backend.Task
        var err error

        // If no search summary provided, show interactive selection
        if searchSummary == "" </span><span class="cov0" title="0">{
                taskToUpdate, err = SelectTaskInteractively(taskManager, cfg, selectedList.ID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                // Find the task by summary (handles exact/partial/multiple matches)
                // No filter needed - allow updating any task including completed ones
                taskToUpdate, err = FindTaskBySummary(taskManager, cfg, selectedList.ID, searchSummary, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Get update flags (errors ignored as flags are always defined by the command)
        <span class="cov0" title="0">statusFlags, _ := cmd.Flags().GetStringArray("status")
        description, _ := cmd.Flags().GetString("description")
        priority, _ := cmd.Flags().GetInt("priority")
        summaryFlag, _ := cmd.Flags().GetString("summary")
        dueDateStr, _ := cmd.Flags().GetString("due-date")
        startDateStr, _ := cmd.Flags().GetString("start-date")

        // Update fields if provided
        // For update action, use first status value if provided
        if len(statusFlags) &gt; 0 &amp;&amp; statusFlags[0] != "" </span><span class="cov0" title="0">{
                newStatus, err := taskManager.ParseStatusFlag(statusFlags[0])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">taskToUpdate.Status = newStatus</span>
        }

        <span class="cov0" title="0">if summaryFlag != "" </span><span class="cov0" title="0">{
                taskToUpdate.Summary = summaryFlag
        }</span>

        <span class="cov0" title="0">if cmd.Flags().Changed("description") </span><span class="cov0" title="0">{
                taskToUpdate.Description = description
        }</span>

        <span class="cov0" title="0">if cmd.Flags().Changed("priority") </span><span class="cov0" title="0">{
                if err := utils.ValidatePriority(priority); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">taskToUpdate.Priority = priority</span>
        }

        // Parse and update dates if changed
        <span class="cov0" title="0">if cmd.Flags().Changed("due-date") </span><span class="cov0" title="0">{
                dueDate, err := utils.ParseDateFlag(dueDateStr)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">taskToUpdate.DueDate = dueDate</span>
        }

        <span class="cov0" title="0">if cmd.Flags().Changed("start-date") </span><span class="cov0" title="0">{
                startDate, err := utils.ParseDateFlag(startDateStr)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">taskToUpdate.StartDate = startDate</span>
        }

        // Validate dates (after all updates applied)
        <span class="cov0" title="0">if err := utils.ValidateDates(taskToUpdate.StartDate, taskToUpdate.DueDate); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update the task
        <span class="cov0" title="0">if err := taskManager.UpdateTask(selectedList.ID, *taskToUpdate); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error updating task: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Task '%s' updated successfully in list '%s'\n", taskToUpdate.Summary, selectedList.Name)

        // Trigger background push sync
        triggerPushSync(syncProvider)

        return nil</span>
}

// HandleCompleteAction marks a task with a status (defaults to COMPLETED)
func HandleCompleteAction(cmd *cobra.Command, taskManager backend.TaskManager, cfg *config.Config, selectedList *backend.TaskList, searchSummary string, syncProvider SyncCoordinatorProvider) error <span class="cov0" title="0">{
        var taskToComplete *backend.Task
        var err error

        // If no search summary provided, show interactive selection
        if searchSummary == "" </span><span class="cov0" title="0">{
                // Exclude tasks that are already completed or cancelled
                excludeStatuses := []string{"DONE", "COMPLETED", "CANCELLED"}
                filter := &amp;backend.TaskFilter{
                        ExcludeStatuses: &amp;excludeStatuses,
                }
                taskToComplete, err = SelectTaskInteractively(taskManager, cfg, selectedList.ID, filter)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                // Find the task by summary (handles exact/partial/multiple matches)
                // Exclude tasks that are already completed or cancelled
                excludeStatuses := []string{"DONE", "COMPLETED", "CANCELLED"}
                filter := &amp;backend.TaskFilter{
                        ExcludeStatuses: &amp;excludeStatuses,
                }
                taskToComplete, err = FindTaskBySummary(taskManager, cfg, selectedList.ID, searchSummary, filter)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Get status flag (errors ignored as flags are always defined by the command)
        // If provided, use it; otherwise default to DONE
        <span class="cov0" title="0">statusFlags, _ := cmd.Flags().GetStringArray("status")
        var newStatus string

        if len(statusFlags) &gt; 0 &amp;&amp; statusFlags[0] != "" </span><span class="cov0" title="0">{
                newStatus, err = taskManager.ParseStatusFlag(statusFlags[0])
        }</span> else<span class="cov0" title="0"> {
                newStatus, err = taskManager.ParseStatusFlag("DONE")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get display name for user feedback
        <span class="cov0" title="0">statusName := taskManager.StatusToDisplayName(newStatus)

        // Set the new status
        taskToComplete.Status = newStatus

        // Update the task
        if err := taskManager.UpdateTask(selectedList.ID, *taskToComplete); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error updating task: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Task '%s' marked as %s in list '%s'\n", taskToComplete.Summary, statusName, selectedList.Name)

        // Trigger background push sync
        triggerPushSync(syncProvider)

        return nil</span>
}

// HandleDeleteAction deletes a task by summary
func HandleDeleteAction(cmd *cobra.Command, taskManager backend.TaskManager, cfg *config.Config, selectedList *backend.TaskList, searchSummary string, syncProvider SyncCoordinatorProvider) error <span class="cov0" title="0">{
        var taskToDelete *backend.Task
        var err error

        // If no search summary provided, show interactive selection
        if searchSummary == "" </span><span class="cov0" title="0">{
                taskToDelete, err = SelectTaskInteractively(taskManager, cfg, selectedList.ID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                // Find the task by summary (handles exact/partial/multiple matches)
                // No filter needed - allow deleting any task including completed ones
                taskToDelete, err = FindTaskBySummary(taskManager, cfg, selectedList.ID, searchSummary, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Show a final confirmation before deletion
        <span class="cov0" title="0">fmt.Println()
        confirmed, err := utils.PromptConfirmation(fmt.Sprintf("Are you sure you want to delete task '%s'? This action cannot be undone.", taskToDelete.Summary))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !confirmed </span><span class="cov0" title="0">{
                return fmt.Errorf("deletion cancelled")
        }</span>

        // Delete the task
        <span class="cov0" title="0">if err := taskManager.DeleteTask(selectedList.ID, taskToDelete.UID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error deleting task: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Task '%s' deleted successfully from list '%s'\n", taskToDelete.Summary, selectedList.Name)

        // Trigger background push sync
        triggerPushSync(syncProvider)

        return nil</span>
}

// RenderWithCustomView attempts to render tasks using a custom view
// Returns the rendered output or an error if the view cannot be loaded
// This version supports hierarchical display with tree structure
func RenderWithCustomView(tasks []backend.Task, viewName string, taskManager backend.TaskManager, dateFormat string) (string, error) <span class="cov0" title="0">{
        // Try to resolve the view
        view, err := views.ResolveView(viewName)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Create renderer
        <span class="cov0" title="0">renderer := views.NewViewRenderer(view, taskManager, dateFormat)

        // Apply view-specific filters
        filteredTasks := tasks
        if filters := renderer.GetFilters(); filters != nil </span><span class="cov0" title="0">{
                filteredTasks = views.ApplyFilters(tasks, filters)
        }</span>

        // Build task tree BEFORE sorting
        // This preserves parent-child relationships
        <span class="cov0" title="0">tree := BuildTaskTree(filteredTasks)

        // Apply view-specific sorting hierarchically
        // This sorts root tasks and recursively sorts children within each parent
        sortBy, sortOrder := renderer.GetSortConfig()
        if sortBy != "" </span><span class="cov0" title="0">{
                SortTaskTree(tree, sortBy, sortOrder)
        }</span>

        // Render tasks with hierarchy
        <span class="cov0" title="0">return RenderTaskTreeWithCustomView(tree, renderer), nil</span>
}

// RenderTaskTreeWithCustomView formats a task tree using a custom view renderer
func RenderTaskTreeWithCustomView(nodes []*TaskNode, renderer *views.ViewRenderer) string <span class="cov0" title="0">{
        var result strings.Builder
        formatNodeWithCustomView(&amp;result, nodes, "", true, renderer)
        return result.String()
}</span>

// formatNodeWithCustomView recursively formats a task node with proper indentation using custom view
func formatNodeWithCustomView(result *strings.Builder, nodes []*TaskNode, prefix string, isRoot bool, renderer *views.ViewRenderer) <span class="cov0" title="0">{
        for i, node := range nodes </span><span class="cov0" title="0">{
                isLast := i == len(nodes)-1

                // Determine the tree characters
                var nodePrefix, childPrefix string
                if isRoot </span><span class="cov0" title="0">{
                        nodePrefix = ""
                        childPrefix = ""
                }</span> else<span class="cov0" title="0"> {
                        if isLast </span><span class="cov0" title="0">{
                                nodePrefix = prefix + " "
                                childPrefix = prefix + "   "
                        }</span> else<span class="cov0" title="0"> {
                                nodePrefix = prefix + " "
                                childPrefix = prefix + "  "
                        }</span>
                }

                // Render the task normally first
                <span class="cov0" title="0">taskOutput := renderer.RenderTask(*node.Task)

                // Add parent indicator if this task has children
                // This works for ALL tasks with children, including:
                // - Root parents (top-level tasks with children)
                // - Intermediate parents (tasks that are both parents AND children themselves)
                // - Any level of nesting (grandparents, great-grandparents, etc.)
                if len(node.Children) &gt; 0 </span><span class="cov0" title="0">{
                        taskOutput = addParentIndicator(taskOutput, len(node.Children))
                }</span>

                // Apply hierarchical formatting with tree prefix
                <span class="cov0" title="0">taskOutput = applyHierarchicalFormatting(taskOutput, nodePrefix, childPrefix)
                result.WriteString(taskOutput)

                // Recursively format children
                if len(node.Children) &gt; 0 </span><span class="cov0" title="0">{
                        formatNodeWithCustomView(result, node.Children, childPrefix, false, renderer)
                }</span>
        }
}

// applyHierarchicalFormatting adds tree indentation to task output
func applyHierarchicalFormatting(taskOutput, nodePrefix, childPrefix string) string <span class="cov0" title="0">{
        if nodePrefix == "" </span><span class="cov0" title="0">{
                return taskOutput
        }</span>

        <span class="cov0" title="0">var result strings.Builder
        lines := strings.Split(strings.TrimRight(taskOutput, "\n"), "\n")
        for j, line := range lines </span><span class="cov0" title="0">{
                if j == 0 </span><span class="cov0" title="0">{
                        result.WriteString(nodePrefix)
                }</span> else<span class="cov0" title="0"> {
                        result.WriteString(childPrefix)
                }</span>
                <span class="cov0" title="0">result.WriteString(line)
                result.WriteString("\n")</span>
        }
        <span class="cov0" title="0">return result.String()</span>
}

// triggerPushSync spawns a detached background process to sync
func triggerPushSync(syncProvider SyncCoordinatorProvider) <span class="cov0" title="0">{
        if syncProvider == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Get the sync coordinator to verify it's initialized
        <span class="cov0" title="0">coord := syncProvider.GetSyncCoordinator()
        // Safety check: use reflection to verify the interface contains a non-nil value
        // In Go, an interface can be non-nil but contain a nil pointer
        if coord == nil || reflect.ValueOf(coord).IsNil() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get config path to pass to spawned process
        <span class="cov0" title="0">configPath, err := config.GetConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return // Silent fail
        }</span>

        // Spawn detached background process to run sync
        // This process will outlive the parent CLI
        <span class="cov0" title="0">spawnBackgroundSync(configPath)</span>
}

// spawnBackgroundSync is implemented in platform-specific files:
// - actions_unix.go for Unix/Linux/macOS
// - actions_windows.go for Windows

// triggerPullIfStale checks if data is stale and triggers a pull sync if needed
func triggerPullIfStale(coord interface{}, listID string) <span class="cov0" title="0">{
        // Safety check: use reflection to verify the interface contains a non-nil value
        // In Go, an interface can be non-nil but contain a nil pointer
        if coord == nil || reflect.ValueOf(coord).IsNil() </span><span class="cov0" title="0">{
                return
        }</span>

        // Type assert to get the actual SyncCoordinator
        // We use reflection here to avoid circular dependencies
        // The coordinator should have IsStale() and TriggerPullSync() methods
        <span class="cov0" title="0">type pullSyncer interface {
                IsStale(listID string) (bool, error)
                TriggerPullSync(listID string)
        }

        if ps, ok := coord.(pullSyncer); ok </span><span class="cov0" title="0">{
                if stale, err := ps.IsStale(listID); err == nil &amp;&amp; stale </span><span class="cov0" title="0">{
                        // Trigger background pull sync (launches goroutine)
                        ps.TriggerPullSync(listID)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file30" style="display: none">//go:build unix || darwin || linux

package operations

import (
        "os"
        "os/exec"
        "syscall"
)

// spawnBackgroundSync spawns a completely detached background process to sync (Unix/Linux/macOS)
func spawnBackgroundSync(configPath string) <span class="cov0" title="0">{
        // Get current executable path
        executable, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                return // Silent fail - will sync on next operation
        }</span>

        // Build command args with config path
        <span class="cov0" title="0">args := []string{"sync", "--quiet"}
        if configPath != "" </span><span class="cov0" title="0">{
                args = append(args, "--config", configPath)
        }</span>

        // Spawn detached process: gosynctasks sync --quiet --config &lt;path&gt;
        <span class="cov0" title="0">cmd := exec.Command(executable, args...)

        // Completely detach from parent process (Unix-specific)
        cmd.SysProcAttr = &amp;syscall.SysProcAttr{
                Setpgid: true, // New process group
                Pgid:    0,
        }

        // Redirect all I/O to /dev/null
        cmd.Stdin = nil
        cmd.Stdout = nil
        cmd.Stderr = nil

        // Start and immediately detach
        _ = cmd.Start()</span>
        // Don't wait - process runs independently
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package operations

import (
        "fmt"
        "gosynctasks/backend"
        "gosynctasks/internal/cli"
        "strings"
)

// FindListByName searches for a task list by name and returns its ID.
// Performs case-insensitive search. Returns an error if the list is not found.
func FindListByName(taskLists []backend.TaskList, name string) (string, error) <span class="cov0" title="0">{
        for _, list := range taskLists </span><span class="cov0" title="0">{
                if strings.EqualFold(list.Name, name) </span><span class="cov0" title="0">{
                        return list.ID, nil
                }</span>
        }
        <span class="cov0" title="0">return "", fmt.Errorf("list '%s' not found", name)</span>
}

// FindListByNameFull searches for a task list by name and returns the complete TaskList struct.
// Performs case-insensitive search. Returns an error if the list is not found.
func FindListByNameFull(taskLists []backend.TaskList, name string) (*backend.TaskList, error) <span class="cov0" title="0">{
        for _, list := range taskLists </span><span class="cov0" title="0">{
                if strings.EqualFold(list.Name, name) </span><span class="cov0" title="0">{
                        return &amp;list, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("list '%s' not found", name)</span>
}

// SelectListInteractively displays task lists and prompts user to select one
func SelectListInteractively(taskLists []backend.TaskList, taskManager backend.TaskManager) (*backend.TaskList, error) <span class="cov0" title="0">{
        cli.ShowTaskLists(taskLists, taskManager)

        fmt.Printf("\n\033[1mSelect list (1-%d, or 0 to cancel):\033[0m ", len(taskLists))
        var choice int
        if _, err := fmt.Scanf("%d", &amp;choice); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid input")
        }</span>

        <span class="cov0" title="0">if choice == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cancelled")
        }</span>

        <span class="cov0" title="0">if choice &lt; 1 || choice &gt; len(taskLists) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid choice: %d (must be 1-%d)", choice, len(taskLists))
        }</span>

        <span class="cov0" title="0">return &amp;taskLists[choice-1], nil</span>
}

// GetSelectedList returns a list by name or prompts for interactive selection
func GetSelectedList(taskLists []backend.TaskList, taskManager backend.TaskManager, listName string) (*backend.TaskList, error) <span class="cov0" title="0">{
        if listName != "" </span><span class="cov0" title="0">{
                selectedList, err := FindListByNameFull(taskLists, listName)
                if err != nil </span><span class="cov0" title="0">{
                        // If no task lists were loaded at all, suggest checking connection
                        if len(taskLists) == 0 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("list '%s' not found - no task lists could be loaded. This usually means a connection or authentication failure. Please check your connection URL, username, and password in the config file", listName)
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("list '%s' not found. Available lists: %s", listName, formatAvailableLists(taskLists))</span>
                }
                <span class="cov0" title="0">return selectedList, nil</span>
        }

        // No list name provided, use interactive selection
        <span class="cov0" title="0">if len(taskLists) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no task lists available - failed to connect to backend. Please check your connection URL, username, and password in the config file")
        }</span>
        <span class="cov0" title="0">return SelectListInteractively(taskLists, taskManager)</span>
}

// formatAvailableLists creates a comma-separated list of available task list names
func formatAvailableLists(taskLists []backend.TaskList) string <span class="cov0" title="0">{
        if len(taskLists) == 0 </span><span class="cov0" title="0">{
                return "(none)"
        }</span>
        <span class="cov0" title="0">names := make([]string, len(taskLists))
        for i, list := range taskLists </span><span class="cov0" title="0">{
                names[i] = list.Name
        }</span>
        <span class="cov0" title="0">return strings.Join(names, ", ")</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package operations

import (
        "fmt"
        "gosynctasks/backend"
        "gosynctasks/internal/config"
        "sort"
        "strings"
        "time"
)

// CreateOrFindTaskPath creates a hierarchical path of tasks, creating any missing levels
// Returns the UID of the final parent and the actual task name to create
// Example: "parent/child/task" creates/finds "parent", creates/finds "child" under "parent",
// and returns the UID of "child" and "task" as the name
func CreateOrFindTaskPath(taskManager backend.TaskManager, cfg *config.Config, listID string, path string, taskStatus string) (parentUID string, taskName string, err error) <span class="cov0" title="0">{
        parts := strings.Split(path, "/")
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("empty path")
        }</span>

        // If only one part, it's just a regular task (no parent)
        <span class="cov0" title="0">if len(parts) == 1 </span><span class="cov0" title="0">{
                return "", parts[0], nil
        }</span>

        // The last part is the task name to create
        <span class="cov0" title="0">taskName = strings.TrimSpace(parts[len(parts)-1])
        if taskName == "" </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("task name cannot be empty")
        }</span>

        // Create or find each parent level
        <span class="cov0" title="0">var currentParentUID string
        for i := 0; i &lt; len(parts)-1; i++ </span><span class="cov0" title="0">{
                partName := strings.TrimSpace(parts[i])
                if partName == "" </span><span class="cov0" title="0">{
                        return "", "", fmt.Errorf("empty path segment in '%s'", path)
                }</span>

                // Try to find existing task at this level (or create if user chooses)
                <span class="cov0" title="0">task, err := findTaskByParent(taskManager, cfg, listID, partName, currentParentUID, taskStatus)
                if err != nil </span><span class="cov0" title="0">{
                        // Task doesn't exist - create it
                        fmt.Printf("Creating intermediate task '%s'...\n", partName)

                        // Generate UID before creating the task so we have it for the next iteration
                        newUID := fmt.Sprintf("task-%d-%d", time.Now().Unix(), i)

                        newTask := backend.Task{
                                UID:       newUID,
                                Summary:   partName,
                                Status:    taskStatus,
                                ParentUID: currentParentUID,
                        }
                        if err := taskManager.AddTask(listID, newTask); err != nil </span><span class="cov0" title="0">{
                                return "", "", fmt.Errorf("failed to create intermediate task '%s': %w", partName, err)
                        }</span>

                        // Use the UID we just generated (no need to retrieve the task)
                        <span class="cov0" title="0">currentParentUID = newUID</span>
                } else<span class="cov0" title="0"> {
                        // Task already exists, use its UID
                        currentParentUID = task.UID
                }</span>
        }

        <span class="cov0" title="0">return currentParentUID, taskName, nil</span>
}

// ResolveParentTask resolves a parent task reference (simple name or path) to a task UID
// Supports both simple references ("Parent Task") and path-based references ("Feature X/Write code/Fix bug")
// If the parent doesn't exist and user chooses to create it, creates a new task with the given status
func ResolveParentTask(taskManager backend.TaskManager, cfg *config.Config, listID string, parentRef string, taskStatus string) (string, error) <span class="cov0" title="0">{
        if parentRef == "" </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        // Check if it's a path-based reference (contains '/')
        <span class="cov0" title="0">if strings.Contains(parentRef, "/") </span><span class="cov0" title="0">{
                return resolveParentPath(taskManager, cfg, listID, parentRef, taskStatus)
        }</span>

        // Simple reference - find the task by summary
        // No filter needed - allow finding any task including completed ones as parent
        <span class="cov0" title="0">task, err := FindTaskBySummary(taskManager, cfg, listID, parentRef, nil)
        if err != nil </span><span class="cov0" title="0">{
                // If user chose to create new parent (entered 0), create it as root task
                if strings.Contains(err.Error(), "operation cancelled") </span><span class="cov0" title="0">{
                        fmt.Printf("Creating new parent task '%s'...\n", parentRef)
                        newUID := fmt.Sprintf("task-%d-parent", time.Now().Unix())
                        newTask := backend.Task{
                                UID:       newUID,
                                Summary:   parentRef,
                                Status:    taskStatus,
                                ParentUID: "", // Root level
                        }
                        if err := taskManager.AddTask(listID, newTask); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to create new parent task '%s': %w", parentRef, err)
                        }</span>
                        <span class="cov0" title="0">return newUID, nil</span>
                }
                <span class="cov0" title="0">return "", fmt.Errorf("failed to find parent task '%s': %w", parentRef, err)</span>
        }

        <span class="cov0" title="0">return task.UID, nil</span>
}

// resolveParentPath resolves a hierarchical path like "Feature X/Write code" to find the deepest task
// If any part doesn't exist and user chooses to create it, creates new tasks with the given status
func resolveParentPath(taskManager backend.TaskManager, cfg *config.Config, listID string, path string, taskStatus string) (string, error) <span class="cov0" title="0">{
        parts := strings.Split(path, "/")
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("empty parent path")
        }</span>

        // Start from root level (tasks with no parent)
        <span class="cov0" title="0">var currentParentUID string

        for i, part := range parts </span><span class="cov0" title="0">{
                part = strings.TrimSpace(part)
                if part == "" </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("empty path segment in '%s'", path)
                }</span>

                // Find task matching this part with the current parent
                <span class="cov0" title="0">task, err := findTaskByParent(taskManager, cfg, listID, part, currentParentUID, taskStatus)
                if err != nil </span><span class="cov0" title="0">{
                        pathSoFar := strings.Join(parts[:i+1], "/")
                        return "", fmt.Errorf("failed to resolve '%s' in path '%s': %w", pathSoFar, path, err)
                }</span>

                <span class="cov0" title="0">currentParentUID = task.UID</span>
        }

        <span class="cov0" title="0">return currentParentUID, nil</span>
}

// findTaskByParent finds a task with the given summary and parent UID
// If user chooses to create new (enters 0 on selection), creates a new task with the given status
func findTaskByParent(taskManager backend.TaskManager, cfg *config.Config, listID string, summary string, parentUID string, taskStatus string) (*backend.Task, error) <span class="cov0" title="0">{
        // Get all tasks and filter by parent
        allTasks, err := taskManager.GetTasks(listID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get tasks: %w", err)
        }</span>

        // Filter tasks matching summary and parent
        <span class="cov0" title="0">var matches []backend.Task
        summaryLower := strings.ToLower(summary)

        for _, task := range allTasks </span><span class="cov0" title="0">{
                // Check if parent matches (both empty or both equal)
                parentMatches := (parentUID == "" &amp;&amp; task.ParentUID == "") || (task.ParentUID == parentUID)
                if !parentMatches </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if summary matches (case-insensitive, allows partial)
                <span class="cov0" title="0">if strings.Contains(strings.ToLower(task.Summary), summaryLower) </span><span class="cov0" title="0">{
                        matches = append(matches, task)
                }</span>
        }

        <span class="cov0" title="0">if len(matches) == 0 </span><span class="cov0" title="0">{
                // No matches found - create new task automatically
                fmt.Printf("No tasks found matching '%s'. Creating new task...\n", summary)
                return createNewTask(taskManager, listID, summary, parentUID, taskStatus)
        }</span>

        // Separate exact and partial matches
        <span class="cov0" title="0">var exactMatches []backend.Task
        var partialMatches []backend.Task

        for _, task := range matches </span><span class="cov0" title="0">{
                if strings.ToLower(task.Summary) == summaryLower </span><span class="cov0" title="0">{
                        exactMatches = append(exactMatches, task)
                }</span> else<span class="cov0" title="0"> {
                        partialMatches = append(partialMatches, task)
                }</span>
        }

        // Single exact match - return it
        <span class="cov0" title="0">if len(exactMatches) == 1 &amp;&amp; len(partialMatches) == 0 </span><span class="cov0" title="0">{
                return &amp;exactMatches[0], nil
        }</span>

        // Multiple matches - let user select (or create new)
        <span class="cov0" title="0">if len(exactMatches) &gt; 1 </span><span class="cov0" title="0">{
                task, err := selectTaskWithPath(exactMatches, summary, taskManager, cfg, listID)
                if err != nil &amp;&amp; strings.Contains(err.Error(), "operation cancelled") </span><span class="cov0" title="0">{
                        // User chose to create new - create it with current parentUID
                        return createNewTask(taskManager, listID, summary, parentUID, taskStatus)
                }</span>
                <span class="cov0" title="0">return task, err</span>
        }

        <span class="cov0" title="0">if len(exactMatches) == 0 &amp;&amp; len(partialMatches) == 1 </span><span class="cov0" title="0">{
                // Single partial match - confirm
                task := &amp;partialMatches[0]
                confirmed, err := confirmTask(task, taskManager, cfg)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if !confirmed </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("operation cancelled")
                }</span>
                <span class="cov0" title="0">return task, nil</span>
        }

        // Multiple matches (exact or partial) - let user select (or create new)
        <span class="cov0" title="0">task, err := selectTaskWithPath(matches, summary, taskManager, cfg, listID)
        if err != nil &amp;&amp; strings.Contains(err.Error(), "operation cancelled") </span><span class="cov0" title="0">{
                // User chose to create new - create it with current parentUID
                return createNewTask(taskManager, listID, summary, parentUID, taskStatus)
        }</span>
        <span class="cov0" title="0">return task, err</span>
}

// createNewTask creates a new task with the given summary, parent, and status
func createNewTask(taskManager backend.TaskManager, listID string, summary string, parentUID string, taskStatus string) (*backend.Task, error) <span class="cov0" title="0">{
        fmt.Printf("Creating new task '%s'...\n", summary)
        newUID := fmt.Sprintf("task-%d", time.Now().UnixNano())
        newTask := backend.Task{
                UID:       newUID,
                Summary:   summary,
                Status:    taskStatus,
                ParentUID: parentUID,
        }
        if err := taskManager.AddTask(listID, newTask); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create new task '%s': %w", summary, err)
        }</span>
        <span class="cov0" title="0">return &amp;newTask, nil</span>
}

// selectTaskWithPath shows tasks with their hierarchical paths for disambiguation
func selectTaskWithPath(tasks []backend.Task, searchSummary string, taskManager backend.TaskManager, cfg *config.Config, listID string) (*backend.Task, error) <span class="cov0" title="0">{
        if len(tasks) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no tasks found matching '%s'", searchSummary)
        }</span>

        // Get all tasks to build hierarchy
        <span class="cov0" title="0">allTasks, err := taskManager.GetTasks(listID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get tasks for hierarchy: %w", err)
        }</span>

        // Build UID to task map
        <span class="cov0" title="0">taskMap := make(map[string]*backend.Task)
        for i := range allTasks </span><span class="cov0" title="0">{
                taskMap[allTasks[i].UID] = &amp;allTasks[i]
        }</span>

        // Show tasks with hierarchical paths
        <span class="cov0" title="0">fmt.Printf("\n%d tasks found matching '%s':\n", len(tasks), searchSummary)
        dateFormat := cfg.GetDateFormat()

        for i, task := range tasks </span><span class="cov0" title="0">{
                path := GetTaskPath(&amp;task, taskMap)
                fmt.Printf("\n%d: [%s]", i+1, path)
                fmt.Print(task.FormatWithView("all", taskManager, dateFormat))
        }</span>

        <span class="cov0" title="0">fmt.Printf("\nSelect task (1-%d) or 0 to create new: ", len(tasks))
        var choice int
        if _, err := fmt.Scanf("%d", &amp;choice); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid input: %w", err)
        }</span>

        <span class="cov0" title="0">if choice == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("operation cancelled")
        }</span>

        <span class="cov0" title="0">if choice &lt; 1 || choice &gt; len(tasks) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid choice: %d", choice)
        }</span>

        <span class="cov0" title="0">return &amp;tasks[choice-1], nil</span>
}

// TaskNode represents a node in the task tree
type TaskNode struct {
        Task     *backend.Task
        Children []*TaskNode
}

// BuildTaskTree builds a hierarchical tree from a flat list of tasks
func BuildTaskTree(tasks []backend.Task) []*TaskNode <span class="cov7" title="20">{
        // Build map of UID to task pointer
        taskMap := make(map[string]*backend.Task)
        for i := range tasks </span><span class="cov10" title="59">{
                taskMap[tasks[i].UID] = &amp;tasks[i]
        }</span>

        // Build map of parent UID to children
        <span class="cov7" title="20">childrenMap := make(map[string][]*backend.Task)
        var rootTasks []*backend.Task

        for i := range tasks </span><span class="cov10" title="59">{
                task := &amp;tasks[i]
                if task.ParentUID == "" </span><span class="cov8" title="27">{
                        rootTasks = append(rootTasks, task)
                }</span> else<span class="cov8" title="32"> {
                        childrenMap[task.ParentUID] = append(childrenMap[task.ParentUID], task)
                }</span>
        }

        // Recursively build tree
        <span class="cov7" title="20">var buildNode func(*backend.Task) *TaskNode
        buildNode = func(task *backend.Task) *TaskNode </span><span class="cov10" title="59">{
                node := &amp;TaskNode{
                        Task:     task,
                        Children: []*TaskNode{},
                }

                // Add children recursively
                if children, exists := childrenMap[task.UID]; exists </span><span class="cov7" title="21">{
                        for _, child := range children </span><span class="cov8" title="32">{
                                node.Children = append(node.Children, buildNode(child))
                        }</span>
                }

                <span class="cov10" title="59">return node</span>
        }

        // Build root nodes
        <span class="cov7" title="20">var roots []*TaskNode
        for _, rootTask := range rootTasks </span><span class="cov8" title="27">{
                roots = append(roots, buildNode(rootTask))
        }</span>

        <span class="cov7" title="20">return roots</span>
}

// SortTaskTree sorts a task tree hierarchically
// It sorts root nodes and recursively sorts children within each parent
func SortTaskTree(nodes []*TaskNode, sortBy string, sortOrder string) <span class="cov6" title="13">{
        if sortBy == "" || len(nodes) == 0 </span><span class="cov2" title="2">{
                return
        }</span>

        // Import sort package functions from views package
        // We'll use a comparison function that matches the ApplySort logic
        <span class="cov6" title="11">sortNodes(nodes, sortBy, sortOrder)

        // Recursively sort children
        for _, node := range nodes </span><span class="cov7" title="18">{
                if len(node.Children) &gt; 0 </span><span class="cov4" title="6">{
                        SortTaskTree(node.Children, sortBy, sortOrder)
                }</span>
        }
}

// sortNodes sorts a slice of TaskNodes based on sort configuration
func sortNodes(nodes []*TaskNode, sortBy string, sortOrder string) <span class="cov6" title="11">{
        if sortBy == "" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov6" title="11">ascending := true
        if strings.ToLower(sortOrder) == "desc" </span><span class="cov1" title="1">{
                ascending = false
        }</span>

        <span class="cov6" title="11">sort.Slice(nodes, func(i, j int) bool </span><span class="cov6" title="10">{
                var less bool
                ti, tj := nodes[i].Task, nodes[j].Task

                switch sortBy </span>{
                case "status":<span class="cov0" title="0">
                        less = ti.Status &lt; tj.Status</span>
                case "summary":<span class="cov5" title="7">
                        less = strings.ToLower(ti.Summary) &lt; strings.ToLower(tj.Summary)</span>
                case "priority":<span class="cov3" title="3">
                        // Lower priority number = higher priority (1 is highest)
                        // 0 means undefined, should go last
                        pi, pj := ti.Priority, tj.Priority
                        if pi == 0 &amp;&amp; pj == 0 </span><span class="cov0" title="0">{
                                less = false
                        }</span> else<span class="cov3" title="3"> if pi == 0 </span><span class="cov0" title="0">{
                                less = false // undefined goes last
                        }</span> else<span class="cov3" title="3"> if pj == 0 </span><span class="cov0" title="0">{
                                less = true // undefined goes last
                        }</span> else<span class="cov3" title="3"> {
                                less = pi &lt; pj
                        }</span>
                case "due_date":<span class="cov0" title="0">
                        less = compareDatePointers(ti.DueDate, tj.DueDate, true)</span>
                case "start_date":<span class="cov0" title="0">
                        less = compareDatePointers(ti.StartDate, tj.StartDate, true)</span>
                case "created":<span class="cov0" title="0">
                        less = compareDatePointers(&amp;ti.Created, &amp;tj.Created, true)</span>
                case "modified":<span class="cov0" title="0">
                        less = compareDatePointers(&amp;ti.Modified, &amp;tj.Modified, true)</span>
                default:<span class="cov0" title="0">
                        less = false</span>
                }

                <span class="cov6" title="10">if ascending </span><span class="cov5" title="7">{
                        return less
                }</span>
                <span class="cov3" title="3">return !less</span>
        })
}

// compareDatePointers compares two date pointers, handling nil values
// nilsLast determines whether nil values should be considered greater than non-nil
func compareDatePointers(a, b *time.Time, nilsLast bool) bool <span class="cov0" title="0">{
        if a == nil &amp;&amp; b == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if a == nil </span><span class="cov0" title="0">{
                return !nilsLast
        }</span>
        <span class="cov0" title="0">if b == nil </span><span class="cov0" title="0">{
                return nilsLast
        }</span>
        <span class="cov0" title="0">return a.Before(*b)</span>
}

// addParentIndicator adds a visual indicator to parent tasks showing they have children.
// It adds a prefix symbol () and child count to the first line of the task output.
//
// This function works for all tasks with children, regardless of hierarchy level:
// - Root parents (tasks at the top level)
// - Intermediate parents (tasks that are both children AND have their own children)
// - Deeply nested parents (at any level of the hierarchy)
//
// Example transformations:
// Input:  "   Phase 1\n"
// Output: "    Phase 1 (3)\n"  (if Phase 1 has 3 children)
func addParentIndicator(taskOutput string, childCount int) string <span class="cov4" title="5">{
        lines := strings.Split(taskOutput, "\n")
        if len(lines) == 0 </span><span class="cov0" title="0">{
                return taskOutput
        }</span>

        // Add the parent indicator to the first line
        // Format: " [original first line] (N)"
        <span class="cov4" title="5">firstLine := lines[0]

        // Insert the indicator at the beginning (after any leading spaces)
        trimmed := strings.TrimLeft(firstLine, " ")
        leadingSpaces := firstLine[:len(firstLine)-len(trimmed)]

        lines[0] = leadingSpaces + " " + trimmed + fmt.Sprintf(" (%d)", childCount)

        return strings.Join(lines, "\n")</span>
}

// FormatTaskTree formats a task tree with box-drawing characters for hierarchical display
func FormatTaskTree(nodes []*TaskNode, view string, taskManager backend.TaskManager, dateFormat string) string <span class="cov1" title="1">{
        var result strings.Builder
        formatNode(&amp;result, nodes, "", true, view, taskManager, dateFormat)
        return result.String()
}</span>

// formatNode recursively formats a task node with proper indentation
func formatNode(result *strings.Builder, nodes []*TaskNode, prefix string, isRoot bool, view string, taskManager backend.TaskManager, dateFormat string) <span class="cov3" title="3">{
        for i, node := range nodes </span><span class="cov4" title="6">{
                isLast := i == len(nodes)-1

                // Determine the tree characters
                var nodePrefix, childPrefix string
                if isRoot </span><span class="cov1" title="1">{
                        nodePrefix = ""
                        childPrefix = ""
                }</span> else<span class="cov4" title="5"> {
                        if isLast </span><span class="cov2" title="2">{
                                nodePrefix = prefix + " "
                                childPrefix = prefix + "   "
                        }</span> else<span class="cov3" title="3"> {
                                nodePrefix = prefix + " "
                                childPrefix = prefix + "  "
                        }</span>
                }

                // Format the task
                <span class="cov4" title="6">taskOutput := node.Task.FormatWithView(view, taskManager, dateFormat)

                // Add parent indicator if this task has children
                // This works for ALL tasks with children, including:
                // - Root parents (top-level tasks with children)
                // - Intermediate parents (tasks that are both parents AND children themselves)
                // - Any level of nesting (grandparents, great-grandparents, etc.)
                if len(node.Children) &gt; 0 </span><span class="cov2" title="2">{
                        taskOutput = addParentIndicator(taskOutput, len(node.Children))
                }</span>

                // Add indentation to each line of the task output
                <span class="cov4" title="6">if nodePrefix != "" </span><span class="cov4" title="5">{
                        lines := strings.Split(strings.TrimRight(taskOutput, "\n"), "\n")
                        for j, line := range lines </span><span class="cov4" title="5">{
                                if j == 0 </span><span class="cov4" title="5">{
                                        result.WriteString(nodePrefix)
                                }</span> else<span class="cov0" title="0"> {
                                        // Continuation lines use the child prefix
                                        if isLast </span><span class="cov0" title="0">{
                                                result.WriteString(prefix + "   ")
                                        }</span> else<span class="cov0" title="0"> {
                                                result.WriteString(prefix + "  ")
                                        }</span>
                                }
                                <span class="cov4" title="5">result.WriteString(line)
                                result.WriteString("\n")</span>
                        }
                } else<span class="cov1" title="1"> {
                        result.WriteString(taskOutput)
                }</span>

                // Recursively format children
                <span class="cov4" title="6">if len(node.Children) &gt; 0 </span><span class="cov2" title="2">{
                        formatNode(result, node.Children, childPrefix, false, view, taskManager, dateFormat)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package operations

import (
        "fmt"
        "gosynctasks/backend"
        "gosynctasks/internal/cli"
        "gosynctasks/internal/config"
        "gosynctasks/internal/utils"
        "strings"

        "github.com/spf13/cobra"
)

// FindTaskBySummary searches for a task by summary and handles UX for exact/partial/multiple matches
// If filter is provided, it will be applied to the search results to exclude certain tasks
func FindTaskBySummary(taskManager backend.TaskManager, cfg *config.Config, listID string, searchSummary string, filter *backend.TaskFilter) (*backend.Task, error) <span class="cov5" title="6">{
        // Use backend's search method
        matches, err := taskManager.FindTasksBySummary(listID, searchSummary)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("error searching for tasks: %w", err)
        }</span>

        // Apply filter to exclude certain tasks (e.g., completed tasks)
        <span class="cov5" title="5">if filter != nil &amp;&amp; filter.ExcludeStatuses != nil &amp;&amp; len(*filter.ExcludeStatuses) &gt; 0 </span><span class="cov0" title="0">{
                excludeMap := make(map[string]bool)
                for _, status := range *filter.ExcludeStatuses </span><span class="cov0" title="0">{
                        excludeMap[status] = true
                }</span>

                <span class="cov0" title="0">var filtered []backend.Task
                for _, task := range matches </span><span class="cov0" title="0">{
                        if !excludeMap[task.Status] </span><span class="cov0" title="0">{
                                filtered = append(filtered, task)
                        }</span>
                }
                <span class="cov0" title="0">matches = filtered</span>
        }

        <span class="cov5" title="5">if len(matches) == 0 </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("no tasks found matching '%s'", searchSummary)
        }</span>

        // Separate exact and partial matches
        <span class="cov4" title="3">var exactMatches []backend.Task
        var partialMatches []backend.Task
        searchLower := strings.ToLower(searchSummary)

        for _, task := range matches </span><span class="cov4" title="3">{
                if strings.ToLower(task.Summary) == searchLower </span><span class="cov4" title="3">{
                        exactMatches = append(exactMatches, task)
                }</span> else<span class="cov0" title="0"> {
                        partialMatches = append(partialMatches, task)
                }</span>
        }

        // Single exact match - proceed without confirmation
        <span class="cov4" title="3">if len(exactMatches) == 1 &amp;&amp; len(partialMatches) == 0 </span><span class="cov4" title="3">{
                return &amp;exactMatches[0], nil
        }</span>

        // Single partial match - ask for confirmation
        <span class="cov0" title="0">if len(exactMatches) == 0 &amp;&amp; len(partialMatches) == 1 </span><span class="cov0" title="0">{
                task := &amp;partialMatches[0]
                confirmed, err := confirmTask(task, taskManager, cfg)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if !confirmed </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("operation cancelled")
                }</span>
                <span class="cov0" title="0">return task, nil</span>
        }

        // Multiple matches (exact or partial) - prompt selection with hierarchical paths
        <span class="cov0" title="0">if len(exactMatches) &gt; 1 </span><span class="cov0" title="0">{
                return selectTask(exactMatches, searchSummary, taskManager, cfg, listID)
        }</span>

        // Mix of exact and partial, or multiple partial
        <span class="cov0" title="0">return selectTask(matches, searchSummary, taskManager, cfg, listID)</span>
}

// selectTask shows a list of tasks and prompts user to select one
// Now includes hierarchical paths for disambiguation
func selectTask(tasks []backend.Task, searchSummary string, taskManager backend.TaskManager, cfg *config.Config, listID string) (*backend.Task, error) <span class="cov0" title="0">{
        if len(tasks) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no tasks found matching '%s'", searchSummary)
        }</span>

        // Get all tasks to build hierarchy
        <span class="cov0" title="0">allTasks, err := taskManager.GetTasks(listID, nil)
        if err != nil </span><span class="cov0" title="0">{
                // Fall back to simple display if we can't get all tasks
                return selectTaskSimple(tasks, searchSummary, taskManager, cfg)
        }</span>

        // Build UID to task map for path resolution
        <span class="cov0" title="0">taskMap := make(map[string]*backend.Task)
        for i := range allTasks </span><span class="cov0" title="0">{
                taskMap[allTasks[i].UID] = &amp;allTasks[i]
        }</span>

        // Show tasks with hierarchical paths and "all" view
        <span class="cov0" title="0">fmt.Printf("\n%d tasks found matching '%s':\n", len(tasks), searchSummary)
        dateFormat := cfg.GetDateFormat()

        for i, task := range tasks </span><span class="cov0" title="0">{
                // Get hierarchical path
                path := GetTaskPath(&amp;task, taskMap)
                fmt.Printf("\n%d: [%s]", i+1, path)
                fmt.Print(task.FormatWithView("all", taskManager, dateFormat))
        }</span>

        <span class="cov0" title="0">fmt.Printf("\nSelect task (1-%d) or 0 to skip: ", len(tasks))
        choice, err := utils.ReadInt()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid input: %w", err)
        }</span>

        <span class="cov0" title="0">if choice == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("operation cancelled")
        }</span>

        <span class="cov0" title="0">if choice &lt; 1 || choice &gt; len(tasks) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid choice: %d", choice)
        }</span>

        <span class="cov0" title="0">return &amp;tasks[choice-1], nil</span>
}

// selectTaskSimple is a fallback that doesn't show hierarchical paths
func selectTaskSimple(tasks []backend.Task, searchSummary string, taskManager backend.TaskManager, cfg *config.Config) (*backend.Task, error) <span class="cov0" title="0">{
        fmt.Printf("\n%d tasks found matching '%s':\n", len(tasks), searchSummary)
        dateFormat := cfg.GetDateFormat()

        for i, task := range tasks </span><span class="cov0" title="0">{
                fmt.Printf("\n%d:", i+1)
                fmt.Print(task.FormatWithView("all", taskManager, dateFormat))
        }</span>

        <span class="cov0" title="0">fmt.Printf("\nSelect task (1-%d) or 0 to skip: ", len(tasks))
        choice, err := utils.ReadInt()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid input: %w", err)
        }</span>

        <span class="cov0" title="0">if choice == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("operation cancelled")
        }</span>

        <span class="cov0" title="0">if choice &lt; 1 || choice &gt; len(tasks) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid choice: %d", choice)
        }</span>

        <span class="cov0" title="0">return &amp;tasks[choice-1], nil</span>
}

// GetTaskPath returns the hierarchical path of a task (e.g., "Feature X / Write code / Fix bug")
// This is exported so it can be used by other packages
func GetTaskPath(task *backend.Task, taskMap map[string]*backend.Task) string <span class="cov0" title="0">{
        var parts []string
        current := task

        // Walk up the parent chain
        for current != nil </span><span class="cov0" title="0">{
                parts = append([]string{current.Summary}, parts...)
                if current.ParentUID == "" </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">current = taskMap[current.ParentUID]</span>
        }

        <span class="cov0" title="0">return strings.Join(parts, " / ")</span>
}

// confirmTask shows task details and asks for confirmation
func confirmTask(task *backend.Task, taskManager backend.TaskManager, cfg *config.Config) (bool, error) <span class="cov0" title="0">{
        dateFormat := cfg.GetDateFormat()
        fmt.Println("\nTask found:")
        fmt.Print(task.FormatWithView("all", taskManager, dateFormat))
        fmt.Println()
        return utils.PromptConfirmation("Proceed with this task?")
}</span>

// SelectTaskInteractively displays all tasks from a list and prompts user to select one
// If filter is nil, all tasks are shown
func SelectTaskInteractively(taskManager backend.TaskManager, cfg *config.Config, listID string, filter *backend.TaskFilter) (*backend.Task, error) <span class="cov2" title="2">{
        // Get tasks from the list (with optional filter)
        allTasks, err := taskManager.GetTasks(listID, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error retrieving tasks: %w", err)
        }</span>

        <span class="cov2" title="2">if len(allTasks) == 0 </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("no tasks available in this list")
        }</span>

        // Sort tasks using backend-specific sorting
        <span class="cov0" title="0">taskManager.SortTasks(allTasks)

        // Build task tree for hierarchical display
        tree := BuildTaskTree(allTasks)

        // Build flat list for selection
        var flatTasks []*backend.Task
        buildFlatTaskList(tree, &amp;flatTasks)

        // Get terminal width and calculate border width
        termWidth := cli.GetTerminalWidth()
        borderWidth := termWidth - 2
        if borderWidth &lt; 40 </span><span class="cov0" title="0">{
                borderWidth = 40 // Minimum width
        }</span>
        <span class="cov0" title="0">if borderWidth &gt; 100 </span><span class="cov0" title="0">{
                borderWidth = 100 // Maximum width for readability
        }</span>

        // Display tasks with numbering - dynamic header
        <span class="cov0" title="0">headerText := " Available Tasks "
        headerPadding := borderWidth - len(headerText)
        if headerPadding &lt; 0 </span><span class="cov0" title="0">{
                headerPadding = 0
        }</span>
        <span class="cov0" title="0">fmt.Printf("\n\033[1;36m%s%s\033[0m\n", headerText, strings.Repeat("", headerPadding))

        // Format and print the tree
        output, _ := formatTaskTreeNumbered(tree, taskManager, cfg.GetDateFormat(), 1, "", true)
        fmt.Print(output)

        // Display footer with dynamic width
        fmt.Printf("\033[1;36m%s\033[0m\n", strings.Repeat("", borderWidth))

        // Prompt for selection
        fmt.Printf("\n\033[1mSelect task (1-%d, or 0 to cancel):\033[0m ", len(flatTasks))
        choice, err := utils.ReadInt()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid input")
        }</span>

        <span class="cov0" title="0">if choice == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cancelled")
        }</span>

        <span class="cov0" title="0">if choice &lt; 1 || choice &gt; len(flatTasks) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid choice: %d (must be 1-%d)", choice, len(flatTasks))
        }</span>

        <span class="cov0" title="0">return flatTasks[choice-1], nil</span>
}

// buildFlatTaskList recursively builds a flat list of tasks from the tree
// This is useful for numbered selection where we need sequential access
func buildFlatTaskList(nodes []*TaskNode, flatTasks *[]*backend.Task) <span class="cov7" title="11">{
        for _, node := range nodes </span><span class="cov8" title="15">{
                *flatTasks = append(*flatTasks, node.Task)
                if len(node.Children) &gt; 0 </span><span class="cov5" title="5">{
                        buildFlatTaskList(node.Children, flatTasks)
                }</span>
        }
}

// formatTaskTreeNumbered recursively formats tasks with numbering and hierarchy
// Returns a string representation instead of printing directly (for testability)
func formatTaskTreeNumbered(nodes []*TaskNode, taskManager backend.TaskManager, dateFormat string, startNum int, prefix string, isRoot bool) (string, int) <span class="cov8" title="15">{
        var result strings.Builder
        currentNum := startNum

        for i, node := range nodes </span><span class="cov8" title="18">{
                isLast := i == len(nodes)-1

                // Determine the tree characters
                var nodePrefix, childPrefix string
                if isRoot </span><span class="cov6" title="8">{
                        nodePrefix = ""
                        childPrefix = ""
                }</span> else<span class="cov7" title="10"> {
                        if isLast </span><span class="cov6" title="8">{
                                nodePrefix = prefix + " "
                                childPrefix = prefix + "   "
                        }</span> else<span class="cov2" title="2"> {
                                nodePrefix = prefix + " "
                                childPrefix = prefix + "  "
                        }</span>
                }

                // Format task number with color
                <span class="cov8" title="18">numColor := "\033[36m" // Cyan
                reset := "\033[0m"

                // Display task with number and hierarchy
                taskOutput := node.Task.FormatWithView("default", taskManager, dateFormat)
                lines := strings.Split(taskOutput, "\n")

                // First line with number and tree prefix
                if len(lines) &gt; 0 &amp;&amp; lines[0] != "" </span><span class="cov8" title="18">{
                        result.WriteString(fmt.Sprintf("  %s%2d.%s %s%s\n", numColor, currentNum, reset, nodePrefix, lines[0]))
                        currentNum++

                        // Additional lines maintain indentation
                        for j := 1; j &lt; len(lines); j++ </span><span class="cov8" title="18">{
                                if lines[j] != "" </span><span class="cov0" title="0">{
                                        indent := "     " // Space for number
                                        if !isRoot </span><span class="cov0" title="0">{
                                                indent += childPrefix
                                        }</span>
                                        <span class="cov0" title="0">result.WriteString(fmt.Sprintf("%s%s\n", indent, lines[j]))</span>
                                }
                        }
                }

                // Recursively format children
                <span class="cov8" title="18">if len(node.Children) &gt; 0 </span><span class="cov6" title="8">{
                        childOutput, newNum := formatTaskTreeNumbered(node.Children, taskManager, dateFormat, currentNum, childPrefix, false)
                        result.WriteString(childOutput)
                        currentNum = newNum
                }</span>
        }

        <span class="cov8" title="15">return result.String(), currentNum</span>
}

// displayTaskTreeNumbered recursively displays tasks with numbering and hierarchy
// This is the original function maintained for backward compatibility
func displayTaskTreeNumbered(nodes []*TaskNode, taskManager backend.TaskManager, dateFormat string, flatTasks *[]*backend.Task, prefix string, isRoot bool) <span class="cov0" title="0">{
        // Build flat list
        buildFlatTaskList(nodes, flatTasks)

        // Format and print the tree
        output, _ := formatTaskTreeNumbered(nodes, taskManager, dateFormat, 1, prefix, isRoot)
        fmt.Print(output)
}</span>

// BuildFilter constructs a TaskFilter from cobra command flags
// Uses the backend's ParseStatusFlag to convert user input to backend-specific format
func BuildFilter(cmd *cobra.Command, taskManager backend.TaskManager) (*backend.TaskFilter, error) <span class="cov9" title="22">{
        filter := &amp;backend.TaskFilter{}

        // Get status flags (errors ignored as flags are always defined by the command)
        statuses, _ := cmd.Flags().GetStringArray("status")
        if len(statuses) &gt; 0 </span><span class="cov9" title="21">{
                var allStatuses []string
                for _, status := range statuses </span><span class="cov9" title="22">{
                        // Split by comma and trim spaces
                        parts := strings.SplitSeq(status, ",")
                        for part := range parts </span><span class="cov10" title="27">{
                                allStatuses = append(allStatuses, strings.TrimSpace(part))
                        }</span>
                }

                // Parse each status using backend's parser
                <span class="cov9" title="21">var parsedStatuses []string
                for _, status := range allStatuses </span><span class="cov10" title="27">{
                        parsed, err := taskManager.ParseStatusFlag(status)
                        if err != nil </span><span class="cov2" title="2">{
                                return nil, fmt.Errorf("invalid status '%s': %w", status, err)
                        }</span>
                        <span class="cov9" title="25">parsedStatuses = append(parsedStatuses, parsed)</span>
                }
                <span class="cov9" title="19">filter.Statuses = &amp;parsedStatuses</span>
        }

        <span class="cov9" title="20">return filter, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package utils

import (
        "bufio"
        "fmt"
        "os"
        "strconv"
        "strings"
)

// ReadInt reads an integer from stdin using bufio.NewReader
// This avoids the buffer issues that fmt.Scanf has with leftover newlines
func ReadInt() (int, error) <span class="cov0" title="0">{
        reader := bufio.NewReader(os.Stdin)
        input, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to read input: %w", err)
        }</span>

        <span class="cov0" title="0">input = strings.TrimSpace(input)
        value, err := strconv.Atoi(input)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid number: %w", err)
        }</span>

        <span class="cov0" title="0">return value, nil</span>
}

// ReadString reads a string from stdin using bufio.NewReader
// This avoids the buffer issues that fmt.Scanf has with leftover newlines
func ReadString() (string, error) <span class="cov0" title="0">{
        reader := bufio.NewReader(os.Stdin)
        input, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read input: %w", err)
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(input), nil</span>
}

// PromptYesNo prompts the user with a yes/no question and returns the result
func PromptYesNo(question string) bool <span class="cov10" title="35">{
        reader := bufio.NewReader(os.Stdin)
        for </span><span class="cov10" title="35">{
                fmt.Printf("%s (y/n): ", question)
                response, _ := reader.ReadString('\n')
                response = strings.ToLower(strings.TrimSpace(response))

                switch response </span>{
                case "y", "yes":<span class="cov8" title="18">
                        return true</span>
                case "n", "no":<span class="cov8" title="17">
                        return false</span>
                default:<span class="cov0" title="0">
                        fmt.Println("Please enter y or n")
                        return PromptYesNo(question)</span>
                }
        }
}

// PromptSelection displays a numbered list of items and prompts user to select one
// displayFunc is called for each item to display it
// Returns the selected index (0-based) and an error if cancelled or invalid input
func PromptSelection[T any](items []T, prompt string, displayFunc func(int, T)) (int, error) <span class="cov0" title="0">{
        if len(items) == 0 </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("no items to select from")
        }</span>

        // Display items
        <span class="cov0" title="0">for i, item := range items </span><span class="cov0" title="0">{
                displayFunc(i, item)
        }</span>

        // Prompt for selection
        <span class="cov0" title="0">fmt.Printf("\n%s (1-%d) or 0 to cancel: ", prompt, len(items))
        choice, err := ReadInt()
        if err != nil </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("invalid input: %w", err)
        }</span>

        // Check for cancellation
        <span class="cov0" title="0">if choice == 0 </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("operation cancelled")
        }</span>

        // Validate choice
        <span class="cov0" title="0">if choice &lt; 1 || choice &gt; len(items) </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("invalid choice: %d (must be 1-%d)", choice, len(items))
        }</span>

        // Return 0-based index
        <span class="cov0" title="0">return choice - 1, nil</span>
}

// PromptConfirmation displays a message and prompts for y/n confirmation
// Returns true if user confirms, false otherwise, and error for invalid input
func PromptConfirmation(message string) (bool, error) <span class="cov0" title="0">{
        fmt.Print(message + " (y/n): ")
        response, err := ReadString()
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("invalid input: %w", err)
        }</span>

        <span class="cov0" title="0">response = strings.ToLower(response)
        return response == "y" || response == "yes", nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package utils

import (
        "encoding/json"
        "fmt"

        "gopkg.in/yaml.v3"
)

// OutputJSON marshals the provided data as indented JSON and prints it to stdout.
// Returns an error if marshaling fails.
func OutputJSON(data interface{}) error <span class="cov7" title="4">{
        jsonData, err := MarshalJSON(data)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov6" title="3">fmt.Println(string(jsonData))
        return nil</span>
}

// OutputYAML marshals the provided data as YAML and prints it to stdout.
// Returns an error if marshaling fails.
func OutputYAML(data interface{}) error <span class="cov7" title="4">{
        yamlData, err := MarshalYAML(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov7" title="4">fmt.Print(string(yamlData))
        return nil</span>
}

// MarshalJSON marshals the provided data as indented JSON.
// Returns the JSON bytes or an error if marshaling fails.
func MarshalJSON(data interface{}) ([]byte, error) <span class="cov10" title="7">{
        jsonData, err := json.MarshalIndent(data, "", "  ")
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to marshal JSON: %w", err)
        }</span>
        <span class="cov9" title="6">return jsonData, nil</span>
}

// MarshalYAML marshals the provided data as YAML.
// Returns the YAML bytes or an error if marshaling fails.
func MarshalYAML(data interface{}) ([]byte, error) <span class="cov10" title="7">{
        yamlData, err := yaml.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal YAML: %w", err)
        }</span>
        <span class="cov10" title="7">return yamlData, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package utils

import (
        "fmt"
        "time"
)

// ValidatePriority checks if priority is within valid range (0-9)
func ValidatePriority(priority int) error <span class="cov0" title="0">{
        if priority &lt; 0 || priority &gt; 9 </span><span class="cov0" title="0">{
                return fmt.Errorf("priority must be between 0-9 (0=undefined, 1=highest, 9=lowest)")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ParseDateFlag parses a date string in ISO format (YYYY-MM-DD).
// Returns nil for empty strings (used to clear dates).
// Returns error for invalid formats or dates.
func ParseDateFlag(dateStr string) (*time.Time, error) <span class="cov0" title="0">{
        // Empty string means clear the date
        if dateStr == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Parse ISO date format (YYYY-MM-DD) in local timezone
        <span class="cov0" title="0">parsedDate, err := time.ParseInLocation("2006-01-02", dateStr, time.Local)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid date format '%s': expected YYYY-MM-DD (e.g., 2025-01-31)", dateStr)
        }</span>

        <span class="cov0" title="0">return &amp;parsedDate, nil</span>
}

// ValidateDates checks that start and due dates are logically consistent.
// If both are provided, start date must be before or equal to due date.
func ValidateDates(startDate, dueDate *time.Time) error <span class="cov0" title="0">{
        // If either is nil, no validation needed
        if startDate == nil || dueDate == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Start date must be before or equal to due date
        <span class="cov0" title="0">if startDate.After(*dueDate) </span><span class="cov0" title="0">{
                return fmt.Errorf("start date (%s) cannot be after due date (%s)",
                        startDate.Format("2006-01-02"),
                        dueDate.Format("2006-01-02"))
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package builder

import (
        "fmt"
        "gosynctasks/internal/views"

        tea "github.com/charmbracelet/bubbletea"
)

// Run starts the interactive view builder and returns the built view or an error.
// The viewName parameter sets the name of the view being created.
// Returns an error if the user cancels or if validation fails.
func Run(viewName string) (*views.View, error) <span class="cov0" title="0">{
        builder := NewViewBuilder(viewName)
        model := newModel(builder)

        p := tea.NewProgram(model, tea.WithAltScreen())
        finalModel, err := p.Run()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error running interactive builder: %w", err)
        }</span>

        // Get the result from the final model using type switch
        <span class="cov0" title="0">switch m := finalModel.(type) </span>{
        case builderModel:<span class="cov0" title="0">
                if m.builder.CurrentState == StateCancelled </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cancelled by user")
                }</span>

                <span class="cov0" title="0">if m.builder.View != nil </span><span class="cov0" title="0">{
                        return m.builder.View, nil
                }</span>

                // Build the view from builder state
                <span class="cov0" title="0">view, err := m.builder.BuildView()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">return view, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unexpected model type")</span>
        }
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package builder

import (
        "fmt"
        "strings"

        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

// builderModel is the bubbletea model for the view builder.
// It manages UI state including cursor position, text input, and error messages.
type builderModel struct {
        builder       *ViewBuilder
        textInput     textinput.Model
        cursor        int
        selectedIndex int
        quitting      bool
        width         int
        height        int
        errorMsg      string // Error message to display to user
}

// newModel creates a new bubbletea builderModel
func newModel(builder *ViewBuilder) builderModel <span class="cov10" title="27">{
        ti := textinput.New()
        ti.Placeholder = "Enter view description..."
        ti.Focus()
        ti.Width = 50

        return builderModel{
                builder:   builder,
                textInput: ti,
                cursor:    0,
                width:     80,
                height:    24,
        }
}</span>

// Init initializes the builderModel
func (m builderModel) Init() tea.Cmd <span class="cov1" title="1">{
        return textinput.Blink
}</span>

// Update handles messages and updates builderModel state
func (m builderModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov6" title="7">{
        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov1" title="1">
                m.width = msg.Width
                m.height = msg.Height
                return m, nil</span>

        case tea.KeyMsg:<span class="cov5" title="6">
                switch msg.String() </span>{
                case "ctrl+c", "esc":<span class="cov2" title="2">
                        m.builder.CurrentState = StateCancelled
                        m.quitting = true
                        return m, tea.Quit</span>

                case "y", "Y":<span class="cov1" title="1">
                        if m.builder.CurrentState == StateConfirm </span><span class="cov1" title="1">{
                                // Build and save
                                view, err := m.builder.BuildView()
                                if err != nil </span><span class="cov0" title="0">{
                                        m.builder.Err = err
                                        m.builder.CurrentState = StateCancelled
                                }</span> else<span class="cov1" title="1"> {
                                        m.builder.View = view
                                        m.builder.CurrentState = StateDone
                                }</span>
                                <span class="cov1" title="1">m.quitting = true
                                return m, tea.Quit</span>
                        }

                case "n", "N":<span class="cov1" title="1">
                        if m.builder.CurrentState == StateConfirm </span><span class="cov1" title="1">{
                                m.builder.CurrentState = StateCancelled
                                m.quitting = true
                                return m, tea.Quit
                        }</span>

                case "enter":<span class="cov0" title="0">
                        return m.handleEnter()</span>

                case "up", "k":<span class="cov0" title="0">
                        return m.handleUp()</span>

                case "down", "j":<span class="cov0" title="0">
                        return m.handleDown()</span>

                case " ":<span class="cov0" title="0">
                        return m.handleSpace()</span>

                case "ctrl+up":<span class="cov1" title="1">
                        return m.handleMoveUp()</span>

                case "ctrl+down":<span class="cov1" title="1">
                        return m.handleMoveDown()</span>

                case "tab":<span class="cov0" title="0">
                        return m.handleNext()</span>

                case "shift+tab":<span class="cov0" title="0">
                        return m.handlePrevious()</span>
                }
        }

        // Handle text input for certain states
        <span class="cov0" title="0">if m.builder.CurrentState == StateBasicInfo </span><span class="cov0" title="0">{
                var cmd tea.Cmd
                m.textInput, cmd = m.textInput.Update(msg)
                return m, cmd
        }</span>

        <span class="cov0" title="0">return m, nil</span>
}

// View renders the UI
func (m builderModel) View() string <span class="cov2" title="2">{
        if m.quitting </span><span class="cov1" title="1">{
                return ""
        }</span>

        <span class="cov1" title="1">var s strings.Builder

        // Header
        s.WriteString(m.renderHeader())
        s.WriteString("\n\n")

        // Current state view
        switch m.builder.CurrentState </span>{
        case StateWelcome:<span class="cov1" title="1">
                s.WriteString(m.renderWelcome())</span>
        case StateBasicInfo:<span class="cov0" title="0">
                s.WriteString(m.renderBasicInfo())</span>
        case StateFieldSelection:<span class="cov0" title="0">
                s.WriteString(m.renderFieldSelection())</span>
        case StateFieldOrdering:<span class="cov0" title="0">
                s.WriteString(m.renderFieldOrdering())</span>
        case StateFieldConfig:<span class="cov0" title="0">
                s.WriteString(m.renderFieldConfig())</span>
        case StateDisplayOptions:<span class="cov0" title="0">
                s.WriteString(m.renderDisplayOptions())</span>
        case StateFilterConfig:<span class="cov0" title="0">
                s.WriteString(m.renderFilterConfig())</span>
        case StateConfirm:<span class="cov0" title="0">
                s.WriteString(m.renderConfirm())</span>
        }

        <span class="cov1" title="1">s.WriteString("\n\n")

        // Show error message if any
        if m.errorMsg != "" </span><span class="cov1" title="1">{
                errorStyle := lipgloss.NewStyle().
                        Foreground(lipgloss.Color("196")).
                        Bold(true)
                s.WriteString(errorStyle.Render(" " + m.errorMsg))
                s.WriteString("\n\n")
        }</span>

        <span class="cov1" title="1">s.WriteString(m.renderHelp())

        return s.String()</span>
}

// renderHeader renders the header with current state
func (m builderModel) renderHeader() string <span class="cov1" title="1">{
        title := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("39")).
                Render("Interactive View Builder")

        step := fmt.Sprintf("Step %d/7: %s", m.getStateNumber(), m.builder.CurrentState.String())
        stepStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("241"))

        return fmt.Sprintf("%s\n%s", title, stepStyle.Render(step))
}</span>

// getStateNumber returns the current step number
func (m builderModel) getStateNumber() int <span class="cov7" title="9">{
        switch m.builder.CurrentState </span>{
        case StateWelcome:<span class="cov2" title="2">
                return 0</span>
        case StateBasicInfo:<span class="cov1" title="1">
                return 1</span>
        case StateFieldSelection:<span class="cov1" title="1">
                return 2</span>
        case StateFieldOrdering:<span class="cov1" title="1">
                return 3</span>
        case StateFieldConfig:<span class="cov1" title="1">
                return 4</span>
        case StateDisplayOptions:<span class="cov1" title="1">
                return 5</span>
        case StateFilterConfig:<span class="cov1" title="1">
                return 6</span>
        case StateConfirm:<span class="cov1" title="1">
                return 7</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

// renderHelp renders the help text at the bottom
func (m builderModel) renderHelp() string <span class="cov1" title="1">{
        helpStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("241"))

        var help string
        switch m.builder.CurrentState </span>{
        case StateWelcome:<span class="cov1" title="1">
                help = "enter: continue  ctrl+c: cancel"</span>
        case StateBasicInfo:<span class="cov0" title="0">
                help = "enter: continue  ctrl+c: cancel"</span>
        case StateFieldSelection:<span class="cov0" title="0">
                help = "/: navigate  space: toggle  enter: continue  ctrl+c: cancel"</span>
        case StateFieldOrdering:<span class="cov0" title="0">
                help = "/: navigate  ctrl+/: move  enter: continue  ctrl+c: cancel"</span>
        case StateFieldConfig:<span class="cov0" title="0">
                help = "/: navigate  space: toggle  tab: next field  enter: continue  ctrl+c: cancel"</span>
        case StateDisplayOptions:<span class="cov0" title="0">
                help = "/: navigate  space: toggle  enter: continue  ctrl+c: cancel"</span>
        case StateFilterConfig:<span class="cov0" title="0">
                help = "/: navigate  space: toggle  enter: continue  ctrl+c: cancel"</span>
        case StateConfirm:<span class="cov0" title="0">
                help = "y: save  n: cancel  ctrl+c: cancel"</span>
        }

        <span class="cov1" title="1">return helpStyle.Render(help)</span>
}

// State transition handlers

func (m builderModel) handleEnter() (tea.Model, tea.Cmd) <span class="cov8" title="13">{
        switch m.builder.CurrentState </span>{
        case StateWelcome:<span class="cov2" title="2">
                m.builder.CurrentState = StateBasicInfo
                m.textInput.SetValue(m.builder.ViewDescription)
                m.textInput.Focus()</span>

        case StateBasicInfo:<span class="cov2" title="2">
                m.builder.ViewDescription = m.textInput.Value()
                m.builder.CurrentState = StateFieldSelection
                m.cursor = 0</span>

        case StateFieldSelection:<span class="cov5" title="5">
                m.builder.UpdateSelectedFields()

                // Validation: At least one field must be selected
                if len(m.builder.SelectedFields) == 0 </span><span class="cov2" title="2">{
                        m.errorMsg = "Please select at least one field"
                        return m, nil
                }</span>

                <span class="cov4" title="3">m.errorMsg = "" // Clear any previous error
                m.builder.UpdateFieldOrder()
                m.builder.CurrentState = StateFieldOrdering
                m.cursor = 0</span>

        case StateFieldOrdering:<span class="cov1" title="1">
                m.builder.CurrentState = StateFieldConfig
                m.cursor = 0
                m.selectedIndex = 0</span>

        case StateFieldConfig:<span class="cov1" title="1">
                m.builder.CurrentState = StateDisplayOptions
                m.cursor = 0</span>

        case StateDisplayOptions:<span class="cov1" title="1">
                m.builder.CurrentState = StateFilterConfig
                m.cursor = 0</span>

        case StateFilterConfig:<span class="cov1" title="1">
                m.builder.CurrentState = StateConfirm
                m.cursor = 0</span>

        case StateConfirm:<span class="cov0" title="0">
                // Build and save
                view, err := m.builder.BuildView()
                if err != nil </span><span class="cov0" title="0">{
                        m.builder.Err = err
                        m.builder.CurrentState = StateCancelled
                }</span> else<span class="cov0" title="0"> {
                        m.builder.View = view
                        m.builder.CurrentState = StateDone
                }</span>
                <span class="cov0" title="0">m.quitting = true
                return m, tea.Quit</span>
        }

        <span class="cov7" title="11">return m, nil</span>
}

func (m builderModel) handleUp() (tea.Model, tea.Cmd) <span class="cov2" title="2">{
        if m.cursor &gt; 0 </span><span class="cov1" title="1">{
                m.cursor--
        }</span>
        <span class="cov2" title="2">return m, nil</span>
}

func (m builderModel) handleDown() (tea.Model, tea.Cmd) <span class="cov2" title="2">{
        maxCursor := m.getMaxCursor()
        if m.cursor &lt; maxCursor </span><span class="cov1" title="1">{
                m.cursor++
        }</span>
        <span class="cov2" title="2">return m, nil</span>
}

func (m builderModel) handleSpace() (tea.Model, tea.Cmd) <span class="cov5" title="5">{
        switch m.builder.CurrentState </span>{
        case StateFieldSelection:<span class="cov1" title="1">
                if m.cursor &lt; len(m.builder.AvailableFields) </span><span class="cov1" title="1">{
                        m.builder.AvailableFields[m.cursor].Selected = !m.builder.AvailableFields[m.cursor].Selected
                }</span>

        case StateFieldConfig:<span class="cov1" title="1">
                // Toggle color for current field
                if m.cursor &lt; len(m.builder.FieldOrder) </span><span class="cov1" title="1">{
                        fieldName := m.builder.FieldOrder[m.cursor]
                        item := m.builder.getFieldItem(fieldName)
                        if item != nil </span><span class="cov1" title="1">{
                                item.Color = !item.Color
                        }</span>
                }

        case StateDisplayOptions:<span class="cov4" title="3">
                switch m.cursor </span>{
                case 0:<span class="cov1" title="1">
                        m.builder.ShowHeader = !m.builder.ShowHeader</span>
                case 1:<span class="cov1" title="1">
                        m.builder.ShowBorder = !m.builder.ShowBorder</span>
                case 2:<span class="cov1" title="1">
                        m.builder.CompactMode = !m.builder.CompactMode</span>
                }

        case StateFilterConfig:<span class="cov0" title="0">
                // Toggle status filter
                statuses := []string{"NEEDS-ACTION", "IN-PROCESS", "COMPLETED", "CANCELLED"}
                if m.cursor &lt; len(statuses) </span><span class="cov0" title="0">{
                        status := statuses[m.cursor]
                        // Check if status is in filter
                        found := false
                        foundIndex := -1
                        for i, s := range m.builder.FilterStatus </span><span class="cov0" title="0">{
                                if s == status </span><span class="cov0" title="0">{
                                        found = true
                                        foundIndex = i
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">if found </span><span class="cov0" title="0">{
                                // Remove from filter
                                m.builder.FilterStatus = append(
                                        m.builder.FilterStatus[:foundIndex],
                                        m.builder.FilterStatus[foundIndex+1:]...)
                        }</span> else<span class="cov0" title="0"> {
                                // Add to filter
                                m.builder.FilterStatus = append(m.builder.FilterStatus, status)
                        }</span>
                }
        }

        <span class="cov5" title="5">return m, nil</span>
}

func (m builderModel) handleMoveUp() (tea.Model, tea.Cmd) <span class="cov2" title="2">{
        if m.builder.CurrentState == StateFieldOrdering &amp;&amp; m.cursor &gt; 0 </span><span class="cov2" title="2">{
                // Swap with previous
                m.builder.FieldOrder[m.cursor], m.builder.FieldOrder[m.cursor-1] =
                        m.builder.FieldOrder[m.cursor-1], m.builder.FieldOrder[m.cursor]
                m.cursor--
        }</span>
        <span class="cov2" title="2">return m, nil</span>
}

func (m builderModel) handleMoveDown() (tea.Model, tea.Cmd) <span class="cov2" title="2">{
        if m.builder.CurrentState == StateFieldOrdering &amp;&amp; m.cursor &lt; len(m.builder.FieldOrder)-1 </span><span class="cov2" title="2">{
                // Swap with next
                m.builder.FieldOrder[m.cursor], m.builder.FieldOrder[m.cursor+1] =
                        m.builder.FieldOrder[m.cursor+1], m.builder.FieldOrder[m.cursor]
                m.cursor++
        }</span>
        <span class="cov2" title="2">return m, nil</span>
}

func (m builderModel) handleNext() (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        if m.builder.CurrentState == StateFieldConfig </span><span class="cov0" title="0">{
                if m.cursor &lt; len(m.builder.FieldOrder)-1 </span><span class="cov0" title="0">{
                        m.cursor++
                }</span>
        }
        <span class="cov0" title="0">return m, nil</span>
}

func (m builderModel) handlePrevious() (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        if m.builder.CurrentState == StateFieldConfig </span><span class="cov0" title="0">{
                if m.cursor &gt; 0 </span><span class="cov0" title="0">{
                        m.cursor--
                }</span>
        }
        <span class="cov0" title="0">return m, nil</span>
}

func (m builderModel) getMaxCursor() int <span class="cov4" title="4">{
        switch m.builder.CurrentState </span>{
        case StateFieldSelection:<span class="cov4" title="3">
                return len(m.builder.AvailableFields) - 1</span>
        case StateFieldOrdering:<span class="cov0" title="0">
                return len(m.builder.FieldOrder) - 1</span>
        case StateFieldConfig:<span class="cov0" title="0">
                return len(m.builder.FieldOrder) - 1</span>
        case StateDisplayOptions:<span class="cov1" title="1">
                return 2</span> // 3 options: ShowHeader, ShowBorder, CompactMode
        case StateFilterConfig:<span class="cov0" title="0">
                return 3</span> // 4 status options: NEEDS-ACTION, IN-PROCESS, COMPLETED, CANCELLED
        default:<span class="cov0" title="0">
                return 0</span>
        }
}
</pre>
		
		<pre class="file" id="file39" style="display: none">// Package builder provides an interactive TUI for creating custom task views.
// It uses the Charm Bubbletea framework to guide users through a step-by-step
// wizard for configuring view options, selecting fields, and customizing display.
package builder

import (
        "fmt"
        "gosynctasks/internal/views"
)

// BuilderState represents the current state in the view builder state machine.
// The builder progresses through these states in sequence from Welcome to Done/Cancelled.
type BuilderState int

const (
        // StateWelcome is the initial welcome screen
        StateWelcome BuilderState = iota
        // StateBasicInfo collects view name and description
        StateBasicInfo
        // StateFieldSelection allows selecting which fields to display
        StateFieldSelection
        // StateFieldOrdering allows reordering selected fields
        StateFieldOrdering
        // StateFieldConfig configures format and color for each field
        StateFieldConfig
        // StateDisplayOptions configures view-level display options
        StateDisplayOptions
        // StateFilterConfig allows configuration of default filters
        StateFilterConfig
        // StateConfirm shows final configuration for confirmation
        StateConfirm
        // StateDone indicates successful completion
        StateDone
        // StateCancelled indicates user cancelled the builder
        StateCancelled
)

// String returns the string representation of the state
func (s BuilderState) String() string <span class="cov4" title="10">{
        switch s </span>{
        case StateWelcome:<span class="cov2" title="2">
                return "Welcome"</span>
        case StateBasicInfo:<span class="cov1" title="1">
                return "Basic Info"</span>
        case StateFieldSelection:<span class="cov1" title="1">
                return "Field Selection"</span>
        case StateFieldOrdering:<span class="cov1" title="1">
                return "Field Ordering"</span>
        case StateFieldConfig:<span class="cov1" title="1">
                return "Field Configuration"</span>
        case StateDisplayOptions:<span class="cov1" title="1">
                return "Display Options"</span>
        case StateFilterConfig:<span class="cov0" title="0">
                return "Filter Configuration"</span>
        case StateConfirm:<span class="cov1" title="1">
                return "Confirm"</span>
        case StateDone:<span class="cov1" title="1">
                return "Done"</span>
        case StateCancelled:<span class="cov1" title="1">
                return "Cancelled"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span>
        }
}

// FieldItem represents a field with its selection and configuration state.
// It tracks whether a field is selected for display and its formatting options.
type FieldItem struct {
        Name        string // Field name (e.g., "status", "summary")
        Description string // Human-readable description from field registry
        Selected    bool   // Whether this field is selected for display
        Format      string // Display format (e.g., "symbol", "text")
        Width       int    // Display width (for truncation)
        Color       bool   // Whether to use color
        Label       string // Custom label override
}

// ViewBuilder holds the state for building a custom view through the interactive wizard.
// It maintains all configuration choices across the different builder states and produces
// the final View when complete.
type ViewBuilder struct {
        // View being built
        ViewName        string // Name of the view being created
        ViewDescription string // Optional description

        // Field selection and ordering
        AvailableFields []FieldItem // All available fields from registry
        SelectedFields  []string    // Names of selected fields
        FieldOrder      []string    // Order of selected fields

        // Current field being configured
        CurrentFieldIndex int // Index for field configuration state

        // Display options
        ShowHeader  bool   // Whether to show column headers
        ShowBorder  bool   // Whether to show borders
        CompactMode bool   // Whether to use compact single-line display
        DateFormat  string // Date format string
        SortBy      string // Field to sort by
        SortOrder   string // Sort order ("asc" or "desc")

        // Filter options
        FilterStatus []string // Status filters (e.g., "NEEDS-ACTION", "COMPLETED")

        // State management
        CurrentState BuilderState // Current state in the wizard

        // Result
        View *views.View // Built view (populated on success)
        Err  error       // Error encountered during building
}

// NewViewBuilder creates a new view builder with the given view name.
// It initializes all available fields from the field registry with sensible defaults.
// Status and summary fields are pre-selected as they are the most commonly used.
func NewViewBuilder(name string) *ViewBuilder <span class="cov6" title="40">{
        // Initialize available fields from field registry
        // This ensures single source of truth and maintains consistency
        fieldOrder := []string{"status", "summary", "description", "priority",
                "due_date", "start_date", "created", "modified", "completed",
                "tags", "uid", "parent"}

        availableFields := make([]FieldItem, 0, len(fieldOrder))

        for _, fieldName := range fieldOrder </span><span class="cov10" title="480">{
                def, ok := views.GetFieldDefinition(fieldName)
                if !ok </span><span class="cov0" title="0">{
                        continue</span> // Skip fields not in registry
                }

                // Pre-select status and summary as they're most commonly used
                <span class="cov10" title="480">selected := (fieldName == "status" || fieldName == "summary")

                // Set sensible defaults
                item := FieldItem{
                        Name:        fieldName,
                        Description: def.Description,
                        Selected:    selected,
                        Format:      def.DefaultFormat,
                        Width:       0,     // Will use default
                        Color:       false, // User can toggle in config
                        Label:       "",    // Will use default
                }

                // Description field gets special treatment for width
                if fieldName == "description" </span><span class="cov6" title="40">{
                        item.Width = 70
                }</span>

                <span class="cov10" title="480">availableFields = append(availableFields, item)</span>
        }

        <span class="cov6" title="40">return &amp;ViewBuilder{
                ViewName:        name,
                ViewDescription: "",
                AvailableFields: availableFields,
                SelectedFields:  []string{},
                FieldOrder:      []string{},
                CurrentState:    StateWelcome,
                ShowHeader:      true,
                ShowBorder:      true,
                CompactMode:     false,
                DateFormat:      "2006-01-02",
                SortBy:          "",
                SortOrder:       "asc",
                FilterStatus:    []string{"NEEDS-ACTION", "IN-PROCESS"}, // Default: filter out completed tasks
        }</span>
}

// BuildView constructs the final View from the builder state.
// It validates the configuration and returns an error if invalid.
// At minimum, at least one field must be selected.
func (b *ViewBuilder) BuildView() (*views.View, error) <span class="cov3" title="4">{
        // Validate: must have at least one selected field
        if len(b.FieldOrder) == 0 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("at least one field must be selected")
        }</span>

        // Collect selected fields
        <span class="cov2" title="3">var fields []views.FieldConfig

        for _, fieldName := range b.FieldOrder </span><span class="cov3" title="5">{
                // Find the field item using helper
                item := b.getFieldItem(fieldName)
                if item == nil || !item.Selected </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Validate format against field registry
                <span class="cov3" title="5">if !views.ValidateFieldFormat(item.Name, item.Format) </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("invalid format %q for field %q", item.Format, item.Name)
                }</span>

                <span class="cov3" title="4">showTrue := true
                field := views.FieldConfig{
                        Name:   item.Name,
                        Format: item.Format,
                        Show:   &amp;showTrue,
                        Color:  item.Color,
                }

                if item.Width &gt; 0 </span><span class="cov0" title="0">{
                        field.Width = item.Width
                }</span>

                <span class="cov3" title="4">if item.Label != "" </span><span class="cov0" title="0">{
                        field.Label = item.Label
                }</span>

                <span class="cov3" title="4">fields = append(fields, field)</span>
        }

        // Final validation: ensure we have at least one field configured
        <span class="cov2" title="2">if len(fields) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no valid fields configured")
        }</span>

        <span class="cov2" title="2">view := &amp;views.View{
                Name:        b.ViewName,
                Description: b.ViewDescription,
                Fields:      fields,
                FieldOrder:  b.FieldOrder,
                Display: views.DisplayOptions{
                        ShowHeader:  b.ShowHeader,
                        ShowBorder:  b.ShowBorder,
                        CompactMode: b.CompactMode,
                        DateFormat:  b.DateFormat,
                        SortBy:      b.SortBy,
                        SortOrder:   b.SortOrder,
                },
        }

        return view, nil</span>
}

// UpdateSelectedFields updates the list of selected field names from AvailableFields.
// This should be called after field selection changes.
func (b *ViewBuilder) UpdateSelectedFields() <span class="cov5" title="17">{
        b.SelectedFields = []string{}
        for _, field := range b.AvailableFields </span><span class="cov8" title="204">{
                if field.Selected </span><span class="cov5" title="28">{
                        b.SelectedFields = append(b.SelectedFields, field.Name)
                }</span>
        }
}

// UpdateFieldOrder sets the field order from selected fields.
// It preserves existing order for fields that remain selected and appends newly selected fields.
// This is optimized to O(n) using a map for lookups.
func (b *ViewBuilder) UpdateFieldOrder() <span class="cov4" title="12">{
        if len(b.FieldOrder) == 0 </span><span class="cov4" title="10">{
                // Initialize field order with currently selected fields
                b.FieldOrder = append([]string{}, b.SelectedFields...)
                return
        }</span>

        // Build a map of selected fields for O(1) lookup
        <span class="cov2" title="2">selectedMap := make(map[string]bool, len(b.SelectedFields))
        for _, name := range b.SelectedFields </span><span class="cov3" title="5">{
                selectedMap[name] = true
        }</span>

        // Keep fields that are still selected, preserving order
        <span class="cov2" title="2">newOrder := make([]string, 0, len(b.SelectedFields))
        for _, fieldName := range b.FieldOrder </span><span class="cov3" title="5">{
                if selectedMap[fieldName] </span><span class="cov3" title="4">{
                        newOrder = append(newOrder, fieldName)
                        delete(selectedMap, fieldName) // Mark as processed
                }</span>
        }

        // Append newly selected fields that weren't in the old order
        <span class="cov2" title="2">for _, selected := range b.SelectedFields </span><span class="cov3" title="5">{
                if selectedMap[selected] </span><span class="cov1" title="1">{ // If still in map, it's new
                        newOrder = append(newOrder, selected)
                }</span>
        }

        <span class="cov2" title="2">b.FieldOrder = newOrder</span>
}

// Validate checks if the current builder state is valid.
// Returns an error describing what is invalid, or nil if valid.
func (b *ViewBuilder) Validate() error <span class="cov2" title="3">{
        // View name required
        if b.ViewName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("view name is required")
        }</span>

        // At least one field must be selected
        <span class="cov2" title="3">if len(b.SelectedFields) == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("at least one field must be selected")
        }</span>

        // Validate each selected field's format
        <span class="cov2" title="2">for _, fieldName := range b.SelectedFields </span><span class="cov2" title="3">{
                item := b.getFieldItem(fieldName)
                if item == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov2" title="3">if !views.ValidateFieldFormat(item.Name, item.Format) </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid format %q for field %q", item.Format, item.Name)
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// getFieldItem is a helper that finds a FieldItem by name.
// Returns nil if not found. This reduces code duplication.
func (b *ViewBuilder) getFieldItem(name string) *FieldItem <span class="cov4" title="12">{
        for i := range b.AvailableFields </span><span class="cov5" title="26">{
                if b.AvailableFields[i].Name == name </span><span class="cov4" title="11">{
                        return &amp;b.AvailableFields[i]
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package builder

import (
        "fmt"
        "strings"

        "github.com/charmbracelet/lipgloss"
)

var (
        selectedStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("170"))
        normalStyle   = lipgloss.NewStyle()
        dimStyle      = lipgloss.NewStyle().Foreground(lipgloss.Color("241"))
        checkboxStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("39"))
)

// renderWelcome renders the welcome screen
func (m builderModel) renderWelcome() string <span class="cov8" title="1">{
        var s strings.Builder

        s.WriteString("Welcome to the Interactive View Builder!\n\n")
        s.WriteString("This wizard will guide you through creating a custom view for displaying tasks.\n")
        s.WriteString(fmt.Sprintf("View name: %s\n\n", lipgloss.NewStyle().Bold(true).Render(m.builder.ViewName)))
        s.WriteString("You'll configure:\n")
        s.WriteString("   View description\n")
        s.WriteString("   Which fields to display\n")
        s.WriteString("   Field order and formatting\n")
        s.WriteString("   Display options\n\n")
        s.WriteString(dimStyle.Render("Press Enter to continue..."))

        return s.String()
}</span>

// renderBasicInfo renders the basic info input screen
func (m builderModel) renderBasicInfo() string <span class="cov0" title="0">{
        var s strings.Builder

        s.WriteString("Basic Information\n\n")
        s.WriteString("Enter a description for your view (optional):\n\n")
        s.WriteString(m.textInput.View())
        s.WriteString("\n\n")
        s.WriteString(dimStyle.Render("Press Enter to continue..."))

        return s.String()
}</span>

// renderFieldSelection renders the field selection screen
func (m builderModel) renderFieldSelection() string <span class="cov0" title="0">{
        var s strings.Builder

        s.WriteString("Field Selection\n\n")
        s.WriteString("Select which fields to display in your view:\n\n")

        for i, field := range m.builder.AvailableFields </span><span class="cov0" title="0">{
                cursor := " "
                if i == m.cursor </span><span class="cov0" title="0">{
                        cursor = "&gt;"
                }</span>

                <span class="cov0" title="0">checkbox := "[ ]"
                if field.Selected </span><span class="cov0" title="0">{
                        checkbox = checkboxStyle.Render("[]")
                }</span>

                <span class="cov0" title="0">line := fmt.Sprintf("%s %s %s", cursor, checkbox, field.Name)
                if i == m.cursor </span><span class="cov0" title="0">{
                        line = selectedStyle.Render(line)
                }</span>

                <span class="cov0" title="0">s.WriteString(line)
                s.WriteString(dimStyle.Render(" - " + field.Description))
                s.WriteString("\n")</span>
        }

        <span class="cov0" title="0">selectedCount := 0
        for _, field := range m.builder.AvailableFields </span><span class="cov0" title="0">{
                if field.Selected </span><span class="cov0" title="0">{
                        selectedCount++
                }</span>
        }

        <span class="cov0" title="0">s.WriteString(fmt.Sprintf("\n%s selected\n", dimStyle.Render(fmt.Sprintf("%d fields", selectedCount))))

        return s.String()</span>
}

// renderFieldOrdering renders the field ordering screen
func (m builderModel) renderFieldOrdering() string <span class="cov0" title="0">{
        var s strings.Builder

        s.WriteString("Field Ordering\n\n")
        s.WriteString("Arrange the order fields will appear:\n\n")

        for i, fieldName := range m.builder.FieldOrder </span><span class="cov0" title="0">{
                cursor := " "
                if i == m.cursor </span><span class="cov0" title="0">{
                        cursor = "&gt;"
                }</span>

                <span class="cov0" title="0">line := fmt.Sprintf("%s %d. %s", cursor, i+1, fieldName)
                if i == m.cursor </span><span class="cov0" title="0">{
                        line = selectedStyle.Render(line)
                }</span>

                <span class="cov0" title="0">s.WriteString(line)
                s.WriteString("\n")</span>
        }

        <span class="cov0" title="0">s.WriteString(fmt.Sprintf("\n%s\n", dimStyle.Render("Use Ctrl+/ to move fields")))

        return s.String()</span>
}

// renderFieldConfig renders the field configuration screen
func (m builderModel) renderFieldConfig() string <span class="cov0" title="0">{
        var s strings.Builder

        s.WriteString("Field Configuration\n\n")
        s.WriteString("Configure formatting for each field:\n\n")

        for i, fieldName := range m.builder.FieldOrder </span><span class="cov0" title="0">{
                cursor := " "
                if i == m.cursor </span><span class="cov0" title="0">{
                        cursor = "&gt;"
                }</span>

                // Find field details
                <span class="cov0" title="0">var field *FieldItem
                for j := range m.builder.AvailableFields </span><span class="cov0" title="0">{
                        if m.builder.AvailableFields[j].Name == fieldName </span><span class="cov0" title="0">{
                                field = &amp;m.builder.AvailableFields[j]
                                break</span>
                        }
                }

                <span class="cov0" title="0">if field == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">colorIndicator := ""
                if field.Color </span><span class="cov0" title="0">{
                        colorIndicator = checkboxStyle.Render(" [color]")
                }</span>

                <span class="cov0" title="0">line := fmt.Sprintf("%s %s: %s%s", cursor, fieldName, field.Format, colorIndicator)
                if i == m.cursor </span><span class="cov0" title="0">{
                        line = selectedStyle.Render(line)
                }</span>

                <span class="cov0" title="0">s.WriteString(line)
                s.WriteString("\n")</span>
        }

        <span class="cov0" title="0">s.WriteString(fmt.Sprintf("\n%s\n", dimStyle.Render("Space to toggle color  Tab/Shift+Tab to navigate")))

        return s.String()</span>
}

// renderDisplayOptions renders the display options screen
func (m builderModel) renderDisplayOptions() string <span class="cov0" title="0">{
        var s strings.Builder

        s.WriteString("Display Options\n\n")
        s.WriteString("Configure display settings:\n\n")

        options := []struct {
                name    string
                enabled bool
        }{
                {"Show header", m.builder.ShowHeader},
                {"Show border", m.builder.ShowBorder},
                {"Compact mode", m.builder.CompactMode},
        }

        for i, opt := range options </span><span class="cov0" title="0">{
                cursor := " "
                if i == m.cursor </span><span class="cov0" title="0">{
                        cursor = "&gt;"
                }</span>

                <span class="cov0" title="0">checkbox := "[ ]"
                if opt.enabled </span><span class="cov0" title="0">{
                        checkbox = checkboxStyle.Render("[]")
                }</span>

                <span class="cov0" title="0">line := fmt.Sprintf("%s %s %s", cursor, checkbox, opt.name)
                if i == m.cursor </span><span class="cov0" title="0">{
                        line = selectedStyle.Render(line)
                }</span>

                <span class="cov0" title="0">s.WriteString(line)
                s.WriteString("\n")</span>
        }

        <span class="cov0" title="0">s.WriteString(fmt.Sprintf("\nDate format: %s\n", m.builder.DateFormat))

        return s.String()</span>
}

// renderFilterConfig renders the filter configuration screen
func (m builderModel) renderFilterConfig() string <span class="cov0" title="0">{
        var s strings.Builder

        s.WriteString("Filter Configuration\n\n")
        s.WriteString("Select which task statuses to display in your view:\n")
        s.WriteString(dimStyle.Render("(Unselected statuses will be filtered out)\n\n"))

        // Define available statuses with descriptions
        statuses := []struct {
                name        string
                description string
        }{
                {"NEEDS-ACTION", "Tasks that need to be done (TODO)"},
                {"IN-PROCESS", "Tasks currently being worked on"},
                {"COMPLETED", "Finished tasks (DONE)"},
                {"CANCELLED", "Cancelled tasks"},
        }

        for i, status := range statuses </span><span class="cov0" title="0">{
                cursor := " "
                if i == m.cursor </span><span class="cov0" title="0">{
                        cursor = "&gt;"
                }</span>

                // Check if this status is in the filter
                <span class="cov0" title="0">checked := false
                for _, filterStatus := range m.builder.FilterStatus </span><span class="cov0" title="0">{
                        if filterStatus == status.name </span><span class="cov0" title="0">{
                                checked = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">checkbox := "[ ]"
                if checked </span><span class="cov0" title="0">{
                        checkbox = checkboxStyle.Render("[]")
                }</span>

                <span class="cov0" title="0">line := fmt.Sprintf("%s %s %s", cursor, checkbox, status.name)
                if i == m.cursor </span><span class="cov0" title="0">{
                        line = selectedStyle.Render(line)
                }</span>

                <span class="cov0" title="0">s.WriteString(line)
                s.WriteString(dimStyle.Render(" - " + status.description))
                s.WriteString("\n")</span>
        }

        <span class="cov0" title="0">selectedCount := len(m.builder.FilterStatus)
        s.WriteString(fmt.Sprintf("\n%s\n", dimStyle.Render(fmt.Sprintf("%d statuses selected", selectedCount))))

        if selectedCount == 0 </span><span class="cov0" title="0">{
                s.WriteString(dimStyle.Render("Note: If no statuses are selected, all tasks will be displayed.\n"))
        }</span>

        <span class="cov0" title="0">return s.String()</span>
}

// renderConfirm renders the confirmation screen
func (m builderModel) renderConfirm() string <span class="cov0" title="0">{
        var s strings.Builder

        s.WriteString("Confirm View Configuration\n\n")
        s.WriteString(fmt.Sprintf("Name: %s\n", m.builder.ViewName))
        s.WriteString(fmt.Sprintf("Description: %s\n", m.builder.ViewDescription))
        s.WriteString(fmt.Sprintf("\nFields (%d):\n", len(m.builder.FieldOrder)))

        for i, fieldName := range m.builder.FieldOrder </span><span class="cov0" title="0">{
                var field *FieldItem
                for j := range m.builder.AvailableFields </span><span class="cov0" title="0">{
                        if m.builder.AvailableFields[j].Name == fieldName </span><span class="cov0" title="0">{
                                field = &amp;m.builder.AvailableFields[j]
                                break</span>
                        }
                }

                <span class="cov0" title="0">if field != nil </span><span class="cov0" title="0">{
                        colorIndicator := ""
                        if field.Color </span><span class="cov0" title="0">{
                                colorIndicator = " (color)"
                        }</span>
                        <span class="cov0" title="0">s.WriteString(fmt.Sprintf("  %d. %s [%s]%s\n", i+1, field.Name, field.Format, colorIndicator))</span>
                }
        }

        <span class="cov0" title="0">s.WriteString("\nDisplay Options:\n")
        s.WriteString(fmt.Sprintf("  Header: %v\n", m.builder.ShowHeader))
        s.WriteString(fmt.Sprintf("  Border: %v\n", m.builder.ShowBorder))
        s.WriteString(fmt.Sprintf("  Compact: %v\n", m.builder.CompactMode))
        s.WriteString(fmt.Sprintf("  Date format: %s\n", m.builder.DateFormat))

        s.WriteString("\n")
        s.WriteString(selectedStyle.Render("Save this view? (y/n)"))

        return s.String()</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package views

// FieldRegistry maps field names to their definitions
var FieldRegistry = map[string]FieldDefinition{
        "status": {
                Name:          "status",
                Description:   "Task completion status",
                Formats:       []string{"symbol", "text", "emoji", "short"},
                DefaultFormat: "symbol",
        },
        "summary": {
                Name:          "summary",
                Description:   "Task title/summary",
                Formats:       []string{"full", "truncate"},
                DefaultFormat: "full",
        },
        "description": {
                Name:          "description",
                Description:   "Task detailed description",
                Formats:       []string{"full", "truncate", "first_line"},
                DefaultFormat: "truncate",
        },
        "priority": {
                Name:            "priority",
                Description:     "Task priority (0-9)",
                Formats:         []string{"number", "text", "stars", "color"},
                DefaultFormat:   "number",
                RequiresBackend: true, // For priority color
        },
        "due_date": {
                Name:          "due_date",
                Description:   "Task due date",
                Formats:       []string{"full", "relative", "short"},
                DefaultFormat: "full",
        },
        "start_date": {
                Name:          "start_date",
                Description:   "Task start date",
                Formats:       []string{"full", "relative", "short"},
                DefaultFormat: "full",
        },
        "created": {
                Name:          "created",
                Description:   "Task creation timestamp",
                Formats:       []string{"full", "relative", "date_only"},
                DefaultFormat: "full",
        },
        "modified": {
                Name:          "modified",
                Description:   "Task last modified timestamp",
                Formats:       []string{"full", "relative", "date_only"},
                DefaultFormat: "full",
        },
        "completed": {
                Name:          "completed",
                Description:   "Task completion timestamp",
                Formats:       []string{"full", "relative", "date_only", "short"},
                DefaultFormat: "full",
        },
        "tags": {
                Name:          "tags",
                Description:   "Task categories/labels",
                Formats:       []string{"list", "comma", "hash"},
                DefaultFormat: "comma",
        },
        "uid": {
                Name:          "uid",
                Description:   "Unique task identifier",
                Formats:       []string{"full", "short"},
                DefaultFormat: "short",
        },
        "parent": {
                Name:          "parent",
                Description:   "Parent task UID (for subtasks)",
                Formats:       []string{"full", "short"},
                DefaultFormat: "short",
        },
}

// GetFieldDefinition returns the definition for a field name
func GetFieldDefinition(name string) (FieldDefinition, bool) <span class="cov9" title="193">{
        def, ok := FieldRegistry[name]
        return def, ok
}</span>

// ValidateFieldFormat checks if a format is valid for a field
func ValidateFieldFormat(fieldName, format string) bool <span class="cov9" title="158">{
        def, ok := GetFieldDefinition(fieldName)
        if !ok </span><span class="cov1" title="1">{
                return false
        }</span>

        // Empty format is valid (will use default)
        <span class="cov9" title="157">if format == "" </span><span class="cov2" title="3">{
                return true
        }</span>

        // Check if format is in the list of valid formats
        <span class="cov9" title="154">for _, validFormat := range def.Formats </span><span class="cov10" title="255">{
                if format == validFormat </span><span class="cov9" title="149">{
                        return true
                }</span>
        }

        <span class="cov3" title="5">return false</span>
}

// GetDefaultFormat returns the default format for a field
func GetDefaultFormat(fieldName string) string <span class="cov4" title="11">{
        def, ok := GetFieldDefinition(fieldName)
        if !ok </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov4" title="10">return def.DefaultFormat</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package views

import (
        "gosynctasks/backend"
        "sort"
        "strings"
        "time"
)

// ApplyFilters filters tasks based on view filter configuration
func ApplyFilters(tasks []backend.Task, filters *ViewFilters) []backend.Task <span class="cov7" title="14">{
        if filters == nil </span><span class="cov1" title="1">{
                return tasks
        }</span>

        <span class="cov6" title="13">var filtered []backend.Task

        for _, task := range tasks </span><span class="cov10" title="52">{
                if matchesFilters(task, filters) </span><span class="cov8" title="26">{
                        filtered = append(filtered, task)
                }</span>
        }

        <span class="cov6" title="13">return filtered</span>
}

// matchesFilters checks if a task matches all filter criteria
func matchesFilters(task backend.Task, filters *ViewFilters) bool <span class="cov10" title="52">{
        // Exclude statuses filter (check this first)
        if len(filters.ExcludeStatuses) &gt; 0 </span><span class="cov6" title="10">{
                for _, excludeStatus := range filters.ExcludeStatuses </span><span class="cov7" title="17">{
                        if strings.EqualFold(task.Status, excludeStatus) </span><span class="cov4" title="5">{
                                return false
                        }</span>
                }
        }

        // Status filter (include only these statuses)
        <span class="cov9" title="47">if len(filters.Status) &gt; 0 </span><span class="cov5" title="6">{
                matched := false
                for _, status := range filters.Status </span><span class="cov5" title="7">{
                        if strings.EqualFold(task.Status, status) </span><span class="cov3" title="3">{
                                matched = true
                                break</span>
                        }
                }
                <span class="cov5" title="6">if !matched </span><span class="cov3" title="3">{
                        return false
                }</span>
        }

        // Priority filter
        <span class="cov9" title="44">if filters.PriorityMin &gt; 0 || filters.PriorityMax &gt; 0 </span><span class="cov6" title="12">{
                // If only min is set, check &gt;= min
                if filters.PriorityMin &gt; 0 &amp;&amp; filters.PriorityMax == 0 </span><span class="cov4" title="4">{
                        if task.Priority &lt; filters.PriorityMin </span><span class="cov1" title="1">{
                                return false
                        }</span>
                }
                // If only max is set, check &lt;= max
                <span class="cov6" title="11">if filters.PriorityMax &gt; 0 &amp;&amp; filters.PriorityMin == 0 </span><span class="cov4" title="4">{
                        if task.Priority &gt; filters.PriorityMax </span><span class="cov1" title="1">{
                                return false
                        }</span>
                }
                // If both are set, check range
                <span class="cov6" title="10">if filters.PriorityMin &gt; 0 &amp;&amp; filters.PriorityMax &gt; 0 </span><span class="cov4" title="4">{
                        if task.Priority &lt; filters.PriorityMin || task.Priority &gt; filters.PriorityMax </span><span class="cov2" title="2">{
                                return false
                        }</span>
                }
        }

        // Tags filter (task must have all specified tags)
        <span class="cov9" title="40">if len(filters.Tags) &gt; 0 </span><span class="cov6" title="12">{
                taskTags := make(map[string]bool)
                for _, tag := range task.Categories </span><span class="cov8" title="24">{
                        taskTags[strings.ToLower(tag)] = true
                }</span>

                <span class="cov6" title="12">for _, requiredTag := range filters.Tags </span><span class="cov7" title="15">{
                        if !taskTags[strings.ToLower(requiredTag)] </span><span class="cov5" title="7">{
                                return false
                        }</span>
                }
        }

        // Due date filters
        <span class="cov8" title="33">if filters.DueBefore != nil </span><span class="cov4" title="5">{
                if task.DueDate == nil || !task.DueDate.Before(*filters.DueBefore) </span><span class="cov4" title="4">{
                        return false
                }</span>
        }

        <span class="cov8" title="29">if filters.DueAfter != nil </span><span class="cov4" title="5">{
                if task.DueDate == nil || !task.DueDate.After(*filters.DueAfter) </span><span class="cov3" title="3">{
                        return false
                }</span>
        }

        // Start date filters
        <span class="cov8" title="26">if filters.StartBefore != nil </span><span class="cov0" title="0">{
                if task.StartDate == nil || !task.StartDate.Before(*filters.StartBefore) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="26">if filters.StartAfter != nil </span><span class="cov0" title="0">{
                if task.StartDate == nil || !task.StartDate.After(*filters.StartAfter) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="26">return true</span>
}

// ApplySort sorts tasks based on view sort configuration
func ApplySort(tasks []backend.Task, sortBy string, sortOrder string) <span class="cov4" title="5">{
        if sortBy == "" </span><span class="cov1" title="1">{
                return
        }</span>

        // Normalize sort order
        <span class="cov4" title="4">ascending := true
        if strings.ToLower(sortOrder) == "desc" </span><span class="cov1" title="1">{
                ascending = false
        }</span>

        <span class="cov4" title="4">sort.Slice(tasks, func(i, j int) bool </span><span class="cov7" title="14">{
                var less bool

                switch sortBy </span>{
                case "status":<span class="cov0" title="0">
                        less = tasks[i].Status &lt; tasks[j].Status</span>
                case "summary":<span class="cov5" title="6">
                        less = strings.ToLower(tasks[i].Summary) &lt; strings.ToLower(tasks[j].Summary)</span>
                case "priority":<span class="cov4" title="4">
                        // Lower priority number = higher priority (1 is highest)
                        // 0 means undefined, should go last
                        pi, pj := tasks[i].Priority, tasks[j].Priority
                        if pi == 0 &amp;&amp; pj == 0 </span><span class="cov0" title="0">{
                                less = false
                        }</span> else<span class="cov4" title="4"> if pi == 0 </span><span class="cov1" title="1">{
                                less = false // undefined goes last
                        }</span> else<span class="cov3" title="3"> if pj == 0 </span><span class="cov1" title="1">{
                                less = true // undefined goes last
                        }</span> else<span class="cov2" title="2"> {
                                less = pi &lt; pj
                        }</span>
                case "due_date":<span class="cov4" title="4">
                        less = compareDates(tasks[i].DueDate, tasks[j].DueDate, true)</span>
                case "start_date":<span class="cov0" title="0">
                        less = compareDates(tasks[i].StartDate, tasks[j].StartDate, true)</span>
                case "created":<span class="cov0" title="0">
                        less = compareDates(&amp;tasks[i].Created, &amp;tasks[j].Created, true)</span>
                case "modified":<span class="cov0" title="0">
                        less = compareDates(&amp;tasks[i].Modified, &amp;tasks[j].Modified, true)</span>
                default:<span class="cov0" title="0">
                        less = false</span>
                }

                <span class="cov7" title="14">if ascending </span><span class="cov6" title="11">{
                        return less
                }</span>
                <span class="cov3" title="3">return !less</span>
        })
}

// compareDates compares two date pointers, handling nil values
// nilsLast determines whether nil values should be considered greater than non-nil
func compareDates(a, b *time.Time, nilsLast bool) bool <span class="cov4" title="4">{
        if a == nil &amp;&amp; b == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov4" title="4">if a == nil </span><span class="cov1" title="1">{
                return !nilsLast
        }</span>
        <span class="cov3" title="3">if b == nil </span><span class="cov0" title="0">{
                return nilsLast
        }</span>
        <span class="cov3" title="3">return a.Before(*b)</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package formatters

import (
        "gosynctasks/backend"
        "time"
)

// FieldFormatter is the base interface for all field formatters
type FieldFormatter interface {
        // Format returns the formatted string representation of a field value
        Format(task backend.Task, format string, width int, color bool) string
}

// FormatContext provides additional context for formatting
type FormatContext struct {
        // DateFormat is the Go time format string for date display
        DateFormat string

        // Backend provides backend-specific functionality (e.g., priority colors)
        Backend backend.TaskManager

        // Now is the current time (useful for relative date calculations)
        Now time.Time
}

// NewFormatContext creates a new format context with default values
func NewFormatContext(backend backend.TaskManager, dateFormat string) *FormatContext <span class="cov10" title="8">{
        if dateFormat == "" </span><span class="cov0" title="0">{
                dateFormat = "2006-01-02"
        }</span>

        <span class="cov10" title="8">return &amp;FormatContext{
                DateFormat: dateFormat,
                Backend:    backend,
                Now:        time.Now(),
        }</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package formatters

import (
        "fmt"
        "gosynctasks/backend"
        "time"
)

// DateFormatter formats date fields
type DateFormatter struct {
        ctx       *FormatContext
        fieldName string // "due_date", "start_date", "created", "modified", "completed"
}

// NewDateFormatter creates a new date formatter
func NewDateFormatter(ctx *FormatContext, fieldName string) *DateFormatter <span class="cov0" title="0">{
        return &amp;DateFormatter{
                ctx:       ctx,
                fieldName: fieldName,
        }
}</span>

// Format formats the date field according to the specified format
// Supported formats: full, relative, short, date_only
func (f *DateFormatter) Format(task backend.Task, format string, width int, colorize bool) string <span class="cov0" title="0">{
        date := f.getDate(task)
        if date == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">var result string

        switch format </span>{
        case "full":<span class="cov0" title="0">
                result = f.formatFull(*date, colorize)</span>
        case "relative":<span class="cov0" title="0">
                result = f.formatRelative(*date, colorize)</span>
        case "short":<span class="cov0" title="0">
                result = f.formatShort(*date, colorize)</span>
        case "date_only":<span class="cov0" title="0">
                result = f.formatDateOnly(*date, colorize)</span>
        default:<span class="cov0" title="0">
                result = f.formatFull(*date, colorize)</span>
        }

        <span class="cov0" title="0">return truncate(result, width)</span>
}

// getDate extracts the appropriate date from the task
func (f *DateFormatter) getDate(task backend.Task) *time.Time <span class="cov0" title="0">{
        switch f.fieldName </span>{
        case "due_date":<span class="cov0" title="0">
                return task.DueDate</span>
        case "start_date":<span class="cov0" title="0">
                return task.StartDate</span>
        case "created":<span class="cov0" title="0">
                if task.Created.IsZero() </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return &amp;task.Created</span>
        case "modified":<span class="cov0" title="0">
                if task.Modified.IsZero() </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return &amp;task.Modified</span>
        case "completed":<span class="cov0" title="0">
                return task.Completed</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// formatFull returns full date with color coding based on date type
func (f *DateFormatter) formatFull(date time.Time, colorize bool) string <span class="cov0" title="0">{
        dateStr := date.Format(f.ctx.DateFormat)

        if !colorize </span><span class="cov0" title="0">{
                return dateStr
        }</span>

        // Apply color based on field type and date relative to now
        <span class="cov0" title="0">color := f.getDateColor(date)
        if color != "" </span><span class="cov0" title="0">{
                return color + dateStr + "\033[0m"
        }</span>

        <span class="cov0" title="0">return dateStr</span>
}

// formatRelative returns relative time (e.g., "2 days ago", "in 3 days")
func (f *DateFormatter) formatRelative(date time.Time, colorize bool) string <span class="cov0" title="0">{
        duration := f.ctx.Now.Sub(date)

        var result string

        if duration &lt; 0 </span><span class="cov0" title="0">{
                // Future date
                duration = -duration
                result = f.humanizeDuration(duration, "in ")
        }</span> else<span class="cov0" title="0"> {
                // Past date
                result = f.humanizeDuration(duration, "") + " ago"
        }</span>

        <span class="cov0" title="0">if !colorize </span><span class="cov0" title="0">{
                return result
        }</span>

        <span class="cov0" title="0">color := f.getDateColor(date)
        if color != "" </span><span class="cov0" title="0">{
                return color + result + "\033[0m"
        }</span>

        <span class="cov0" title="0">return result</span>
}

// formatShort returns short date format (e.g., "01/15", "Jan 15")
func (f *DateFormatter) formatShort(date time.Time, colorize bool) string <span class="cov0" title="0">{
        // Use short format from context or default
        shortFormat := "01/02"
        if f.ctx.DateFormat == "2006-01-02 15:04" </span><span class="cov0" title="0">{
                shortFormat = "01/02 15:04"
        }</span>

        <span class="cov0" title="0">dateStr := date.Format(shortFormat)

        if !colorize </span><span class="cov0" title="0">{
                return dateStr
        }</span>

        <span class="cov0" title="0">color := f.getDateColor(date)
        if color != "" </span><span class="cov0" title="0">{
                return color + dateStr + "\033[0m"
        }</span>

        <span class="cov0" title="0">return dateStr</span>
}

// formatDateOnly returns just the date part (no time)
func (f *DateFormatter) formatDateOnly(date time.Time, colorize bool) string <span class="cov0" title="0">{
        dateStr := date.Format("2006-01-02")

        if !colorize </span><span class="cov0" title="0">{
                return dateStr
        }</span>

        <span class="cov0" title="0">color := f.getDateColor(date)
        if color != "" </span><span class="cov0" title="0">{
                return color + dateStr + "\033[0m"
        }</span>

        <span class="cov0" title="0">return dateStr</span>
}

// getDateColor returns the appropriate color for a date based on field type
func (f *DateFormatter) getDateColor(date time.Time) string <span class="cov0" title="0">{
        switch f.fieldName </span>{
        case "due_date":<span class="cov0" title="0">
                return f.getDueDateColor(date)</span>
        case "start_date":<span class="cov0" title="0">
                return f.getStartDateColor(date)</span>
        default:<span class="cov0" title="0">
                return ""</span> // No color for other date fields
        }
}

// getDueDateColor returns color for due dates
func (f *DateFormatter) getDueDateColor(date time.Time) string <span class="cov0" title="0">{
        if date.Before(f.ctx.Now) </span><span class="cov0" title="0">{
                return "\033[31m" // Red (overdue)
        }</span> else<span class="cov0" title="0"> if date.Sub(f.ctx.Now).Hours() &lt; 24 </span><span class="cov0" title="0">{
                return "\033[33m" // Yellow (due soon)
        }</span>
        <span class="cov0" title="0">return "\033[90m"</span> // Gray (future)
}

// getStartDateColor returns color for start dates
func (f *DateFormatter) getStartDateColor(date time.Time) string <span class="cov0" title="0">{
        hoursDiff := date.Sub(f.ctx.Now).Hours()

        if date.Before(f.ctx.Now) </span><span class="cov0" title="0">{
                return "\033[36m" // Cyan (past - should have started)
        }</span> else<span class="cov0" title="0"> if hoursDiff &lt; 72 </span><span class="cov0" title="0">{ // Within 3 days
                return "\033[33m" // Yellow (starting soon)
        }</span>
        <span class="cov0" title="0">return "\033[90m"</span> // Gray (future)
}

// humanizeDuration converts duration to human-readable format
func (f *DateFormatter) humanizeDuration(d time.Duration, prefix string) string <span class="cov0" title="0">{
        seconds := int(d.Seconds())
        minutes := seconds / 60
        hours := minutes / 60
        days := hours / 24
        weeks := days / 7
        months := days / 30
        years := days / 365

        if years &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s%dy", prefix, years)
        }</span> else<span class="cov0" title="0"> if months &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s%dmo", prefix, months)
        }</span> else<span class="cov0" title="0"> if weeks &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s%dw", prefix, weeks)
        }</span> else<span class="cov0" title="0"> if days &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s%dd", prefix, days)
        }</span> else<span class="cov0" title="0"> if hours &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s%dh", prefix, hours)
        }</span> else<span class="cov0" title="0"> if minutes &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s%dm", prefix, minutes)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s%ds", prefix, seconds)</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package formatters

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "gosynctasks/backend"
        "os/exec"
        "strings"
        "time"
)

// PluginFormatter executes external scripts to format field values
type PluginFormatter struct {
        ctx     *FormatContext
        command string
        args    []string
        timeout time.Duration
        env     map[string]string
}

// NewPluginFormatter creates a new plugin formatter
func NewPluginFormatter(ctx *FormatContext, command string, args []string, timeoutMs int, env map[string]string) *PluginFormatter <span class="cov9" title="10">{
        // Set default timeout to 1 second if not specified
        timeout := 1000 * time.Millisecond
        if timeoutMs &gt; 0 </span><span class="cov8" title="9">{
                timeout = time.Duration(timeoutMs) * time.Millisecond
        }</span>

        // Enforce maximum timeout of 5 seconds
        <span class="cov9" title="10">maxTimeout := 5000 * time.Millisecond
        if timeout &gt; maxTimeout </span><span class="cov1" title="1">{
                timeout = maxTimeout
        }</span>

        <span class="cov9" title="10">return &amp;PluginFormatter{
                ctx:     ctx,
                command: command,
                args:    args,
                timeout: timeout,
                env:     env,
        }</span>
}

// Format executes the plugin script and returns the formatted output
func (f *PluginFormatter) Format(task backend.Task, format string, width int, color bool) string <span class="cov10" title="12">{
        // Prepare task data as JSON
        taskData, err := f.prepareTaskData(task, format, width, color)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("[plugin error: %v]", err)
        }</span>

        // Execute the plugin
        <span class="cov10" title="12">output, err := f.executePlugin(taskData)
        if err != nil </span><span class="cov4" title="3">{
                return fmt.Sprintf("[plugin error: %v]", err)
        }</span>

        // Trim trailing whitespace and return
        <span class="cov8" title="9">return strings.TrimRight(output, "\r\n")</span>
}

// prepareTaskData converts the task to JSON for passing to the plugin
func (f *PluginFormatter) prepareTaskData(task backend.Task, format string, width int, color bool) ([]byte, error) <span class="cov10" title="12">{
        // Create a simplified task representation for JSON serialization
        data := map[string]interface{}{
                "uid":         task.UID,
                "summary":     task.Summary,
                "description": task.Description,
                "status":      task.Status,
                "priority":    task.Priority,
                "categories":  task.Categories,
                "format":      format,
                "width":       width,
                "color":       color,
        }

        // Add date fields (convert to ISO 8601 format)
        if task.DueDate != nil &amp;&amp; !task.DueDate.IsZero() </span><span class="cov1" title="1">{
                data["due_date"] = task.DueDate.Format(time.RFC3339)
        }</span>
        <span class="cov10" title="12">if task.StartDate != nil &amp;&amp; !task.StartDate.IsZero() </span><span class="cov0" title="0">{
                data["start_date"] = task.StartDate.Format(time.RFC3339)
        }</span>
        <span class="cov10" title="12">if !task.Created.IsZero() </span><span class="cov0" title="0">{
                data["created"] = task.Created.Format(time.RFC3339)
        }</span>
        <span class="cov10" title="12">if !task.Modified.IsZero() </span><span class="cov0" title="0">{
                data["modified"] = task.Modified.Format(time.RFC3339)
        }</span>
        <span class="cov10" title="12">if task.Completed != nil &amp;&amp; !task.Completed.IsZero() </span><span class="cov0" title="0">{
                data["completed"] = task.Completed.Format(time.RFC3339)
        }</span>

        // Add parent UID if present
        <span class="cov10" title="12">if task.ParentUID != "" </span><span class="cov0" title="0">{
                data["parent_uid"] = task.ParentUID
        }</span>

        <span class="cov10" title="12">return json.Marshal(data)</span>
}

// executePlugin runs the external command with timeout and security measures
func (f *PluginFormatter) executePlugin(input []byte) (string, error) <span class="cov10" title="12">{
        // Create context with timeout
        ctx, cancel := context.WithTimeout(context.Background(), f.timeout)
        defer cancel()

        // Build command
        cmd := exec.CommandContext(ctx, f.command, f.args...)

        // Set up input/output buffers
        cmd.Stdin = bytes.NewReader(input)
        var stdout bytes.Buffer
        var stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        // Set environment variables if specified
        if len(f.env) &gt; 0 </span><span class="cov1" title="1">{
                cmd.Env = cmd.Environ()
                for key, value := range f.env </span><span class="cov1" title="1">{
                        cmd.Env = append(cmd.Env, fmt.Sprintf("%s=%s", key, value))
                }</span>
        }

        // Execute the command
        <span class="cov10" title="12">err := cmd.Run()

        // Check for timeout
        if ctx.Err() == context.DeadlineExceeded </span><span class="cov1" title="1">{
                return "", fmt.Errorf("plugin timed out after %v", f.timeout)
        }</span>

        // Check for execution errors
        <span class="cov9" title="11">if err != nil </span><span class="cov3" title="2">{
                // Include stderr if available
                if stderr.Len() &gt; 0 </span><span class="cov3" title="2">{
                        return "", fmt.Errorf("plugin failed: %v (stderr: %s)", err, stderr.String())
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("plugin failed: %v", err)</span>
        }

        <span class="cov8" title="9">return stdout.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package formatters

import (
        "fmt"
        "gosynctasks/backend"
        "strings"
)

// PriorityFormatter formats task priority field
type PriorityFormatter struct {
        ctx *FormatContext
}

// NewPriorityFormatter creates a new priority formatter
func NewPriorityFormatter(ctx *FormatContext) *PriorityFormatter <span class="cov0" title="0">{
        return &amp;PriorityFormatter{ctx: ctx}
}</span>

// Format formats the priority field according to the specified format
// Supported formats: number, text, stars, color
func (f *PriorityFormatter) Format(task backend.Task, format string, width int, colorize bool) string <span class="cov0" title="0">{
        var result string

        switch format </span>{
        case "number":<span class="cov0" title="0">
                result = f.formatNumber(task.Priority, colorize)</span>
        case "text":<span class="cov0" title="0">
                result = f.formatText(task.Priority, colorize)</span>
        case "stars":<span class="cov0" title="0">
                result = f.formatStars(task.Priority, colorize)</span>
        case "color":<span class="cov0" title="0">
                result = f.formatColorBar(task.Priority)</span>
        default:<span class="cov0" title="0">
                result = f.formatNumber(task.Priority, colorize)</span>
        }

        <span class="cov0" title="0">return truncate(result, width)</span>
}

// formatNumber returns priority as a number with optional color
func (f *PriorityFormatter) formatNumber(priority int, colorize bool) string <span class="cov0" title="0">{
        if priority == 0 </span><span class="cov0" title="0">{
                return "-"
        }</span>

        <span class="cov0" title="0">numStr := fmt.Sprintf("%d", priority)

        if colorize &amp;&amp; f.ctx.Backend != nil </span><span class="cov0" title="0">{
                color := f.ctx.Backend.GetPriorityColor(priority)
                return color + numStr + "\033[0m"
        }</span>

        <span class="cov0" title="0">return numStr</span>
}

// formatText returns priority as text (High/Medium/Low)
func (f *PriorityFormatter) formatText(priority int, colorize bool) string <span class="cov0" title="0">{
        var text string
        var color string

        if priority == 0 </span><span class="cov0" title="0">{
                return "None"
        }</span>

        // Priority mapping: 1-3=High, 4-6=Medium, 7-9=Low
        <span class="cov0" title="0">switch </span>{
        case priority &gt;= 1 &amp;&amp; priority &lt;= 3:<span class="cov0" title="0">
                text = "High"
                color = "\033[31m"</span> // Red
        case priority &gt;= 4 &amp;&amp; priority &lt;= 6:<span class="cov0" title="0">
                text = "Medium"
                color = "\033[33m"</span> // Yellow
        case priority &gt;= 7 &amp;&amp; priority &lt;= 9:<span class="cov0" title="0">
                text = "Low"
                color = "\033[34m"</span> // Blue
        default:<span class="cov0" title="0">
                text = fmt.Sprintf("P%d", priority)
                color = "\033[37m"</span> // White
        }

        <span class="cov0" title="0">if colorize </span><span class="cov0" title="0">{
                return color + text + "\033[0m"
        }</span>
        <span class="cov0" title="0">return text</span>
}

// formatStars returns priority as stars (more stars = higher priority)
// Priority 1-3:  (high)
// Priority 4-6:  (medium)
// Priority 7-9:  (low)
func (f *PriorityFormatter) formatStars(priority int, colorize bool) string <span class="cov0" title="0">{
        if priority == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">var stars string
        var color string

        switch </span>{
        case priority &gt;= 1 &amp;&amp; priority &lt;= 3:<span class="cov0" title="0">
                stars = ""
                color = "\033[31m"</span> // Red
        case priority &gt;= 4 &amp;&amp; priority &lt;= 6:<span class="cov0" title="0">
                stars = ""
                color = "\033[33m"</span> // Yellow
        case priority &gt;= 7 &amp;&amp; priority &lt;= 9:<span class="cov0" title="0">
                stars = ""
                color = "\033[34m"</span> // Blue
        default:<span class="cov0" title="0">
                stars = "?"
                color = "\033[37m"</span>
        }

        <span class="cov0" title="0">if colorize </span><span class="cov0" title="0">{
                return color + stars + "\033[0m"
        }</span>
        <span class="cov0" title="0">return stars</span>
}

// formatColorBar returns priority as a colored bar
func (f *PriorityFormatter) formatColorBar(priority int) string <span class="cov0" title="0">{
        if priority == 0 </span><span class="cov0" title="0">{
                return "\033[90m\033[0m" // Gray bar for no priority
        }</span>

        // Invert priority for bar length (1=highest=longest, 9=lowest=shortest)
        <span class="cov0" title="0">barLength := 10 - priority
        if barLength &lt; 1 </span><span class="cov0" title="0">{
                barLength = 1
        }</span>

        <span class="cov0" title="0">var color string
        switch </span>{
        case priority &gt;= 1 &amp;&amp; priority &lt;= 3:<span class="cov0" title="0">
                color = "\033[31m"</span> // Red
        case priority &gt;= 4 &amp;&amp; priority &lt;= 6:<span class="cov0" title="0">
                color = "\033[33m"</span> // Yellow
        case priority &gt;= 7 &amp;&amp; priority &lt;= 9:<span class="cov0" title="0">
                color = "\033[34m"</span> // Blue
        default:<span class="cov0" title="0">
                color = "\033[37m"</span>
        }

        <span class="cov0" title="0">bar := strings.Repeat("", barLength)
        return color + bar + "\033[0m"</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package formatters

import (
        "gosynctasks/backend"
        "strings"
)

// StatusFormatter formats task status field
type StatusFormatter struct {
        ctx *FormatContext
}

// NewStatusFormatter creates a new status formatter
func NewStatusFormatter(ctx *FormatContext) *StatusFormatter <span class="cov3" title="4">{
        return &amp;StatusFormatter{ctx: ctx}
}</span>

// Format formats the status field according to the specified format
// Supported formats: symbol, text, emoji, short
func (f *StatusFormatter) Format(task backend.Task, format string, width int, color bool) string <span class="cov7" title="19">{
        var result string

        switch format </span>{
        case "symbol":<span class="cov5" title="7">
                result = f.formatSymbol(task.Status, color)</span>
        case "text":<span class="cov3" title="4">
                result = f.formatText(task.Status, color)</span>
        case "emoji":<span class="cov3" title="4">
                result = f.formatEmoji(task.Status)</span>
        case "short":<span class="cov3" title="4">
                result = f.formatShort(task.Status, color)</span>
        default:<span class="cov0" title="0">
                result = f.formatSymbol(task.Status, color)</span>
        }

        <span class="cov7" title="19">return truncate(result, width)</span>
}

// formatSymbol returns colored symbols for each status
func (f *StatusFormatter) formatSymbol(status string, color bool) string <span class="cov5" title="7">{
        var statusColor string
        var statusSymbol string

        switch status </span>{
        case "COMPLETED":<span class="cov2" title="2">
                statusColor = "\033[32m" // Green
                statusSymbol = ""</span>
        case "IN-PROCESS":<span class="cov2" title="2">
                statusColor = "\033[33m" // Yellow
                statusSymbol = ""</span>
        case "CANCELLED":<span class="cov2" title="2">
                statusColor = "\033[31m" // Red
                statusSymbol = ""</span>
        default:<span class="cov1" title="1"> // NEEDS-ACTION
                statusColor = "\033[37m" // White
                statusSymbol = ""</span>
        }

        <span class="cov5" title="7">if color </span><span class="cov3" title="3">{
                return statusColor + statusSymbol + "\033[0m"
        }</span>
        <span class="cov3" title="4">return statusSymbol</span>
}

// formatText returns full text status with optional color
func (f *StatusFormatter) formatText(status string, color bool) string <span class="cov3" title="4">{
        var statusColor string
        var statusText string

        switch status </span>{
        case "COMPLETED":<span class="cov1" title="1">
                statusColor = "\033[32m"
                statusText = "COMPLETED"</span>
        case "IN-PROCESS":<span class="cov1" title="1">
                statusColor = "\033[33m"
                statusText = "IN-PROCESS"</span>
        case "CANCELLED":<span class="cov1" title="1">
                statusColor = "\033[31m"
                statusText = "CANCELLED"</span>
        default:<span class="cov1" title="1"> // NEEDS-ACTION
                statusColor = "\033[37m"
                statusText = "TODO"</span>
        }

        <span class="cov3" title="4">if color </span><span class="cov0" title="0">{
                return statusColor + statusText + "\033[0m"
        }</span>
        <span class="cov3" title="4">return statusText</span>
}

// formatEmoji returns emoji representations
func (f *StatusFormatter) formatEmoji(status string) string <span class="cov3" title="4">{
        switch status </span>{
        case "COMPLETED":<span class="cov1" title="1">
                return ""</span>
        case "IN-PROCESS":<span class="cov1" title="1">
                return ""</span>
        case "CANCELLED":<span class="cov1" title="1">
                return ""</span>
        default:<span class="cov1" title="1"> // NEEDS-ACTION
                return ""</span>
        }
}

// formatShort returns abbreviated status
func (f *StatusFormatter) formatShort(status string, color bool) string <span class="cov3" title="4">{
        var statusColor string
        var statusText string

        switch status </span>{
        case "COMPLETED":<span class="cov1" title="1">
                statusColor = "\033[32m"
                statusText = "D"</span>
        case "IN-PROCESS":<span class="cov1" title="1">
                statusColor = "\033[33m"
                statusText = "P"</span>
        case "CANCELLED":<span class="cov1" title="1">
                statusColor = "\033[31m"
                statusText = "C"</span>
        default:<span class="cov1" title="1"> // NEEDS-ACTION
                statusColor = "\033[37m"
                statusText = "T"</span>
        }

        <span class="cov3" title="4">if color </span><span class="cov0" title="0">{
                return statusColor + statusText + "\033[0m"
        }</span>
        <span class="cov3" title="4">return statusText</span>
}

// truncate truncates a string to the specified width (accounting for ANSI codes)
func truncate(s string, width int) string <span class="cov7" title="23">{
        if width &lt;= 0 </span><span class="cov7" title="20">{
                return s
        }</span>

        // Strip ANSI codes to measure actual visible length
        <span class="cov3" title="3">visibleLen := len(stripAnsi(s))
        if visibleLen &lt;= width </span><span class="cov2" title="2">{
                return s
        }</span>

        // Truncate visible content
        <span class="cov1" title="1">visible := stripAnsi(s)
        if width &gt; 3 </span><span class="cov1" title="1">{
                visible = visible[:width-3] + "..."
        }</span> else<span class="cov0" title="0"> {
                visible = visible[:width]
        }</span>

        // If original had color, try to preserve it (simplified)
        <span class="cov1" title="1">if strings.Contains(s, "\033[") </span><span class="cov0" title="0">{
                // Extract first color code
                colorStart := strings.Index(s, "\033[")
                colorEnd := strings.Index(s[colorStart:], "m")
                if colorEnd &gt; 0 </span><span class="cov0" title="0">{
                        colorCode := s[colorStart : colorStart+colorEnd+1]
                        return colorCode + visible + "\033[0m"
                }</span>
        }

        <span class="cov1" title="1">return visible</span>
}

// stripAnsi removes ANSI color codes from a string
func stripAnsi(s string) string <span class="cov5" title="8">{
        var result []rune
        inEscape := false

        for _, r := range s </span><span class="cov10" title="75">{
                if r == '\033' </span><span class="cov4" title="6">{
                        inEscape = true
                        continue</span>
                }

                <span class="cov9" title="69">if inEscape </span><span class="cov7" title="21">{
                        if r == 'm' </span><span class="cov4" title="6">{
                                inEscape = false
                        }</span>
                        <span class="cov7" title="21">continue</span>
                }

                <span class="cov9" title="48">result = append(result, r)</span>
        }

        <span class="cov5" title="8">return string(result)</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package formatters

import (
        "gosynctasks/backend"
        "strings"
)

// SummaryFormatter formats task summary field
type SummaryFormatter struct {
        ctx *FormatContext
}

// NewSummaryFormatter creates a new summary formatter
func NewSummaryFormatter(ctx *FormatContext) *SummaryFormatter <span class="cov0" title="0">{
        return &amp;SummaryFormatter{ctx: ctx}
}</span>

// Format formats the summary field according to the specified format
// Supported formats: full, truncate
func (f *SummaryFormatter) Format(task backend.Task, format string, width int, colorize bool) string <span class="cov0" title="0">{
        summary := task.Summary

        // Apply priority color if enabled
        if colorize &amp;&amp; task.Priority &gt; 0 &amp;&amp; f.ctx.Backend != nil </span><span class="cov0" title="0">{
                priorityColor := f.ctx.Backend.GetPriorityColor(task.Priority)
                if format == "truncate" &amp;&amp; width &gt; 0 </span><span class="cov0" title="0">{
                        summary = truncate(summary, width)
                }</span>
                <span class="cov0" title="0">return priorityColor + "\033[1m" + summary + "\033[0m"</span> // Bold + color
        }

        <span class="cov0" title="0">if format == "truncate" &amp;&amp; width &gt; 0 </span><span class="cov0" title="0">{
                return truncate(summary, width)
        }</span>

        <span class="cov0" title="0">return summary</span>
}

// DescriptionFormatter formats task description field
type DescriptionFormatter struct {
        ctx *FormatContext
}

// NewDescriptionFormatter creates a new description formatter
func NewDescriptionFormatter(ctx *FormatContext) *DescriptionFormatter <span class="cov0" title="0">{
        return &amp;DescriptionFormatter{ctx: ctx}
}</span>

// Format formats the description field according to the specified format
// Supported formats: full, truncate, first_line
func (f *DescriptionFormatter) Format(task backend.Task, format string, width int, colorize bool) string <span class="cov0" title="0">{
        if task.Description == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">var result string

        switch format </span>{
        case "full":<span class="cov0" title="0">
                result = task.Description</span>
        case "truncate":<span class="cov0" title="0">
                result = f.formatTruncate(task.Description, width)</span>
        case "first_line":<span class="cov0" title="0">
                result = f.formatFirstLine(task.Description, width)</span>
        default:<span class="cov0" title="0">
                result = f.formatTruncate(task.Description, width)</span>
        }

        // Description is typically shown in dim gray
        <span class="cov0" title="0">if colorize </span><span class="cov0" title="0">{
                return "\033[2m" + result + "\033[0m"
        }</span>

        <span class="cov0" title="0">return result</span>
}

// formatTruncate truncates description and replaces newlines with spaces
func (f *DescriptionFormatter) formatTruncate(description string, width int) string <span class="cov0" title="0">{
        // Replace newlines with spaces
        desc := strings.ReplaceAll(description, "\n", " ")
        desc = strings.ReplaceAll(desc, "\r", "")

        // Collapse multiple spaces
        desc = strings.Join(strings.Fields(desc), " ")

        if width &gt; 0 &amp;&amp; len(desc) &gt; width </span><span class="cov0" title="0">{
                if width &gt; 3 </span><span class="cov0" title="0">{
                        return desc[:width-3] + "..."
                }</span>
                <span class="cov0" title="0">return desc[:width]</span>
        }

        <span class="cov0" title="0">return desc</span>
}

// formatFirstLine returns only the first line of description
func (f *DescriptionFormatter) formatFirstLine(description string, width int) string <span class="cov0" title="0">{
        lines := strings.Split(description, "\n")
        if len(lines) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">firstLine := strings.TrimSpace(lines[0])

        if width &gt; 0 &amp;&amp; len(firstLine) &gt; width </span><span class="cov0" title="0">{
                if width &gt; 3 </span><span class="cov0" title="0">{
                        return firstLine[:width-3] + "..."
                }</span>
                <span class="cov0" title="0">return firstLine[:width]</span>
        }

        <span class="cov0" title="0">return firstLine</span>
}

// TagsFormatter formats task tags/categories field
type TagsFormatter struct {
        ctx *FormatContext
}

// NewTagsFormatter creates a new tags formatter
func NewTagsFormatter(ctx *FormatContext) *TagsFormatter <span class="cov0" title="0">{
        return &amp;TagsFormatter{ctx: ctx}
}</span>

// Format formats the tags field according to the specified format
// Supported formats: list, comma, hash
func (f *TagsFormatter) Format(task backend.Task, format string, width int, colorize bool) string <span class="cov0" title="0">{
        if len(task.Categories) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">var result string

        switch format </span>{
        case "list":<span class="cov0" title="0">
                result = f.formatList(task.Categories)</span>
        case "comma":<span class="cov0" title="0">
                result = f.formatComma(task.Categories)</span>
        case "hash":<span class="cov0" title="0">
                result = f.formatHash(task.Categories)</span>
        default:<span class="cov0" title="0">
                result = f.formatComma(task.Categories)</span>
        }

        <span class="cov0" title="0">if width &gt; 0 &amp;&amp; len(result) &gt; width </span><span class="cov0" title="0">{
                if width &gt; 3 </span><span class="cov0" title="0">{
                        result = result[:width-3] + "..."
                }</span> else<span class="cov0" title="0"> {
                        result = result[:width]
                }</span>
        }

        <span class="cov0" title="0">if colorize </span><span class="cov0" title="0">{
                return "\033[36m" + result + "\033[0m" // Cyan for tags
        }</span>

        <span class="cov0" title="0">return result</span>
}

// formatList formats tags as a bracketed list [tag1][tag2]
func (f *TagsFormatter) formatList(tags []string) string <span class="cov0" title="0">{
        if len(tags) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">var parts []string
        for _, tag := range tags </span><span class="cov0" title="0">{
                parts = append(parts, "["+tag+"]")
        }</span>
        <span class="cov0" title="0">return strings.Join(parts, "")</span>
}

// formatComma formats tags as comma-separated list
func (f *TagsFormatter) formatComma(tags []string) string <span class="cov0" title="0">{
        return strings.Join(tags, ", ")
}</span>

// formatHash formats tags with hash prefix #tag1 #tag2
func (f *TagsFormatter) formatHash(tags []string) string <span class="cov0" title="0">{
        if len(tags) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">var parts []string
        for _, tag := range tags </span><span class="cov0" title="0">{
                parts = append(parts, "#"+tag)
        }</span>
        <span class="cov0" title="0">return strings.Join(parts, " ")</span>
}

// UIDFormatter formats task UID field
type UIDFormatter struct {
        ctx *FormatContext
}

// NewUIDFormatter creates a new UID formatter
func NewUIDFormatter(ctx *FormatContext) *UIDFormatter <span class="cov0" title="0">{
        return &amp;UIDFormatter{ctx: ctx}
}</span>

// Format formats the UID field according to the specified format
// Supported formats: full, short
func (f *UIDFormatter) Format(task backend.Task, format string, width int, colorize bool) string <span class="cov0" title="0">{
        if task.UID == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">var result string

        switch format </span>{
        case "full":<span class="cov0" title="0">
                result = task.UID</span>
        case "short":<span class="cov0" title="0">
                result = f.formatShort(task.UID)</span>
        default:<span class="cov0" title="0">
                result = f.formatShort(task.UID)</span>
        }

        <span class="cov0" title="0">if width &gt; 0 &amp;&amp; len(result) &gt; width </span><span class="cov0" title="0">{
                result = result[:width]
        }</span>

        <span class="cov0" title="0">if colorize </span><span class="cov0" title="0">{
                return "\033[90m" + result + "\033[0m" // Gray for UID
        }</span>

        <span class="cov0" title="0">return result</span>
}

// formatShort returns abbreviated UID (first 8 characters)
func (f *UIDFormatter) formatShort(uid string) string <span class="cov0" title="0">{
        if len(uid) &lt;= 8 </span><span class="cov0" title="0">{
                return uid
        }</span>
        <span class="cov0" title="0">return uid[:8]</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package views

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/go-playground/validator/v10"
        "gopkg.in/yaml.v3"
)

var validate *validator.Validate

func init() <span class="cov1" title="1">{
        validate = validator.New()

        // Register custom validation for alphanum_underscore
        _ = validate.RegisterValidation("alphanum_underscore", func(fl validator.FieldLevel) bool </span><span class="cov6" title="31">{
                str := fl.Field().String()
                for _, r := range str </span><span class="cov10" title="221">{
                        if !((r &gt;= 'a' &amp;&amp; r &lt;= 'z') || (r &gt;= 'A' &amp;&amp; r &lt;= 'Z') || (r &gt;= '0' &amp;&amp; r &lt;= '9') || r == '_' || r == '-') </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov6" title="31">return true</span>
        })
}

// LoadView loads a view configuration from a YAML file
func LoadView(path string) (*View, error) <span class="cov5" title="20">{
        // Read file
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov2" title="3">{
                return nil, fmt.Errorf("failed to read view file %s: %w", path, err)
        }</span>

        // Parse YAML
        <span class="cov5" title="17">var view View
        if err := yaml.Unmarshal(data, &amp;view); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to parse YAML in %s: %w", path, err)
        }</span>

        // Set name from filename if not specified in YAML
        <span class="cov5" title="16">if view.Name == "" </span><span class="cov0" title="0">{
                view.Name = filepath.Base(path)
                // Remove .yaml or .yml extension
                if ext := filepath.Ext(view.Name); ext == ".yaml" || ext == ".yml" </span><span class="cov0" title="0">{
                        view.Name = view.Name[:len(view.Name)-len(ext)]
                }</span>
        }

        // Validate structure
        <span class="cov5" title="16">if err := validate.Struct(&amp;view); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("validation failed for view %s: %w", path, formatValidationError(err))
        }</span>

        // Validate field formats
        <span class="cov5" title="16">for i, field := range view.Fields </span><span class="cov8" title="92">{
                if !ValidateFieldFormat(field.Name, field.Format) </span><span class="cov0" title="0">{
                        def, _ := GetFieldDefinition(field.Name)
                        return nil, fmt.Errorf("invalid format '%s' for field '%s' (valid formats: %v)",
                                field.Format, field.Name, def.Formats)
                }</span>

                // Set default format if not specified
                <span class="cov8" title="92">if field.Format == "" </span><span class="cov0" title="0">{
                        view.Fields[i].Format = GetDefaultFormat(field.Name)
                }</span>

                // Set default Show to true if not explicitly set (nil means not specified)
                <span class="cov8" title="92">if field.Show == nil </span><span class="cov0" title="0">{
                        trueVal := true
                        view.Fields[i].Show = &amp;trueVal
                }</span>
        }

        // Validate field_order references existing fields
        <span class="cov5" title="16">if len(view.FieldOrder) &gt; 0 </span><span class="cov5" title="14">{
                fieldMap := make(map[string]bool)
                for _, field := range view.Fields </span><span class="cov8" title="86">{
                        fieldMap[field.Name] = true
                }</span>

                <span class="cov5" title="14">for _, fieldName := range view.FieldOrder </span><span class="cov8" title="86">{
                        if !fieldMap[fieldName] </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("field_order references undefined field: %s", fieldName)
                        }</span>
                }
        }

        // Set default display options
        <span class="cov5" title="16">if view.Display.DateFormat == "" </span><span class="cov0" title="0">{
                view.Display.DateFormat = "2006-01-02"
        }</span>

        <span class="cov5" title="16">return &amp;view, nil</span>
}

// LoadViewFromBytes loads a view configuration from YAML bytes (used for testing)
func LoadViewFromBytes(data []byte, name string) (*View, error) <span class="cov5" title="15">{
        var view View
        if err := yaml.Unmarshal(data, &amp;view); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse YAML: %w", err)
        }</span>

        <span class="cov5" title="15">if view.Name == "" </span><span class="cov1" title="1">{
                view.Name = name
        }</span>

        // Validate and set defaults (same as LoadView)
        <span class="cov5" title="15">if err := validate.Struct(&amp;view); err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("validation failed: %w", formatValidationError(err))
        }</span>

        <span class="cov5" title="13">for i, field := range view.Fields </span><span class="cov7" title="53">{
                if !ValidateFieldFormat(field.Name, field.Format) </span><span class="cov1" title="1">{
                        def, _ := GetFieldDefinition(field.Name)
                        return nil, fmt.Errorf("invalid format '%s' for field '%s' (valid formats: %v)",
                                field.Format, field.Name, def.Formats)
                }</span>

                <span class="cov7" title="52">if field.Format == "" </span><span class="cov2" title="2">{
                        view.Fields[i].Format = GetDefaultFormat(field.Name)
                }</span>

                <span class="cov7" title="52">if field.Show == nil </span><span class="cov2" title="2">{
                        trueVal := true
                        view.Fields[i].Show = &amp;trueVal
                }</span>
        }

        // Validate field_order references existing fields
        <span class="cov5" title="12">if len(view.FieldOrder) &gt; 0 </span><span class="cov4" title="8">{
                fieldMap := make(map[string]bool)
                for _, field := range view.Fields </span><span class="cov7" title="44">{
                        fieldMap[field.Name] = true
                }</span>

                <span class="cov4" title="8">for _, fieldName := range view.FieldOrder </span><span class="cov7" title="45">{
                        if !fieldMap[fieldName] </span><span class="cov1" title="1">{
                                return nil, fmt.Errorf("field_order references undefined field: %s", fieldName)
                        }</span>
                }
        }

        <span class="cov4" title="11">if view.Display.DateFormat == "" </span><span class="cov2" title="3">{
                view.Display.DateFormat = "2006-01-02"
        }</span>

        <span class="cov4" title="11">return &amp;view, nil</span>
}

// formatValidationError converts validator errors to user-friendly messages
func formatValidationError(err error) error <span class="cov2" title="2">{
        if validationErrs, ok := err.(validator.ValidationErrors); ok </span><span class="cov2" title="2">{
                for _, e := range validationErrs </span><span class="cov2" title="2">{
                        switch e.Tag() </span>{
                        case "required":<span class="cov1" title="1">
                                return fmt.Errorf("field '%s' is required", e.Field())</span>
                        case "min":<span class="cov0" title="0">
                                return fmt.Errorf("field '%s' must have at least %s items/characters", e.Field(), e.Param())</span>
                        case "max":<span class="cov0" title="0">
                                return fmt.Errorf("field '%s' must have at most %s items/characters", e.Field(), e.Param())</span>
                        case "oneof":<span class="cov1" title="1">
                                return fmt.Errorf("field '%s' must be one of: %s", e.Field(), e.Param())</span>
                        case "alphanum_underscore":<span class="cov0" title="0">
                                return fmt.Errorf("field '%s' must contain only letters, numbers, underscores, and hyphens", e.Field())</span>
                        }
                }
        }
        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package views

import (
        "fmt"
        "gosynctasks/backend"
        "gosynctasks/internal/views/formatters"
        "strings"
)

// ViewRenderer renders tasks according to view configuration
type ViewRenderer struct {
        view   *View
        ctx    *formatters.FormatContext
        fmtMap map[string]formatters.FieldFormatter
}

// NewViewRenderer creates a new view renderer
func NewViewRenderer(view *View, backend backend.TaskManager, dateFormat string) *ViewRenderer <span class="cov5" title="6">{
        if dateFormat == "" </span><span class="cov0" title="0">{
                dateFormat = view.Display.DateFormat
        }</span>

        <span class="cov5" title="6">ctx := formatters.NewFormatContext(backend, dateFormat)

        renderer := &amp;ViewRenderer{
                view:   view,
                ctx:    ctx,
                fmtMap: make(map[string]formatters.FieldFormatter),
        }

        // Initialize formatters for each field
        renderer.initializeFormatters()

        return renderer</span>
}

// initializeFormatters creates formatter instances for all fields in the view
func (r *ViewRenderer) initializeFormatters() <span class="cov5" title="6">{
        for _, field := range r.view.Fields </span><span class="cov7" title="16">{
                var formatter formatters.FieldFormatter

                // Check if a plugin formatter is configured for this field
                if field.Plugin != nil </span><span class="cov0" title="0">{
                        // Use plugin formatter
                        formatter = formatters.NewPluginFormatter(
                                r.ctx,
                                field.Plugin.Command,
                                field.Plugin.Args,
                                field.Plugin.Timeout,
                                field.Plugin.Env,
                        )
                }</span> else<span class="cov7" title="16"> {
                        // Use built-in formatter based on field name
                        switch field.Name </span>{
                        case "status":<span class="cov5" title="6">
                                formatter = formatters.NewStatusFormatter(r.ctx)</span>
                        case "priority":<span class="cov1" title="1">
                                formatter = formatters.NewPriorityFormatter(r.ctx)</span>
                        case "summary":<span class="cov5" title="6">
                                formatter = formatters.NewSummaryFormatter(r.ctx)</span>
                        case "description":<span class="cov1" title="1">
                                formatter = formatters.NewDescriptionFormatter(r.ctx)</span>
                        case "due_date":<span class="cov1" title="1">
                                formatter = formatters.NewDateFormatter(r.ctx, "due_date")</span>
                        case "start_date":<span class="cov1" title="1">
                                formatter = formatters.NewDateFormatter(r.ctx, "start_date")</span>
                        case "created":<span class="cov0" title="0">
                                formatter = formatters.NewDateFormatter(r.ctx, "created")</span>
                        case "modified":<span class="cov0" title="0">
                                formatter = formatters.NewDateFormatter(r.ctx, "modified")</span>
                        case "completed":<span class="cov0" title="0">
                                formatter = formatters.NewDateFormatter(r.ctx, "completed")</span>
                        case "tags":<span class="cov0" title="0">
                                formatter = formatters.NewTagsFormatter(r.ctx)</span>
                        case "uid":<span class="cov0" title="0">
                                formatter = formatters.NewUIDFormatter(r.ctx)</span>
                        case "parent":<span class="cov0" title="0">
                                // Parent uses UID formatter
                                formatter = formatters.NewUIDFormatter(r.ctx)</span>
                        }
                }

                <span class="cov7" title="16">if formatter != nil </span><span class="cov7" title="16">{
                        r.fmtMap[field.Name] = formatter
                }</span>
        }
}

// RenderTask renders a single task according to the view configuration
func (r *ViewRenderer) RenderTask(task backend.Task) string <span class="cov6" title="8">{
        var result strings.Builder

        // Determine which fields to show and in what order
        fieldsToShow := r.getFieldsToShow()

        // Build field outputs
        fieldOutputs := make(map[string]string)
        for _, fieldName := range fieldsToShow </span><span class="cov8" title="19">{
                fieldConfig := r.getFieldConfig(fieldName)
                if fieldConfig == nil || (fieldConfig.Show != nil &amp;&amp; !*fieldConfig.Show) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="19">formatter := r.fmtMap[fieldName]
                if formatter == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="19">output := formatter.Format(task, fieldConfig.Format, fieldConfig.Width, fieldConfig.Color)
                if output != "" </span><span class="cov8" title="19">{
                        // Apply label if specified
                        if fieldConfig.Label != "" </span><span class="cov0" title="0">{
                                output = fieldConfig.Label + ": " + output
                        }</span>
                        <span class="cov8" title="19">fieldOutputs[fieldName] = output</span>
                }
        }

        // Render based on view type
        <span class="cov6" title="8">if r.view.Display.CompactMode </span><span class="cov2" title="2">{
                // Compact mode: all on one line
                result.WriteString("  ")
                parts := []string{}
                for _, fieldName := range fieldsToShow </span><span class="cov4" title="5">{
                        if output, ok := fieldOutputs[fieldName]; ok &amp;&amp; output != "" </span><span class="cov4" title="5">{
                                parts = append(parts, output)
                        }</span>
                }
                <span class="cov2" title="2">result.WriteString(strings.Join(parts, " "))
                result.WriteString("\n")</span>
        } else<span class="cov5" title="6"> {
                // Standard mode: main line + optional description line + optional metadata line
                r.renderStandardMode(&amp;result, fieldsToShow, fieldOutputs)
        }</span>

        <span class="cov6" title="8">return result.String()</span>
}

// renderStandardMode renders in standard (non-compact) mode
func (r *ViewRenderer) renderStandardMode(result *strings.Builder, fieldsToShow []string, fieldOutputs map[string]string) <span class="cov5" title="6">{
        // Main line: status + summary + dates
        mainFields := []string{"status", "summary", "start_date", "due_date"}
        mainParts := []string{}

        result.WriteString("  ")
        for _, fieldName := range mainFields </span><span class="cov8" title="24">{
                if output, ok := fieldOutputs[fieldName]; ok &amp;&amp; output != "" </span><span class="cov7" title="14">{
                        mainParts = append(mainParts, output)
                }</span>
        }
        <span class="cov5" title="6">result.WriteString(strings.Join(mainParts, " "))
        result.WriteString("\n")

        // Description line (if present and not already shown)
        if desc, ok := fieldOutputs["description"]; ok &amp;&amp; desc != "" </span><span class="cov0" title="0">{
                result.WriteString(fmt.Sprintf("     %s\n", desc))
        }</span>

        // Metadata line: other fields (priority, tags, created, modified, etc.)
        <span class="cov5" title="6">metadataFields := []string{"created", "modified", "priority", "tags", "uid", "completed", "parent"}
        metadataParts := []string{}

        for _, fieldName := range metadataFields </span><span class="cov10" title="42">{
                if output, ok := fieldOutputs[fieldName]; ok &amp;&amp; output != "" </span><span class="cov0" title="0">{
                        // Skip if not in fieldsToShow
                        inShow := false
                        for _, f := range fieldsToShow </span><span class="cov0" title="0">{
                                if f == fieldName </span><span class="cov0" title="0">{
                                        inShow = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if inShow </span><span class="cov0" title="0">{
                                metadataParts = append(metadataParts, output)
                        }</span>
                }
        }

        <span class="cov5" title="6">if len(metadataParts) &gt; 0 </span><span class="cov0" title="0">{
                result.WriteString(fmt.Sprintf("     %s\n", strings.Join(metadataParts, " | ")))
        }</span>
}

// getFieldsToShow returns the list of fields to display in order
func (r *ViewRenderer) getFieldsToShow() []string <span class="cov6" title="8">{
        // If field_order is specified, use it
        if len(r.view.FieldOrder) &gt; 0 </span><span class="cov4" title="4">{
                return r.view.FieldOrder
        }</span>

        // Otherwise, use the order from Fields array
        <span class="cov4" title="4">fields := []string{}
        for _, field := range r.view.Fields </span><span class="cov6" title="9">{
                // Show if: Show is nil (default to true) OR Show is true
                if field.Show == nil || *field.Show </span><span class="cov6" title="8">{
                        fields = append(fields, field.Name)
                }</span>
        }

        <span class="cov4" title="4">return fields</span>
}

// getFieldConfig returns the field configuration by name
func (r *ViewRenderer) getFieldConfig(fieldName string) *FieldConfig <span class="cov8" title="19">{
        for i := range r.view.Fields </span><span class="cov9" title="34">{
                if r.view.Fields[i].Name == fieldName </span><span class="cov8" title="19">{
                        return &amp;r.view.Fields[i]
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// RenderTasks renders multiple tasks
func (r *ViewRenderer) RenderTasks(tasks []backend.Task) string <span class="cov1" title="1">{
        var result strings.Builder

        for _, task := range tasks </span><span class="cov3" title="3">{
                result.WriteString(r.RenderTask(task))
        }</span>

        <span class="cov1" title="1">return result.String()</span>
}

// GetFilters returns the view's filter configuration
func (r *ViewRenderer) GetFilters() *ViewFilters <span class="cov0" title="0">{
        return r.view.Filters
}</span>

// GetSortConfig returns the view's sort configuration
func (r *ViewRenderer) GetSortConfig() (string, string) <span class="cov0" title="0">{
        return r.view.Display.SortBy, r.view.Display.SortOrder
}</span>

// RenderTaskHierarchical renders a single task with hierarchical indentation
// prefix is the tree prefix (e.g., " " or " ")
func (r *ViewRenderer) RenderTaskHierarchical(task backend.Task, nodePrefix, childPrefix string) string <span class="cov0" title="0">{
        var result strings.Builder

        // Render the task normally
        taskOutput := r.RenderTask(task)

        // Add indentation to each line of the task output
        if nodePrefix != "" </span><span class="cov0" title="0">{
                lines := strings.Split(strings.TrimRight(taskOutput, "\n"), "\n")
                for j, line := range lines </span><span class="cov0" title="0">{
                        if j == 0 </span><span class="cov0" title="0">{
                                result.WriteString(nodePrefix)
                        }</span> else<span class="cov0" title="0"> {
                                // Continuation lines use the child prefix
                                result.WriteString(childPrefix)
                        }</span>
                        <span class="cov0" title="0">result.WriteString(line)
                        result.WriteString("\n")</span>
                }
        } else<span class="cov0" title="0"> {
                result.WriteString(taskOutput)
        }</span>

        <span class="cov0" title="0">return result.String()</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package views

import (
        "embed"
        "fmt"
        "path/filepath"
        "sync"
)

//go:embed builtin_views/*.yaml
var builtinViewFS embed.FS

// viewCache stores loaded views for performance
var viewCache = make(map[string]*View)
var cacheMutex sync.RWMutex

// ResolveView loads a view by name with the following priority:
// 1. User views (~/.config/gosynctasks/views/&lt;name&gt;.yaml)
// 2. Built-in views (basic, all, minimal, full, kanban, timeline, compact)
//
// Views are cached after first load for performance.
func ResolveView(name string) (*View, error) <span class="cov7" title="18">{
        // Check cache first
        cacheMutex.RLock()
        if cached, ok := viewCache[name]; ok </span><span class="cov3" title="3">{
                cacheMutex.RUnlock()
                return cached, nil
        }</span>
        <span class="cov6" title="15">cacheMutex.RUnlock()

        // Try to load user view first
        viewsDir, err := GetViewsDir()
        if err == nil </span><span class="cov6" title="15">{
                // Try .yaml extension first, then .yml
                for _, ext := range []string{".yaml", ".yml"} </span><span class="cov6" title="16">{
                        filePath := filepath.Join(viewsDir, name+ext)
                        view, err := LoadView(filePath)
                        if err == nil </span><span class="cov6" title="14">{
                                // Cache the view
                                cacheMutex.Lock()
                                viewCache[name] = view
                                cacheMutex.Unlock()
                                return view, nil
                        }</span>
                }
        }

        // Fall back to built-in views
        <span class="cov1" title="1">view, err := getBuiltInView(name)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("view '%s' not found (checked user views and built-in views)", name)
        }</span>

        // Cache the built-in view
        <span class="cov0" title="0">cacheMutex.Lock()
        viewCache[name] = view
        cacheMutex.Unlock()

        return view, nil</span>
}

// ClearViewCache clears the view cache (useful for testing or after view updates)
func ClearViewCache() <span class="cov5" title="8">{
        cacheMutex.Lock()
        defer cacheMutex.Unlock()
        viewCache = make(map[string]*View)
}</span>

// InvalidateViewCache removes a specific view from the cache
func InvalidateViewCache(name string) <span class="cov1" title="1">{
        cacheMutex.Lock()
        defer cacheMutex.Unlock()
        delete(viewCache, name)
}</span>

// getBuiltInView returns a built-in view by name from embedded YAML files
func getBuiltInView(name string) (*View, error) <span class="cov5" title="10">{
        // Try to read the embedded YAML file
        filePath := fmt.Sprintf("builtin_views/%s.yaml", name)
        data, err := builtinViewFS.ReadFile(filePath)
        if err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("built-in view '%s' not found", name)
        }</span>

        // Load view from YAML bytes
        <span class="cov5" title="8">view, err := LoadViewFromBytes(data, name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load built-in view '%s': %w", name, err)
        }</span>

        <span class="cov5" title="8">return view, nil</span>
}

// GetBuiltInViews returns a list of built-in view names
func GetBuiltInViews() []string <span class="cov7" title="19">{
        return []string{"default", "all", "minimal", "full", "kanban", "timeline", "compact"}
}</span>

// IsBuiltInView checks if a view name is a built-in view
func IsBuiltInView(name string) bool <span class="cov6" title="15">{
        builtInViews := GetBuiltInViews()
        for _, builtIn := range builtInViews </span><span class="cov10" title="74">{
                if name == builtIn </span><span class="cov6" title="12">{
                        return true
                }</span>
        }
        <span class="cov3" title="3">return false</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package views

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "slices"

        "gopkg.in/yaml.v3"
)

// GetViewsDir returns the directory where view configurations are stored
// Default: ~/.config/gosynctasks/views/
func GetViewsDir() (string, error) <span class="cov10" title="19">{
        configDir, err := os.UserConfigDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get user config directory: %w", err)
        }</span>

        <span class="cov10" title="19">viewsDir := filepath.Join(configDir, "gosynctasks", "views")
        return viewsDir, nil</span>
}

// EnsureViewsDir creates the views directory if it doesn't exist
func EnsureViewsDir() error <span class="cov1" title="1">{
        viewsDir, err := GetViewsDir()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if err := os.MkdirAll(viewsDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create views directory: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// ListViews returns a list of all available view names (user + built-in)
// User views take precedence over built-in views with the same name
func ListViews() ([]string, error) <span class="cov0" title="0">{
        viewsMap := make(map[string]bool)

        // Get built-in views
        builtInViews := []string{"default", "all"}
        for _, name := range builtInViews </span><span class="cov0" title="0">{
                viewsMap[name] = true
        }</span>

        // Get user views
        <span class="cov0" title="0">viewsDir, err := GetViewsDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check if directory exists
        <span class="cov0" title="0">if _, err := os.Stat(viewsDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                // Directory doesn't exist yet, just return built-in views
                return builtInViews, nil
        }</span>

        // Read directory
        <span class="cov0" title="0">entries, err := os.ReadDir(viewsDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read views directory: %w", err)
        }</span>

        <span class="cov0" title="0">for _, entry := range entries </span><span class="cov0" title="0">{
                if entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">name := entry.Name()
                // Only include .yaml and .yml files
                if strings.HasSuffix(name, ".yaml") || strings.HasSuffix(name, ".yml") </span><span class="cov0" title="0">{
                        // Remove extension
                        viewName := name[:len(name)-len(filepath.Ext(name))]
                        viewsMap[viewName] = true
                }</span>
        }

        // Convert map to sorted list
        <span class="cov0" title="0">views := make([]string, 0, len(viewsMap))
        for name := range viewsMap </span><span class="cov0" title="0">{
                views = append(views, name)
        }</span>

        <span class="cov0" title="0">return views, nil</span>
}

// SaveView saves a view configuration to disk
func SaveView(view *View) error <span class="cov0" title="0">{
        if err := EnsureViewsDir(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">viewsDir, err := GetViewsDir()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate view before saving
        <span class="cov0" title="0">if err := validate.Struct(view); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validation failed: %w", formatValidationError(err))
        }</span>

        // Marshal to YAML
        <span class="cov0" title="0">data, err := yaml.Marshal(view)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal view to YAML: %w", err)
        }</span>

        // Write to file
        <span class="cov0" title="0">filePath := filepath.Join(viewsDir, view.Name+".yaml")
        if err := os.WriteFile(filePath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write view file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteView deletes a user view configuration
// Built-in views cannot be deleted
func DeleteView(name string) error <span class="cov0" title="0">{
        // Prevent deletion of built-in views
        builtInViews := []string{"default", "all"}
        if slices.Contains(builtInViews, name) </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot delete built-in view '%s'", name)
        }</span>

        <span class="cov0" title="0">viewsDir, err := GetViewsDir()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Try both .yaml and .yml extensions
        <span class="cov0" title="0">for _, ext := range []string{".yaml", ".yml"} </span><span class="cov0" title="0">{
                filePath := filepath.Join(viewsDir, name+ext)
                if _, err := os.Stat(filePath); err == nil </span><span class="cov0" title="0">{
                        if err := os.Remove(filePath); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to delete view file: %w", err)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
        }

        <span class="cov0" title="0">return fmt.Errorf("view '%s' not found", name)</span>
}

// ViewExists checks if a view exists (user or built-in)
func ViewExists(name string) bool <span class="cov0" title="0">{
        // Check built-in views
        builtInViews := []string{"default", "all"}
        for _, builtIn := range builtInViews </span><span class="cov0" title="0">{
                if name == builtIn </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        // Check user views
        <span class="cov0" title="0">viewsDir, err := GetViewsDir()
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Try both .yaml and .yml extensions
        <span class="cov0" title="0">for _, ext := range []string{".yaml", ".yml"} </span><span class="cov0" title="0">{
                filePath := filepath.Join(viewsDir, name+ext)
                if _, err := os.Stat(filePath); err == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// CopyBuiltInViewsToUserConfig copies all built-in views to the user's config directory
// This is typically called on first run to allow users to customize views
// Returns true if views were copied, false if they already existed
func CopyBuiltInViewsToUserConfig() (bool, error) <span class="cov3" title="2">{
        viewsDir, err := GetViewsDir()
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to get views directory: %w", err)
        }</span>

        // Check if views directory exists and has any .yaml files
        <span class="cov3" title="2">if info, err := os.Stat(viewsDir); err == nil &amp;&amp; info.IsDir() </span><span class="cov1" title="1">{
                entries, err := os.ReadDir(viewsDir)
                if err == nil &amp;&amp; len(entries) &gt; 0 </span><span class="cov1" title="1">{
                        // Check if there are any .yaml or .yml files
                        for _, entry := range entries </span><span class="cov1" title="1">{
                                if !entry.IsDir() </span><span class="cov1" title="1">{
                                        name := entry.Name()
                                        if strings.HasSuffix(name, ".yaml") || strings.HasSuffix(name, ".yml") </span><span class="cov1" title="1">{
                                                // Views already exist, skip copying
                                                return false, nil
                                        }</span>
                                }
                        }
                }
        }

        // Ensure views directory exists
        <span class="cov1" title="1">if err := EnsureViewsDir(); err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to create views directory: %w", err)
        }</span>

        // Copy each built-in view
        <span class="cov1" title="1">builtInViews := GetBuiltInViews()
        for _, viewName := range builtInViews </span><span class="cov6" title="7">{
                // Read built-in view from embedded FS
                filePath := fmt.Sprintf("builtin_views/%s.yaml", viewName)
                data, err := builtinViewFS.ReadFile(filePath)
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("failed to read built-in view '%s': %w", viewName, err)
                }</span>

                // Write to user's views directory
                <span class="cov6" title="7">destPath := filepath.Join(viewsDir, viewName+".yaml")
                if err := os.WriteFile(destPath, data, 0644); err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("failed to write view '%s' to %s: %w", viewName, destPath, err)
                }</span>
        }

        <span class="cov1" title="1">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package views

import (
        "fmt"
        "strings"
)

// ValidationError represents a validation error with details
type ValidationError struct {
        Field   string
        Message string
        Value   string // The invalid value that caused the error
        Hint    string // Suggestion for fixing the error
}

func (e ValidationError) Error() string <span class="cov6" title="10">{
        if e.Field != "" </span><span class="cov6" title="9">{
                return fmt.Sprintf("%s: %s", e.Field, e.Message)
        }</span>
        <span class="cov1" title="1">return e.Message</span>
}

// ValidationErrors is a collection of multiple validation errors
type ValidationErrors struct {
        Errors []ValidationError
}

func (e ValidationErrors) Error() string <span class="cov5" title="6">{
        if len(e.Errors) == 0 </span><span class="cov1" title="1">{
                return "validation failed"
        }</span>
        <span class="cov5" title="5">if len(e.Errors) == 1 </span><span class="cov3" title="3">{
                return e.Errors[0].Error()
        }</span>
        <span class="cov2" title="2">var b strings.Builder
        b.WriteString(fmt.Sprintf("validation failed with %d errors:\n", len(e.Errors)))
        for i, err := range e.Errors </span><span class="cov5" title="7">{
                b.WriteString(fmt.Sprintf("  %d. %s\n", i+1, err.Error()))
        }</span>
        <span class="cov2" title="2">return b.String()</span>
}

// ValidateView validates a view configuration
func ValidateView(view *View) error <span class="cov0" title="0">{
        if view == nil </span><span class="cov0" title="0">{
                return &amp;ValidationError{Message: "view cannot be nil"}
        }</span>

        // Validate view name
        <span class="cov0" title="0">if err := ValidateViewName(view.Name); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate fields
        <span class="cov0" title="0">if err := ValidateFields(view.Fields); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate field order
        <span class="cov0" title="0">if err := ValidateFieldOrder(view.Fields, view.FieldOrder); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate display options
        <span class="cov0" title="0">if err := ValidateDisplayOptions(&amp;view.Display); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateViewComprehensive validates a view and collects ALL errors instead of stopping at first
func ValidateViewComprehensive(view *View) *ValidationErrors <span class="cov4" title="4">{
        var errors []ValidationError

        if view == nil </span><span class="cov1" title="1">{
                return &amp;ValidationErrors{
                        Errors: []ValidationError{{Message: "view cannot be nil"}},
                }
        }</span>

        // Validate view name
        <span class="cov3" title="3">if err := ValidateViewName(view.Name); err != nil </span><span class="cov1" title="1">{
                if ve, ok := err.(*ValidationError); ok </span><span class="cov1" title="1">{
                        errors = append(errors, *ve)
                }</span> else<span class="cov0" title="0"> {
                        errors = append(errors, ValidationError{Field: "name", Message: err.Error()})
                }</span>
        }

        // Validate fields - collect all field errors
        <span class="cov3" title="3">if len(view.Fields) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Field:   "fields",
                        Message: "at least one field must be selected",
                        Hint:    "Add at least one field from: status, summary, description, priority, due_date, start_date, created, modified, completed, tags, uid, parent",
                })
        }</span> else<span class="cov3" title="3"> {
                for i, field := range view.Fields </span><span class="cov5" title="6">{
                        if fieldErr := ValidateField(&amp;field); fieldErr != nil </span><span class="cov4" title="4">{
                                if ve, ok := fieldErr.(*ValidationError); ok </span><span class="cov4" title="4">{
                                        // Prefix with array index
                                        ve.Field = fmt.Sprintf("fields[%d].%s", i, ve.Field)
                                        errors = append(errors, *ve)
                                }</span>
                        }
                }
        }

        // Validate field order
        <span class="cov3" title="3">if len(view.FieldOrder) &gt; 0 </span><span class="cov0" title="0">{
                fieldMap := make(map[string]bool)
                for _, field := range view.Fields </span><span class="cov0" title="0">{
                        fieldMap[field.Name] = true
                }</span>

                <span class="cov0" title="0">for i, fieldName := range view.FieldOrder </span><span class="cov0" title="0">{
                        if !fieldMap[fieldName] </span><span class="cov0" title="0">{
                                errors = append(errors, ValidationError{
                                        Field:   fmt.Sprintf("field_order[%d]", i),
                                        Message: fmt.Sprintf("field '%s' does not exist in fields list", fieldName),
                                        Value:   fieldName,
                                        Hint:    "field_order can only reference fields defined in the 'fields' array",
                                })
                        }</span>
                }
        }

        // Validate display options
        <span class="cov3" title="3">if err := ValidateDisplayOptions(&amp;view.Display); err != nil </span><span class="cov1" title="1">{
                if ve, ok := err.(*ValidationError); ok </span><span class="cov1" title="1">{
                        errors = append(errors, *ve)
                }</span>
        }

        <span class="cov3" title="3">if len(errors) &gt; 0 </span><span class="cov2" title="2">{
                return &amp;ValidationErrors{Errors: errors}
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// ValidateViewName validates a view name
func ValidateViewName(name string) error <span class="cov3" title="3">{
        if name == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "name", Message: "view name is required"}
        }</span>

        <span class="cov3" title="3">if len(name) &lt; 1 || len(name) &gt; 50 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "name", Message: "view name must be between 1 and 50 characters"}
        }</span>

        // Check alphanum_underscore constraint
        <span class="cov3" title="3">for _, r := range name </span><span class="cov8" title="18">{
                if !((r &gt;= 'a' &amp;&amp; r &lt;= 'z') || (r &gt;= 'A' &amp;&amp; r &lt;= 'Z') || (r &gt;= '0' &amp;&amp; r &lt;= '9') || r == '_' || r == '-') </span><span class="cov1" title="1">{
                        return &amp;ValidationError{
                                Field:   "name",
                                Message: "view name can only contain letters, numbers, underscores, and hyphens",
                        }
                }</span>
        }

        <span class="cov2" title="2">return nil</span>
}

// ValidateFields validates field configurations
func ValidateFields(fields []FieldConfig) error <span class="cov0" title="0">{
        if len(fields) == 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "fields", Message: "at least one field must be selected"}
        }</span>

        <span class="cov0" title="0">for i, field := range fields </span><span class="cov0" title="0">{
                if err := ValidateField(&amp;field); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{
                                Field:   fmt.Sprintf("fields[%d]", i),
                                Message: err.Error(),
                        }
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ValidateField validates a single field configuration
func ValidateField(field *FieldConfig) error <span class="cov5" title="6">{
        if field == nil </span><span class="cov0" title="0">{
                return &amp;ValidationError{Message: "field cannot be nil"}
        }</span>

        // Validate field name exists in registry
        <span class="cov5" title="6">def, ok := GetFieldDefinition(field.Name)
        if !ok </span><span class="cov1" title="1">{
                validFields := []string{}
                for name := range FieldRegistry </span><span class="cov7" title="12">{
                        validFields = append(validFields, name)
                }</span>
                <span class="cov1" title="1">return &amp;ValidationError{
                        Field:   "name",
                        Message: fmt.Sprintf("unknown field '%s'", field.Name),
                        Value:   field.Name,
                        Hint:    fmt.Sprintf("Valid fields: %s", strings.Join(validFields, ", ")),
                }</span>
        }

        // Validate format if specified
        <span class="cov5" title="5">if field.Format != "" &amp;&amp; !ValidateFieldFormat(field.Name, field.Format) </span><span class="cov2" title="2">{
                return &amp;ValidationError{
                        Field:   "format",
                        Message: fmt.Sprintf("invalid format '%s' for field '%s'", field.Format, field.Name),
                        Value:   field.Format,
                        Hint:    fmt.Sprintf("Valid formats for '%s': %s", field.Name, strings.Join(def.Formats, ", ")),
                }
        }</span>

        // Validate width
        <span class="cov3" title="3">if field.Width &lt; 0 || field.Width &gt; 200 </span><span class="cov1" title="1">{
                return &amp;ValidationError{
                        Field:   "width",
                        Message: "field width must be between 0 and 200",
                        Value:   fmt.Sprintf("%d", field.Width),
                        Hint:    "Set width to a value between 0-200, or 0 for no limit",
                }
        }</span>

        <span class="cov2" title="2">return nil</span>
}

// ValidateFieldOrder validates field order against field list
func ValidateFieldOrder(fields []FieldConfig, fieldOrder []string) error <span class="cov0" title="0">{
        if len(fieldOrder) == 0 </span><span class="cov0" title="0">{
                // Empty field order is valid - will use fields array order
                return nil
        }</span>

        // Create a map of field names for quick lookup
        <span class="cov0" title="0">fieldMap := make(map[string]bool)
        for _, field := range fields </span><span class="cov0" title="0">{
                fieldMap[field.Name] = true
        }</span>

        // Check that all field order entries exist in fields
        <span class="cov0" title="0">for i, fieldName := range fieldOrder </span><span class="cov0" title="0">{
                if !fieldMap[fieldName] </span><span class="cov0" title="0">{
                        return &amp;ValidationError{
                                Field: fmt.Sprintf("field_order[%d]", i),
                                Message: fmt.Sprintf("field '%s' in field_order does not exist in fields list",
                                        fieldName),
                        }
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ValidateDisplayOptions validates display options
func ValidateDisplayOptions(opts *DisplayOptions) error <span class="cov3" title="3">{
        if opts == nil </span><span class="cov0" title="0">{
                return nil // Display options are optional
        }</span>

        // Validate sort_by if specified
        <span class="cov3" title="3">if opts.SortBy != "" </span><span class="cov2" title="2">{
                validSortFields := []string{"status", "summary", "priority", "due_date", "start_date", "created", "modified"}
                valid := false
                for _, validField := range validSortFields </span><span class="cov6" title="10">{
                        if opts.SortBy == validField </span><span class="cov1" title="1">{
                                valid = true
                                break</span>
                        }
                }
                <span class="cov2" title="2">if !valid </span><span class="cov1" title="1">{
                        return &amp;ValidationError{
                                Field:   "display.sort_by",
                                Message: fmt.Sprintf("invalid sort_by field '%s'", opts.SortBy),
                                Value:   opts.SortBy,
                                Hint:    fmt.Sprintf("Valid sort fields: %s", strings.Join(validSortFields, ", ")),
                        }
                }</span>
        }

        // Validate sort_order if specified
        <span class="cov2" title="2">if opts.SortOrder != "" &amp;&amp; opts.SortOrder != "asc" &amp;&amp; opts.SortOrder != "desc" </span><span class="cov0" title="0">{
                return &amp;ValidationError{
                        Field:   "display.sort_order",
                        Message: "sort_order must be 'asc' or 'desc'",
                        Value:   opts.SortOrder,
                        Hint:    "Use 'asc' for ascending or 'desc' for descending",
                }
        }</span>

        <span class="cov2" title="2">return nil</span>
}

// AnnotateYAMLWithErrors adds inline error comments to YAML content
func AnnotateYAMLWithErrors(yamlContent string, errors *ValidationErrors) string <span class="cov1" title="1">{
        if errors == nil || len(errors.Errors) == 0 </span><span class="cov0" title="0">{
                return yamlContent
        }</span>

        <span class="cov1" title="1">lines := strings.Split(yamlContent, "\n")

        // Build error header
        var header strings.Builder
        header.WriteString("# ========================================\n")
        header.WriteString("# VALIDATION ERRORS - Please fix the issues below\n")
        header.WriteString(fmt.Sprintf("# Found %d error(s)\n", len(errors.Errors)))
        header.WriteString("# ========================================\n")
        for i, err := range errors.Errors </span><span class="cov2" title="2">{
                header.WriteString(fmt.Sprintf("# %d. %s: %s\n", i+1, err.Field, err.Message))
                if err.Hint != "" </span><span class="cov2" title="2">{
                        header.WriteString(fmt.Sprintf("#    Hint: %s\n", err.Hint))
                }</span>
        }
        <span class="cov1" title="1">header.WriteString("# ========================================\n\n")

        // Track which errors have been annotated to avoid duplicates
        annotated := make(map[int]bool)

        // Insert errors inline at relevant locations
        result := make([]string, 0, len(lines)+len(errors.Errors)*3)
        result = append(result, strings.Split(header.String(), "\n")...)

        // Track array indices as we go through the file
        arrayItemCount := 0

        for _, line := range lines </span><span class="cov7" title="11">{
                result = append(result, line)

                trimmedLine := strings.TrimSpace(line)

                // Track array items (fields list)
                if strings.HasPrefix(trimmedLine, "- name:") </span><span class="cov2" title="2">{
                        arrayItemCount++
                }</span>

                // Check for errors that match this specific line
                <span class="cov7" title="11">for errIdx, err := range errors.Errors </span><span class="cov8" title="22">{
                        if annotated[errIdx] </span><span class="cov6" title="8">{
                                continue</span> // Skip already annotated errors
                        }

                        // Determine if this line is the correct location for the error
                        <span class="cov7" title="14">matched := false
                        indent := getIndentation(line)

                        // Handle array item errors (fields[N].field)
                        if strings.HasPrefix(err.Field, "fields[") </span><span class="cov5" title="5">{
                                var fieldIndex int
                                var fieldName string
                                if n, _ := fmt.Sscanf(err.Field, "fields[%d].%s", &amp;fieldIndex, &amp;fieldName); n == 2 </span><span class="cov5" title="5">{
                                        // This is the Nth field item (0-indexed), check if we just saw it
                                        if arrayItemCount-1 == fieldIndex &amp;&amp; matchesFieldInLine(trimmedLine, fieldName) </span><span class="cov1" title="1">{
                                                matched = true
                                        }</span>
                                }
                        } else<span class="cov6" title="9"> if matchesErrorFieldPrecise(trimmedLine, err.Field) </span><span class="cov1" title="1">{
                                // Direct field match (not in array)
                                matched = true
                        }</span>

                        <span class="cov7" title="14">if matched </span><span class="cov2" title="2">{
                                // Categorize error as simple or complex
                                isSimple := isSimpleError(err)

                                if isSimple </span><span class="cov1" title="1">{
                                        // Simple error: concise single-line comment
                                        result = append(result, fmt.Sprintf("%s# ERROR: %s", indent, formatSimpleError(err)))
                                }</span> else<span class="cov1" title="1"> {
                                        // Complex error: multi-line with details
                                        result = append(result, fmt.Sprintf("%s# ERROR: %s", indent, err.Message))
                                        if err.Value != "" </span><span class="cov1" title="1">{
                                                result = append(result, fmt.Sprintf("%s# Invalid value: %s", indent, err.Value))
                                        }</span>
                                        <span class="cov1" title="1">if err.Hint != "" </span><span class="cov1" title="1">{
                                                result = append(result, fmt.Sprintf("%s# Hint: %s", indent, err.Hint))
                                        }</span>
                                }

                                <span class="cov2" title="2">annotated[errIdx] = true</span>
                        }
                }
        }

        <span class="cov1" title="1">return strings.Join(result, "\n")</span>
}

// isSimpleError determines if an error is a simple validation error (format, enum, etc.)
func isSimpleError(err ValidationError) bool <span class="cov2" title="2">{
        // Simple errors: invalid format, invalid enum value, wrong type
        // Complex errors: structural issues, missing required fields, type mismatches

        // Check for format errors
        if strings.Contains(err.Message, "invalid format") </span><span class="cov1" title="1">{
                return true
        }</span>

        // Check for enum/choice errors
        <span class="cov1" title="1">if strings.Contains(err.Message, "must be") &amp;&amp; err.Hint != "" </span><span class="cov0" title="0">{
                return true
        }</span>

        // Width errors are simple
        <span class="cov1" title="1">if strings.Contains(err.Field, "width") </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov1" title="1">return false</span>
}

// formatSimpleError creates a concise error message for simple errors
func formatSimpleError(err ValidationError) string <span class="cov1" title="1">{
        // For format errors, extract the valid options from the hint
        if strings.Contains(err.Message, "invalid format") &amp;&amp; err.Hint != "" </span><span class="cov1" title="1">{
                // Extract valid formats from hint like "Valid formats for 'due_date': full, relative, short"
                if strings.Contains(err.Hint, "Valid formats") </span><span class="cov1" title="1">{
                        parts := strings.Split(err.Hint, ": ")
                        if len(parts) == 2 </span><span class="cov1" title="1">{
                                return fmt.Sprintf("Invalid format '%s'. Must be one of: %s", err.Value, parts[1])
                        }</span>
                }
        }

        // For other simple errors, use the hint if available
        <span class="cov0" title="0">if err.Hint != "" &amp;&amp; len(err.Hint) &lt; 80 </span><span class="cov0" title="0">{
                return err.Hint
        }</span>

        <span class="cov0" title="0">return err.Message</span>
}

// getIndentation returns the indentation (leading whitespace) of a line
func getIndentation(line string) string <span class="cov7" title="14">{
        for i, r := range line </span><span class="cov10" title="34">{
                if r != ' ' &amp;&amp; r != '\t' </span><span class="cov7" title="14">{
                        return line[:i]
                }</span>
        }
        <span class="cov0" title="0">return line</span>
}

// matchesFieldInLine checks if a line contains a specific field name
func matchesFieldInLine(line, fieldName string) bool <span class="cov7" title="11">{
        // Check for "fieldName:" pattern
        if strings.HasPrefix(line, fieldName+":") </span><span class="cov2" title="2">{
                return true
        }</span>
        <span class="cov6" title="9">if strings.Contains(line, " "+fieldName+":") </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov6" title="9">return false</span>
}

// matchesErrorFieldPrecise checks if a YAML line precisely matches the error field path
func matchesErrorFieldPrecise(line, fieldPath string) bool <span class="cov6" title="9">{
        // Handle nested fields like "display.sort_by"
        parts := strings.Split(fieldPath, ".")
        if len(parts) &gt; 0 </span><span class="cov6" title="9">{
                lastPart := parts[len(parts)-1]
                return matchesFieldInLine(line, lastPart)
        }</span>

        <span class="cov0" title="0">return matchesFieldInLine(line, fieldPath)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
