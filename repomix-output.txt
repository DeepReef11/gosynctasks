This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
backend/
  fileBackend.go
  nextcloudBackend.go
  taskManager.go
cmd/
  gosynctasks/
    main.go
internal/
  config/
    config.go
    config.sample.json
  utils/
    inputs.go
.gitignore
go.mod
LICENSE
README.md

================================================================
Files
================================================================

================
File: backend/fileBackend.go
================
package backend

import (
	"net/url"
)

type FileBackend struct {
}

func (nB *FileBackend) GetTaskLists() ([]TaskList, error) {
	return nil, nil

}

func (nB *FileBackend) GetTasks() ([]Task, error) {
	return nil, nil
}

func NewFileBackend(url *url.URL) (TaskManager, error) {
	return nil, nil
}

================
File: backend/nextcloudBackend.go
================
package backend

import (
	"fmt"
	"net/url"
)

type NextcloudBackend struct {
	Connector ConnectorConfig

}

func (nB *NextcloudBackend) GetTaskLists() ([]TaskList, error) {
	fmt.Println("Nextcloud backend")
	return nil, nil

}

func (nB *NextcloudBackend) GetTasks(listID string) ([]Task, error) {

	fmt.Println("Nextcloud backend")
	return nil, nil
}

func NewNextcloudBackend(url *url.URL) (TaskManager, error) {
    nB := &NextcloudBackend{}
	return nB, nil
}

================
File: backend/taskManager.go
================
package backend

import (
	"time"
	"encoding/json"
	"fmt"
	"net/url"
)


type UnsupportedSchemeError struct {
	Scheme string
}

func (e *UnsupportedSchemeError) Error() string {
	return fmt.Sprintf("unsupported scheme: %q", e.Scheme)
}

// Base config struct
type ConnectorConfig struct {
	URL *url.URL `json:"url"`
	// Type     string `json:"type" validate:"required,oneof=nextcloud local"`
	//  Timeout  int    `json:"timeout,omitempty"`
}

func (c *ConnectorConfig) UnmarshalJSON(data []byte) error {
	type ConnConfig ConnectorConfig

	tmp := struct {
		*ConnConfig
		URL string `json:"url"`
	}{
		ConnConfig: (*ConnConfig)(c),
	}

	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}

	u, err := url.Parse(tmp.URL)
	if err != nil {
		return err
	}

	tmp.ConnConfig.URL = u

	return nil
}

func (c *ConnectorConfig) TaskManager() (TaskManager, error) {
	switch c.URL.Scheme {
	case "nextcloud":
		return NewNextcloudBackend(c.URL)
	case "file":
		return NewFileBackend(c.URL)
	default:
		return nil, &UnsupportedSchemeError{
			Scheme: c.URL.Scheme,
		}
	}
}





type TaskManager interface {
	GetTaskLists() ([]TaskList, error)
	GetTasks(listID string) ([]Task, error)
	// Tasks() iter.Seq[Task]
	// Task(string) (Task, bool)
	// Create(Task) error
}


 
type Task struct {
	UID         string     `json:"uid"`
	Summary     string     `json:"summary"`
	Description string     `json:"description,omitempty"`
	Status      string     `json:"status"`   // NEEDS-ACTION, IN-PROCESS, COMPLETED, CANCELLED
	Priority    int        `json:"priority"` // 0-9 (0=undefined, 1=highest, 9=lowest)
	Created     time.Time  `json:"created"`
	Modified    time.Time  `json:"modified"`
	DueDate     *time.Time `json:"due_date,omitempty"`
	StartDate   *time.Time `json:"start_date,omitempty"`
	Completed   *time.Time `json:"completed,omitempty"`
	Categories  []string   `json:"categories,omitempty"`
	ParentUID   string     `json:"parent_uid,omitempty"` // For subtasks
}

type TaskList struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	Description string `json:"description,omitempty"`
	Color       string `json:"color,omitempty"`
	URL         string `json:"url"`
	CTags       string `json:"ctags,omitempty"`
}

================
File: cmd/gosynctasks/main.go
================
package main

import (
	"fmt"
	"gosynctasks/internal/config"
	// "gosynctasks/backend"
	//"os"
	"log"
	// "github.com/emersion/go-webdav/caldav"
)

func main() {
	fmt.Println("ok")

	// configObj := config.GetConfig()
	connector := config.GetConfig()
	taskManager, err := connector.Connector.TaskManager()
	if err != nil {
		log.Fatalln("There was a problem with connector's task manager.")
	}
	taskManager.GetTaskLists()
	fmt.Println(*connector)
	fmt.Println("End.")
}

================
File: internal/config/config.go
================
package config

import (
	"encoding/json"
	"fmt"

	// "gosynctasks/backend"
	"gosynctasks/backend"
	// "gosynctasks/connectors"
	"gosynctasks/internal/utils"
	"log"
	"os"
	"path/filepath"
	"sync"

	"github.com/go-playground/validator/v10"

	_ "embed"
)

var configOnce sync.Once

var globalConfig *Config

// var globalConnector *connectors.TaskConnector

//go:embed config.sample.json
var sampleConfig []byte

const (
	CONFIG_DIR_PATH  = "gosynctasks"
	CONFIG_FILE_PATH = "config.json"
	CONFIG_DIR_PERM  = 0755
	CONFIG_FILE_PERM = 0644
)

type Config struct {
	Connector      backend.ConnectorConfig `json:"connector"`
	CanWriteConfig bool                       `json:"canWriteConfig"`
}

func (c Config) Validate() error {
	validate := validator.New()
	return validate.Struct(c)
}

func GetConfig() *Config {
	configOnce.Do(func() {
		config, err := loadUserOrSampleConfig()
		if err != nil {
			log.Fatal(err)
		}
		globalConfig = config
	})
	return globalConfig
}

func loadUserOrSampleConfig() (*Config, error) {

	configPath, err := GetConfigPath()
	if err != nil {
		log.Fatalf("Config path couldn't be retrieved")
		return nil, err
	}
	configData, err := configDataFromPath(configPath)
	if err != nil {
		log.Fatalf("Config data couldn't be retrieved")
		return nil, err
	}
	configObj, err := parseConfig(configData, configPath)
	return configObj, err
}

func GetConfigPath() (string, error) {

	dir, err := os.UserConfigDir()

	if err != nil {
		return "", fmt.Errorf("failed to get user config dir: %w", err)
	}
	return filepath.Join(dir, CONFIG_DIR_PATH, CONFIG_FILE_PATH), nil
}

func createConfigDir(configPath string) error {
	return os.MkdirAll(filepath.Dir(configPath), CONFIG_DIR_PERM)
}
func WriteConfigFile(configPath string, data []byte) error {
	return os.WriteFile(configPath, data, CONFIG_FILE_PERM)
}

func createConfigFromSample(configPath string) []byte {
	var (
		configData []byte
		err        error
	)
	err = createConfigDir(configPath)
	if err != nil {
		log.Fatal(err)
	}
	configData = sampleConfig

	err = WriteConfigFile(configPath, configData)
	if err != nil {
		log.Fatal(err)
	}
	return configData
}

func parseConfig(configData []byte, configPath string) (*Config, error) {
	var configObj Config
	// configObj, err := UnmarshalJSON(configData)
	err := json.Unmarshal(configData, &configObj)

	if err != nil {
		log.Fatalf("Invalid JSON in config file %s: %v", configPath, err)
	}
	if err = configObj.Validate(); err != nil {
		log.Fatalf("Missing field(s) in JSON config file %s: %v", configPath, err)
	}
	return &configObj, err
}

func configDataFromPath(configPath string) ([]byte, error) {
	var (
		configData []byte
		err        error
	)

	configData, err = os.ReadFile(configPath)
	if os.IsNotExist(err) {
		fmt.Println("No config exist at ", configPath)

		shouldCopySample := utils.PromptYesNo("Do you want to copy config sample to " + configPath + "?")
		if shouldCopySample {
			configData = createConfigFromSample(configPath)

		} else {
			configData = sampleConfig
		}
	}

	return configData, nil

}

================
File: internal/config/config.sample.json
================
{
  "field1": "ok",
  "field2": 2
}

================
File: internal/utils/inputs.go
================
package utils

import (
	"bufio"
	"fmt"
	// "log"
	"os"
	"strings"
)

func PromptYesNo(question string) bool {
	reader := bufio.NewReader(os.Stdin)
	for {
		fmt.Printf("%s (y/n): ", question)
		response, _ := reader.ReadString('\n')
		response = strings.ToLower(strings.TrimSpace(response))

		switch response {
		case "y", "yes":
			return true
		case "n", "no":
			return false
		default:
			fmt.Println("Please enter y or n")
			return PromptYesNo(question)
		}
	}
}

================
File: .gitignore
================
# If you prefer the allow list template instead of the deny list, see community template:
# https://github.com/github/gitignore/blob/main/community/Golang/Go.AllowList.gitignore
#
# Binaries for programs and plugins
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary, built with `go test -c`
*.test

# Output of the go coverage tool, specifically when used with LiteIDE
*.out

# Dependency directories (remove the comment below to include it)
# vendor/

# Go workspace file
go.work
go.work.sum

# env file
.env

================
File: go.mod
================
module gosynctasks

go 1.24.3

require github.com/go-playground/validator/v10 v10.26.0

require (
	github.com/gabriel-vasile/mimetype v1.4.8 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	golang.org/x/crypto v0.33.0 // indirect
	golang.org/x/net v0.34.0 // indirect
	golang.org/x/sys v0.30.0 // indirect
	golang.org/x/text v0.23.0 // indirect
)

================
File: LICENSE
================
BSD 2-Clause License

Copyright (c) 2025, DeepReef11

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

================
File: README.md
================
## TODO:
- Add test for config file. Add function that backup the original config file and another that will put it back in place no matter what happen during test exec



================================================================
End of Codebase
================================================================
